#summary This page shows some examples outputs obtained with STAC for different inputs.

<wiki:toc max_depth="1" />

=Recursion=
----
{{{
// test.c
int main(int argc, char** argv)
{
    int x = foo (10, 10);
    int p1 = taint();
    int p2 = taint();
    int y = foo (foo_iterative(p1), p2);
    int tainted = taint();
    int z = foo (tainted, 100);
    int t = foo_iterative(z);
    int q = foo (foo_iterative(tainted), tainted);
    int p = foo (100, tainted);
    
    return 0;
}

int foo_iterative(int n)
{
    int prev;
    int prev_prev;
    int i;
    int aux = taint();
    
    prev = 1;
    prev_prev = 1;
    
    if (n < 1)
        return 0;
    for (i = 2; i <= n; ++ i) {
        aux = prev + prev_prev;
        prev = prev_prev;
        prev_prev = aux;
    }
    return prev_prev;
}

int foo(int n, int x) 
{
    int r = taint();
    if (n > 1)
        r = n * bar(n);
    else 
        r = 1;
    return r;
}

int bar(int n)
{
    int r = taint();
    if (n > 1)
        r = n * foo(n, 100);
    else 
        r = 1;
    return r;
} 
}}}
----
{{{ frama-c.byte -taint-analysis -print-results test.c }}}
----
{{{
Environment for function main:
========================================
	Symname: argc = Generic: Gamma(argc), 
	Symname: argv = Generic: Gamma(argv), 
	Symname: x = Untainted
	Symname: p1 = Tainted
	Symname: p2 = Tainted
	Symname: y = Tainted
	Symname: tmp_2 = Tainted
	Symname: tainted = Tainted
	Symname: z = Tainted
	Symname: t = Tainted
	Symname: q = Tainted
	Symname: tmp_7 = Tainted
	Symname: p = Untainted
	Symname: __retres = Untainted
	Symname: main = Untainted
========================================

Environment for function foo:
========================================
	Symname: n = Generic: Gamma(n), 
	Symname: x = Generic: Gamma(x), 
	Symname: r = Generic: Gamma(n), 
	Symname: tmp_0 = Generic: Gamma(n), 
	Symname: foo = Generic: Gamma(n), 
========================================

Environment for function foo_iterative:
========================================
	Symname: n = Generic: Gamma(n), 
	Symname: prev = Generic: Gamma(n), 
	Symname: prev_prev = Generic: Gamma(n), 
	Symname: i = Generic: Gamma(n), 
	Symname: aux = Tainted
	Symname: __retres = Generic: Gamma(n), 
	Symname: foo_iterative = Generic: Gamma(n), 
========================================

Environment for function bar:
========================================
	Symname: n = Generic: Gamma(n), 
	Symname: r = Generic: Gamma(n), 
	Symname: tmp_0 = Generic: Gamma(n), 
	Symname: bar = Generic: Gamma(n), 
========================================
}}}
----
{{{ frama-c.byte -taint-analysis -print-source test.c }}}
----
{{{
/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is false */

int foo(int n , int x ) ;
extern int ( /* missing proto */  taint)() ;
int foo_iterative(int n ) ;
int main(int argc , char **argv ) 
{ int x ;
  int p1 ;
  int p2 ;
  int y ;
  int tmp_2 ;
  int tainted ;
  int z ;
  int t ;
  int q ;
  int tmp_7 ;
  int p ;
  int __retres ;
  
  {/*sid:1*/
  x = foo(10, 10);
  /*sid:1*/
  /*T(argc) = G(argc)*/
  /*T(argv) = G(argv)*/
  /*T(x) = U*/
  /*T(p1) = U*/
  /*T(p2) = U*/
  /*T(y) = U*/
  /*T(tmp_2) = U*/
  /*T(tainted) = U*/
  /*T(z) = U*/
  /*T(t) = U*/
  /*T(q) = U*/
  /*T(tmp_7) = U*/
  /*T(p) = U*/
  /*T(__retres) = U*/
  /*T(main) = G(argc) + G(argv)*/
  
  /*sid:2*/
  p1 = taint();
  /*sid:2*/
  /*T(p1) = T*/
  
  /*sid:3*/
  p2 = taint();
  /*sid:3*/
  /*T(p2) = T*/
  
  /*sid:4*/
  tmp_2 = foo_iterative(p1);
  /*sid:4*/
  /*T(tmp_2) = T*/
  
  /*sid:5*/
  y = foo(tmp_2, p2);
  /*sid:5*/
  /*T(y) = T*/
  
  /*sid:6*/
  tainted = taint();
  /*sid:6*/
  /*T(tainted) = T*/
  
  /*sid:7*/
  z = foo(tainted, 100);
  /*sid:7*/
  /*T(z) = T*/
  
  /*sid:8*/
  t = foo_iterative(z);
  /*sid:8*/
  /*T(t) = T*/
  
  /*sid:9*/
  tmp_7 = foo_iterative(tainted);
  /*sid:9*/
  /*T(tmp_7) = T*/
  
  /*sid:10*/
  q = foo(tmp_7, tainted);
  /*sid:10*/
  /*T(q) = T*/
  
  p = foo(100, tainted);
  __retres = 0;
  /*sid:46*/
  return (__retres);
  /*sid:46*/
  /*T(main) = U*/
  }

}
int foo_iterative(int n ) 
{ int prev ;
  int prev_prev ;
  int i ;
  int aux ;
  int __retres ;
  
  {/*sid:13*/
  aux = taint();
  /*sid:13*/
  /*T(n) = G(n)*/
  /*T(prev) = U*/
  /*T(prev_prev) = U*/
  /*T(i) = U*/
  /*T(aux) = T*/
  /*T(__retres) = U*/
  /*T(foo_iterative) = G(n)*/
  
  prev = 1;
  prev_prev = 1;
  if (n < 1) {/*sid:18*/
    __retres = 0;
    /*sid:18*/
    /*T(__retres) = G(n)*/
    
    goto return_label;}
  
  /*sid:20*/
  i = 2;
  /*sid:20*/
  /*T(i) = G(n)*/
  
  /*sid:21*/
  while (i <= n) {/*sid:25*/
    aux = prev + prev_prev;
    /*sid:25*/
    /*T(aux) = G(n)*/
    
    prev = prev_prev;
    prev_prev = aux;
    /*sid:28*/
    i ++;
    /*sid:28*/
    /*T(aux) = T*/
    }
  
  /*sid:21*/
  /*T(prev) = G(n)*/
  /*T(prev_prev) = G(n)*/
  
  /*sid:29*/
  __retres = prev_prev;
  /*sid:29*/
  /*T(__retres) = G(n)*/
  
  /*sid:48*/
  return_label: /* CIL Label */ 
  return (__retres);
  /*sid:48*/
  /*T(prev) = G(n)*/
  /*T(prev_prev) = G(n)*/
  /*T(i) = G(n)*/
  }

}
int bar(int n ) ;
int foo(int n , int x ) 
{ int r ;
  int tmp_0 ;
  
  {/*sid:30*/
  r = taint();
  /*sid:30*/
  /*T(n) = G(n)*/
  /*T(x) = G(x)*/
  /*T(r) = T*/
  /*T(tmp_0) = U*/
  /*T(foo) = G(n) + G(x)*/
  
  if (n > 1)
  {{/*sid:34*/
    tmp_0 = bar(n);
    /*sid:34*/
    /*T(tmp_0) = G(n)*/
    
    /*sid:35*/
    r = n * tmp_0;
    /*sid:35*/
    /*T(r) = G(n)*/
    }}
  else {/*sid:36*/
  r = 1;
  /*sid:36*/
  /*T(r) = G(n)*/
  /*T(tmp_0) = G(n)*/
  }
  
  /*sid:37*/
  return (r);
  /*sid:37*/
  /*T(foo) = G(n)*/
  }

}
int bar(int n ) 
{ int r ;
  int tmp_0 ;
  
  {/*sid:38*/
  r = taint();
  /*sid:38*/
  /*T(n) = G(n)*/
  /*T(r) = T*/
  /*T(tmp_0) = U*/
  /*T(bar) = G(n)*/
  
  if (n > 1)
  {{/*sid:42*/
    tmp_0 = foo(n, 100);
    /*sid:42*/
    /*T(tmp_0) = G(n)*/
    
    /*sid:43*/
    r = n * tmp_0;
    /*sid:43*/
    /*T(r) = G(n)*/
    }}
  else {/*sid:44*/
  r = 1;
  /*sid:44*/
  /*T(r) = G(n)*/
  /*T(tmp_0) = G(n)*/
  }
  
  return (r);}
}
}}}