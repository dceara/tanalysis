#summary This page shows some examples outputs obtained with STAC for different inputs.

<wiki:toc max_depth="1" />

=Recursion=
{{{
// test.c
int main(int argc, char** argv)
{
    int x = foo (10, 10);
    int p1 = taint();
    int p2 = taint();
    int y = foo (foo_iterative(p1), p2);
    int tainted = taint();
    int z = foo (tainted, 100);
    int t = foo_iterative(z);
    int q = foo (foo_iterative(tainted), tainted);
    int p = foo (100, tainted);
    
    return 0;
}

int foo_iterative(int n)
{
    int prev;
    int prev_prev;
    int i;
    int aux = taint();
    
    prev = 1;
    prev_prev = 1;
    
    if (n < 1)
        return 0;
    for (i = 2; i <= n; ++ i) {
        aux = prev + prev_prev;
        prev = prev_prev;
        prev_prev = aux;
    }
    return prev_prev;
}

int foo(int n, int x) 
{
    int r = taint();
    if (n > 1)
        r = n * bar(n);
    else 
        r = 1;
    return r;
}

int bar(int n)
{
    int r = taint();
    if (n > 1)
        r = n * foo(n, 100);
    else 
        r = 1;
    return r;
} 
}}}
----
<code title="test code"> frama-c.byte -taint-analysis -print-results test.c </code>
----
{{{
Environment for function main:
========================================
	Symname: argc = Generic: Gamma(argc), 
	Symname: argv = Generic: Gamma(argv), 
	Symname: x = Untainted
	Symname: p1 = Tainted
	Symname: p2 = Tainted
	Symname: y = Tainted
	Symname: tmp_2 = Tainted
	Symname: tainted = Tainted
	Symname: z = Tainted
	Symname: t = Tainted
	Symname: q = Tainted
	Symname: tmp_7 = Tainted
	Symname: p = Untainted
	Symname: __retres = Untainted
	Symname: main = Untainted
========================================

Environment for function foo:
========================================
	Symname: n = Generic: Gamma(n), 
	Symname: x = Generic: Gamma(x), 
	Symname: r = Generic: Gamma(n), 
	Symname: tmp_0 = Generic: Gamma(n), 
	Symname: foo = Generic: Gamma(n), 
========================================

Environment for function foo_iterative:
========================================
	Symname: n = Generic: Gamma(n), 
	Symname: prev = Generic: Gamma(n), 
	Symname: prev_prev = Generic: Gamma(n), 
	Symname: i = Generic: Gamma(n), 
	Symname: aux = Tainted
	Symname: __retres = Generic: Gamma(n), 
	Symname: foo_iterative = Generic: Gamma(n), 
========================================

Environment for function bar:
========================================
	Symname: n = Generic: Gamma(n), 
	Symname: r = Generic: Gamma(n), 
	Symname: tmp_0 = Generic: Gamma(n), 
	Symname: bar = Generic: Gamma(n), 
========================================
}}}
----
{{{ frama-c.byte -taint-analysis -print-source test.c }}}
----
{{{
int foo(int n , int x ) ;
extern int ( /* missing proto */  taint)() ;
int foo_iterative(int n ) ;
int main(int argc , char **argv ) 
{ int x ;
  int p1 ;
  int p2 ;
  int y ;
  int tmp_2 ;
  int tainted ;
  int z ;
  int t ;
  int q ;
  int tmp_7 ;
  int p ;
  int __retres ;
  
  {/*sid:1*/
  x = foo(10, 10);
  /*sid:1*/
  /*T(argc) = G(argc)*/
  /*T(argv) = G(argv)*/
  /*T(x) = U*/
  /*T(p1) = U*/
  /*T(p2) = U*/
  /*T(y) = U*/
  /*T(tmp_2) = U*/
  /*T(tainted) = U*/
  /*T(z) = U*/
  /*T(t) = U*/
  /*T(q) = U*/
  /*T(tmp_7) = U*/
  /*T(p) = U*/
  /*T(__retres) = U*/
  /*T(main) = G(argc) + G(argv)*/
  
  /*sid:2*/
  p1 = taint();
  /*sid:2*/
  /*T(p1) = T*/
  
  /*sid:3*/
  p2 = taint();
  /*sid:3*/
  /*T(p2) = T*/
  
  /*sid:4*/
  tmp_2 = foo_iterative(p1);
  /*sid:4*/
  /*T(tmp_2) = T*/
  
  /*sid:5*/
  y = foo(tmp_2, p2);
  /*sid:5*/
  /*T(y) = T*/
  
  /*sid:6*/
  tainted = taint();
  /*sid:6*/
  /*T(tainted) = T*/
  
  /*sid:7*/
  z = foo(tainted, 100);
  /*sid:7*/
  /*T(z) = T*/
  
  /*sid:8*/
  t = foo_iterative(z);
  /*sid:8*/
  /*T(t) = T*/
  
  /*sid:9*/
  tmp_7 = foo_iterative(tainted);
  /*sid:9*/
  /*T(tmp_7) = T*/
  
  /*sid:10*/
  q = foo(tmp_7, tainted);
  /*sid:10*/
  /*T(q) = T*/
  
  p = foo(100, tainted);
  __retres = 0;
  /*sid:46*/
  return (__retres);
  /*sid:46*/
  /*T(main) = U*/
  }

}
int foo_iterative(int n ) 
{ int prev ;
  int prev_prev ;
  int i ;
  int aux ;
  int __retres ;
  
  {/*sid:13*/
  aux = taint();
  /*sid:13*/
  /*T(n) = G(n)*/
  /*T(prev) = U*/
  /*T(prev_prev) = U*/
  /*T(i) = U*/
  /*T(aux) = T*/
  /*T(__retres) = U*/
  /*T(foo_iterative) = G(n)*/
  
  prev = 1;
  prev_prev = 1;
  if (n < 1) {/*sid:18*/
    __retres = 0;
    /*sid:18*/
    /*T(__retres) = G(n)*/
    
    goto return_label;}
  
  /*sid:20*/
  i = 2;
  /*sid:20*/
  /*T(i) = G(n)*/
  
  /*sid:21*/
  while (i <= n) {/*sid:25*/
    aux = prev + prev_prev;
    /*sid:25*/
    /*T(aux) = G(n)*/
    
    prev = prev_prev;
    prev_prev = aux;
    /*sid:28*/
    i ++;
    /*sid:28*/
    /*T(aux) = T*/
    }
  
  /*sid:21*/
  /*T(prev) = G(n)*/
  /*T(prev_prev) = G(n)*/
  
  /*sid:29*/
  __retres = prev_prev;
  /*sid:29*/
  /*T(__retres) = G(n)*/
  
  /*sid:48*/
  return_label: /* CIL Label */ 
  return (__retres);
  /*sid:48*/
  /*T(prev) = G(n)*/
  /*T(prev_prev) = G(n)*/
  /*T(i) = G(n)*/
  }

}
int bar(int n ) ;
int foo(int n , int x ) 
{ int r ;
  int tmp_0 ;
  
  {/*sid:30*/
  r = taint();
  /*sid:30*/
  /*T(n) = G(n)*/
  /*T(x) = G(x)*/
  /*T(r) = T*/
  /*T(tmp_0) = U*/
  /*T(foo) = G(n) + G(x)*/
  
  if (n > 1)
  {{/*sid:34*/
    tmp_0 = bar(n);
    /*sid:34*/
    /*T(tmp_0) = G(n)*/
    
    /*sid:35*/
    r = n * tmp_0;
    /*sid:35*/
    /*T(r) = G(n)*/
    }}
  else {/*sid:36*/
  r = 1;
  /*sid:36*/
  /*T(r) = G(n)*/
  /*T(tmp_0) = G(n)*/
  }
  
  /*sid:37*/
  return (r);
  /*sid:37*/
  /*T(foo) = G(n)*/
  }

}
int bar(int n ) 
{ int r ;
  int tmp_0 ;
  
  {/*sid:38*/
  r = taint();
  /*sid:38*/
  /*T(n) = G(n)*/
  /*T(r) = T*/
  /*T(tmp_0) = U*/
  /*T(bar) = G(n)*/
  
  if (n > 1)
  {{/*sid:42*/
    tmp_0 = foo(n, 100);
    /*sid:42*/
    /*T(tmp_0) = G(n)*/
    
    /*sid:43*/
    r = n * tmp_0;
    /*sid:43*/
    /*T(r) = G(n)*/
    }}
  else {/*sid:44*/
  r = 1;
  /*sid:44*/
  /*T(r) = G(n)*/
  /*T(tmp_0) = G(n)*/
  }
  
  return (r);}
}
}}}
----
=Pointers as parameters=
{{{
// test.c
int main(int argc, char** argv) 
{
    int tainted = taint();
    int result_test = 1;
    int result_tainted = 1;
    int result_generic = 1;
    int result_generic2 = argc; 
    factorial(&result_test, 100);
    factorial(&result_tainted, tainted);
    factorial(&result_generic, argc);
    factorial(&result_generic2, 1000);
    return 0;
} 


void factorial(int *result, int n)
{
    if (n == 0)
        return;
    *result = *result * n;
    factorial (result, n - 1);
}
}}}
----
{{{ frama-c.byte -taint-analysis -print-final test.c }}}
----
{{{
Environment for function main:
========================================
	Symname: argc = Generic: Gamma(argc), 
	Symname: argv = Generic: Gamma(argv), 
	Symname: tainted = Tainted
	Symname: result_test = Untainted
	Symname: result_tainted = Tainted
	Symname: result_generic = Generic: Gamma(argc), 
	Symname: result_generic2 = Generic: Gamma(argc), 
	Symname: __retres = Untainted
	Symname: main = Untainted
========================================

Environment for function factorial:
========================================
	Symname: result = Generic: Gamma(n), Gamma(result), 
	Symname: n = Generic: Gamma(n), 
	Symname: factorial = Untainted
========================================
}}}
----
{{{ frama-c.byte -taint-analysis -print-source test.c }}}
----
{{{
extern int ( /* missing proto */  taint)() ;
void factorial(int *result , int n ) ;
int main(int argc , char **argv ) 
{ int tainted ;
  int result_test ;
  int result_tainted ;
  int result_generic ;
  int result_generic2 ;
  int __retres ;
  
  {/*sid:1*/
  tainted = taint();
  /*sid:1*/
  /*T(argc) = G(argc)*/
  /*T(argv) = G(argv)*/
  /*T(tainted) = T*/
  /*T(result_test) = U*/
  /*T(result_tainted) = U*/
  /*T(result_generic) = U*/
  /*T(result_generic2) = U*/
  /*T(__retres) = U*/
  /*T(main) = G(argc) + G(argv)*/
  
  result_test = 1;
  result_tainted = 1;
  result_generic = 1;
  /*sid:6*/
  result_generic2 = argc;
  /*sid:6*/
  /*T(result_generic2) = G(argc)*/
  
  factorial(& result_test, 100);
  /*sid:8*/
  factorial(& result_tainted, tainted);
  /*sid:8*/
  /*T(result_tainted) = T*/
  
  /*sid:9*/
  factorial(& result_generic, argc);
  /*sid:9*/
  /*T(result_generic) = G(argc)*/
  
  factorial(& result_generic2, 1000);
  __retres = 0;
  /*sid:19*/
  return (__retres);
  /*sid:19*/
  /*T(main) = U*/
  }

}
void factorial(int *result , int n ) 
{ 
  
  {/*sid:13*/
  if (n == 0) {goto return_label;}
  
  /*sid:13*/
  /*T(result) = G(result)*/
  /*T(n) = G(n)*/
  /*T(factorial) = G(result) + G(n)*/
  
  /*sid:16*/
  *result *= n;
  /*sid:16*/
  /*T(result) = G(n) + G(result)*/
  
  factorial(result, n - 1);
  /*sid:21*/
  return_label: /* CIL Label */ 
  return;
  /*sid:21*/
  /*T(result) = G(n) + G(result)*/
  /*T(factorial) = U*/
  }
}
}}}
----
=Loops=
{{{
// test.c
int main(int argc, int argc2, char** argv) //argc = G, argv = G
{
    int a, b, c, d, tainted, i;
    int a1, b1, c1, d1, i1;
    a = b = d = 0;
    c = tainted = taint();
    for (i = 0; i < argc; ++ i) {
        a++;
        while (b < 500) {
            do {
                c = argc + 1;
            } while (c < argc);
        }
        b+=tainted;
    }
    a1 = b1 = c1 = d1 = 0;
    for (i1 = 0; i1 < argc; ++ i1) {
        a1++;
        while (b1 < 500) {
            do {
                c1 = argc + 1;
            } while (c1 < argc); 
        }
        b1+=2;
    }
    return 0;
}
}}}
----
{{{ frama-c.byte -taint-analysis -print-final test.c }}}
----
{{{
Environment for function main:
========================================
	Symname: argc = Generic: Gamma(argc), 
	Symname: argc2 = Generic: Gamma(argc2), 
	Symname: argv = Generic: Gamma(argv), 
	Symname: a = Generic: Gamma(argc), 
	Symname: b = Tainted
	Symname: c = Tainted
	Symname: d = Untainted
	Symname: tainted = Tainted
	Symname: i = Generic: Gamma(argc), 
	Symname: a1 = Generic: Gamma(argc), 
	Symname: b1 = Generic: Gamma(argc), 
	Symname: c1 = Generic: Gamma(argc), 
	Symname: d1 = Untainted
	Symname: i1 = Generic: Gamma(argc), 
	Symname: __retres = Untainted
	Symname: main = Untainted
========================================
}}}
----
{{{ frama-c.byte -taint-analysis -print-source test.c }}}
----
{{{
extern int ( /* missing proto */  taint)() ;
int main(int argc , int argc2 , char **argv ) 
{ int a ;
  int b ;
  int c ;
  int d ;
  int tainted ;
  int i ;
  int a1 ;
  int b1 ;
  int c1 ;
  int d1 ;
  int i1 ;
  int __retres ;
  
  {/*sid:1*/
  {d = 0;
   b = d;
   a = b;}
  /*sid:1*/
  /*T(argc) = G(argc)*/
  /*T(argc2) = G(argc2)*/
  /*T(argv) = G(argv)*/
  /*T(a) = U*/
  /*T(b) = U*/
  /*T(c) = U*/
  /*T(d) = U*/
  /*T(tainted) = U*/
  /*T(i) = U*/
  /*T(a1) = U*/
  /*T(b1) = U*/
  /*T(c1) = U*/
  /*T(d1) = U*/
  /*T(i1) = U*/
  /*T(__retres) = U*/
  /*T(main) = G(argc2) + G(argc) + G(argv)*/
  
  {/*sid:6*/
   tainted = taint();
   /*sid:6*/
   /*T(tainted) = T*/
   
   /*sid:7*/
   c = tainted;
   /*sid:7*/
   /*T(c) = T*/
   }
  i = 0;
  /*sid:9*/
  while (i < argc) {a ++;
    while (b < 500) {while (1) {c = argc + 1;
                       if (! (c < argc)) {break;}
                       }
      }
    
    b += tainted;
    i ++;}
  
  /*sid:9*/
  /*T(a) = G(argc)*/
  /*T(b) = T*/
  /*T(i) = G(argc)*/
  
  {d1 = 0;
   c1 = d1;
   b1 = c1;
   a1 = b1;}
  i1 = 0;
  /*sid:31*/
  while (i1 < argc) {a1 ++;
    while (b1 < 500) {while (1) {c1 = argc + 1;
                        if (! (c1 < argc)) {break;}
                        }
      }
    
    b1 += 2;
    i1 ++;}
  
  /*sid:31*/
  /*T(a1) = G(argc)*/
  /*T(b1) = G(argc)*/
  /*T(c1) = G(argc)*/
  /*T(i1) = G(argc)*/
  
  __retres = 0;
  /*sid:48*/
  return (__retres);
  /*sid:48*/
  /*T(main) = U*/
  }
}
}}}
----
=Small Picture Editor=
{{{
// utils.h
#ifndef __UTILS_H
#define __UTILS_H

#include <stdio.h>

#define CHECK(condition, error_label, error_message) \
	do { \
		if (!(condition)) { \
			perror(error_message); \
			goto error_label; \
		} \
	} while(0)

#endif
}}}
----
{{{
// common.c
#include <stdio.h>
#include <stdlib.h>
#include "common.h"
#include "utils.h"

int read_config(char* input_file, int* n, int* config, int max_size)
{
	FILE* fi;
	int i, j, k, _n;
	
	fi = fopen(input_file, "r");
	fscanf(fi, "%d", n);
	_n = *n;
	for(i = 0; i < _n; ++ i) {
		for (j = 0; j < _n; ++ j) {
			for (k = 0; k < _n; ++ k) {
				fscanf(fi, "%d", &config[i * _n * _n + j * _n + k]);
			}
		}
	}
		
	fclose(fi);
	return 0;
read_err:
    fclose(fi);	
fopen_err:
	return -1;
}

static inline int max(int x, int y) 
{
	return x < y ? y : x;
}

static inline int min(int x, int y)
{
	return x < y ? x : y;
}

static inline int max_distance(int x, int y, int z)
{
	return (x + y + z) / 5 + 1;
}

int is_alive(int x, int y, int z, int* config, int n)
{
	int i, j, k, d;
	int alive_cnt = 0;
	int cnt = 0;
	int i_min, i_max, j_min, j_max, k_min, k_max;
	d = max_distance(x, y, z);
	i_min = max(x - d, 0);
	i_max = min(x + d + 1, n);
	j_min = max(y - d, 0);
	j_max = min(y + d + 1, n);
	k_min = max(z - d, 0);
	k_max = min(z + d + 1, n);
	for (i = i_min; i < i_max; ++ i) {
		for (j = j_min; j < j_max; ++ j) {
			for (k = k_min; k < k_max; ++ k) {
				if (x == i && y == j && z == k)
					continue;
				if (config[i * n * n + j * n + k]) 
					++ alive_cnt;
				++ cnt;
			}	
		}
	}
	if (alive_cnt * 100 < cnt * LOWER_DEATH_LIMIT)
		return 0;
	
	if (alive_cnt * 100 > cnt * UPPER_DEATH_LIMIT)
		return 0;
	
	if (alive_cnt * 100 > cnt * LOWER_CHANGE_LIMIT && alive_cnt * 100 < cnt * UPPER_CHANGE_LIMIT) {
		if (config[x * n * n + y * n + z]) 
			return 0;
		return 1;
	}
	return 1;
}

int print_config(char* output_file, int n, int g, int* config, int* alive)
{
	FILE* fo;
	int i, j, k;

	CHECK((fo = fopen(output_file, "w")) != NULL, fopen_err, "Unable to open output file");

	for (i = 0; i < n; ++ i) {
		for (j = 0; j < n; ++ j) {
			for (k = 0; k < n; ++ k) {
				CHECK((fprintf(fo, "%d ", config[i * n * n + j * n + k]) != 0), write_err, "Unable to write to output file");
			}
			fprintf(fo, "\n");
		}
		fprintf(fo, "\n");
	}

	for (i = 0; i < g; ++ i) {
		CHECK((fprintf(fo, "%d\n", alive[i]) != 0), write_err, "Unable to write to output file"); 
	}
	fclose(fo);
	return 0;
write_err:
	fclose(fo);
fopen_err:
	return -1;
}

int dbg_print_config(int n, int* config)
{
	int i, j, k;
	for (i = 0; i < n; ++ i) {
		for (j = 0; j < n; ++ j) {
			for (k = 0; k < n; ++ k) {
				printf("%d ", config[i * n * n + j * n + k]);
			}
			printf("\n");
		}
		printf("\n\n");
	}
	printf("\n");
	return 0;
}
}}}
----
{{{
// main.c
#include <stdio.h>
#include <stdlib.h>
#include "common.h"
#include "utils.h"


#define MAX_N 128
#define MAX_CELLS (MAX_N * MAX_N * MAX_N)
#define MAX_G 256

int cube[MAX_CELLS], alive[MAX_G], tmp_cube[MAX_CELLS];
int n, g;

int main(int argc, char** argv) 
{
	int i, j, k, cnt;
	int* old_config;
	int* curr_config;
	int* aux;

	g = strtol(argv[1], (char **)NULL, 10);

	CHECK((read_config(argv[2], &n, cube, MAX_N) == 0), err, "Unable to read initial config");

	old_config = cube;
	curr_config = tmp_cube;
	for (cnt = 0; cnt < g; ++ cnt) {
		for (i = 0; i < n; ++ i) {
			for (j = 0; j < n; ++ j) {
				for (k = 0; k < n; ++ k) {
					if (is_alive(i, j, k, old_config, n)) {
						curr_config[i * n * n + j * n + k] = 1;
						++ alive[cnt];
					} else {
						curr_config[i * n * n + j * n + k] = 0;
					}
				}
			}
		}
		aux = old_config;
		old_config = curr_config;
		curr_config = aux;
	}

	exit(print_config(argv[3], n , g, old_config, alive));

err:
	exit(1);
}
}}}
----
{{{ frama-c.byte -taint-analysis -print-final *.c }}}
----
{{{
Environment for function main:
========================================
	Symname: cube = Generic: Gamma(cube), 
	Symname: alive = Generic: Gamma(alive), 
	Symname: tmp_cube = Generic: Gamma(tmp_cube), 
	Symname: n = Generic: Gamma(n), 
	Symname: g = Generic: Gamma(g), 
	Symname: argc = Generic: Gamma(argc), 
	Symname: argv = Generic: Gamma(argv), 
	Symname: i = Untainted
	Symname: j = Untainted
	Symname: k = Untainted
	Symname: cnt = Untainted
	Symname: old_config = Untainted
	Symname: curr_config = Untainted
	Symname: aux = Untainted
	Symname: tmp = Untainted
	Symname: tmp_0 = Untainted
	Symname: tmp_1 = Untainted
	Symname: __retres = Untainted
	Symname: main = Generic: Gamma(n), Gamma(alive), Gamma(argv), Gamma(argc), Gamma(cube), Gamma(tmp_cube), Gamma(g), 
========================================

Environment for function max:
========================================
	Symname: cube = Generic: Gamma(cube), 
	Symname: alive = Generic: Gamma(alive), 
	Symname: tmp_cube = Generic: Gamma(tmp_cube), 
	Symname: n = Generic: Gamma(n), 
	Symname: g = Generic: Gamma(g), 
	Symname: max = Generic: Gamma(x), Gamma(y), 
	Symname: x = Generic: Gamma(x), 
	Symname: y = Generic: Gamma(y), 
	Symname: tmp = Generic: Gamma(x), Gamma(y), 
========================================

Environment for function min:
========================================
	Symname: cube = Generic: Gamma(cube), 
	Symname: alive = Generic: Gamma(alive), 
	Symname: tmp_cube = Generic: Gamma(tmp_cube), 
	Symname: n = Generic: Gamma(n), 
	Symname: g = Generic: Gamma(g), 
	Symname: min = Generic: Gamma(x), Gamma(y), 
	Symname: x = Generic: Gamma(x), 
	Symname: y = Generic: Gamma(y), 
	Symname: tmp = Generic: Gamma(x), Gamma(y), 
========================================

Environment for function max_distance:
========================================
	Symname: cube = Generic: Gamma(cube), 
	Symname: alive = Generic: Gamma(alive), 
	Symname: tmp_cube = Generic: Gamma(tmp_cube), 
	Symname: n = Generic: Gamma(n), 
	Symname: g = Generic: Gamma(g), 
	Symname: __retres = Generic: Gamma(y), Gamma(x), Gamma(z), 
	Symname: max_distance = Generic: Gamma(y), Gamma(x), Gamma(z), 
	Symname: x = Generic: Gamma(x), 
	Symname: y = Generic: Gamma(y), 
	Symname: z = Generic: Gamma(z), 
========================================

Environment for function read_config:
========================================
	Symname: read_config = Untainted
	Symname: cube = Generic: Gamma(cube), 
	Symname: alive = Generic: Gamma(alive), 
	Symname: tmp_cube = Generic: Gamma(tmp_cube), 
	Symname: n = Generic: Gamma(n), 
	Symname: g = Generic: Gamma(g), 
	Symname: __retres = Untainted
	Symname: input_file = Generic: Gamma(input_file), 
	Symname: n_0 = Tainted
	Symname: config = Tainted
	Symname: max_size = Generic: Gamma(max_size), 
	Symname: fi = Tainted
	Symname: i = Tainted
	Symname: j = Tainted
	Symname: k = Tainted
	Symname: _n = Tainted
========================================

Environment for function print_config:
========================================
	Symname: print_config = Generic: Gamma(n_0), 
	Symname: cube = Generic: Gamma(config), Gamma(n_0), Gamma(g_0), Gamma(alive_0), Gamma(cube), 
	Symname: alive = Generic: Gamma(config), Gamma(n_0), Gamma(g_0), Gamma(alive_0), Gamma(alive), 
	Symname: tmp_cube = Generic: Gamma(config), Gamma(n_0), Gamma(g_0), Gamma(alive_0), Gamma(tmp_cube), 
	Symname: n = Generic: Gamma(config), Gamma(n_0), Gamma(g_0), Gamma(alive_0), Gamma(n), 
	Symname: g = Generic: Gamma(config), Gamma(n_0), Gamma(g_0), Gamma(alive_0), Gamma(g), 
	Symname: __retres = Generic: Gamma(n_0), 
	Symname: output_file = Generic: Gamma(output_file), 
	Symname: n_0 = Generic: Gamma(n_0), 
	Symname: g_0 = Generic: Gamma(g_0), 
	Symname: config = Generic: Gamma(config), 
	Symname: alive_0 = Generic: Gamma(alive_0), 
	Symname: fo = Untainted
	Symname: i = Generic: Gamma(n_0), Gamma(g_0), 
	Symname: j = Generic: Gamma(n_0), 
	Symname: k = Generic: Gamma(n_0), 
	Symname: tmp = Generic: Gamma(n_0), 
	Symname: tmp_0 = Generic: Gamma(g_0), 
========================================

Environment for function dbg_print_config:
========================================
	Symname: dbg_print_config = Untainted
	Symname: cube = Generic: Gamma(n_0), Gamma(config), Gamma(cube), 
	Symname: alive = Generic: Gamma(n_0), Gamma(config), Gamma(alive), 
	Symname: tmp_cube = Generic: Gamma(n_0), Gamma(config), Gamma(tmp_cube), 
	Symname: n = Generic: Gamma(n_0), Gamma(config), Gamma(n), 
	Symname: g = Generic: Gamma(n_0), Gamma(config), Gamma(g), 
	Symname: __retres = Untainted
	Symname: n_0 = Generic: Gamma(n_0), 
	Symname: config = Generic: Gamma(config), 
	Symname: i = Generic: Gamma(n_0), 
	Symname: j = Generic: Gamma(n_0), 
	Symname: k = Generic: Gamma(n_0), 
========================================

Environment for function is_alive:
========================================
	Symname: is_alive = Generic: Gamma(config), Gamma(z), Gamma(y), Gamma(x), Gamma(n_0), 
	Symname: cube = Generic: Gamma(cube), 
	Symname: alive = Generic: Gamma(alive), 
	Symname: tmp_cube = Generic: Gamma(tmp_cube), 
	Symname: n = Generic: Gamma(n), 
	Symname: g = Generic: Gamma(g), 
	Symname: __retres = Generic: Gamma(config), Gamma(z), Gamma(y), Gamma(x), Gamma(n_0), 
	Symname: x = Generic: Gamma(x), 
	Symname: y = Generic: Gamma(y), 
	Symname: z = Generic: Gamma(z), 
	Symname: config = Generic: Gamma(config), 
	Symname: n_0 = Generic: Gamma(n_0), 
	Symname: i = Generic: Gamma(n_0), Gamma(x), Gamma(y), Gamma(z), 
	Symname: j = Generic: Gamma(z), Gamma(y), Gamma(x), Gamma(n_0), 
	Symname: k = Generic: Gamma(z), Gamma(y), Gamma(x), Gamma(n_0), 
	Symname: d = Generic: Gamma(x), Gamma(y), Gamma(z), 
	Symname: alive_cnt = Generic: Gamma(config), Gamma(z), Gamma(y), Gamma(x), Gamma(n_0), 
	Symname: cnt = Generic: Gamma(z), Gamma(y), Gamma(x), Gamma(n_0), 
	Symname: i_min = Generic: Gamma(x), Gamma(y), Gamma(z), 
	Symname: i_max = Generic: Gamma(z), Gamma(y), Gamma(x), Gamma(n_0), 
	Symname: j_min = Generic: Gamma(x), Gamma(y), Gamma(z), 
	Symname: j_max = Generic: Gamma(z), Gamma(y), Gamma(x), Gamma(n_0), 
	Symname: k_min = Generic: Gamma(x), Gamma(y), Gamma(z), 
	Symname: k_max = Generic: Gamma(z), Gamma(y), Gamma(x), Gamma(n_0), 
========================================
}}}
----
{{{ frama-c.byte -taint-analysis -print-source *.c }}}
----
{{{
typedef unsigned int size_t;
typedef long long __quad_t;
typedef long __off_t;
typedef __quad_t __off64_t;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename ,
                   char const   * __restrict  __modes ) ;
extern int fprintf(FILE * __restrict  __stream ,
                   char const   * __restrict  __format  , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern int fscanf(FILE * __restrict  __stream ,
                  char const   * __restrict  __format  , ...) ;
extern void perror(char const   *__s ) ;
int read_config(char *input_file , int *n_0 , int *config , int max_size ) ;
int print_config(char *output_file , int n_0 , int g_0 , int *config ,
                 int *alive_0 ) ;
int dbg_print_config(int n_0 , int *config ) ;
int is_alive(int x , int y , int z , int *config , int n_0 ) ;
int read_config(char *input_file , int *n_0 , int *config , int max_size ) 
{ FILE *fi ;
  int i ;
  int j ;
  int k ;
  int _n ;
  int __retres ;
  
  {/*sid:1*/
  fi = fopen((char const   *)input_file, (char const   *)"r");
  /*sid:1*/
  /*T(read_config) = G(n) + G(alive) + G(max_size) + G(n_0) + G(input_file) + G(config) + G(cube) + G(tmp_cube) + G(g)*/
  /*T(cube) = G(cube)*/
  /*T(alive) = G(alive)*/
  /*T(tmp_cube) = G(tmp_cube)*/
  /*T(n) = G(n)*/
  /*T(g) = G(g)*/
  /*T(__retres) = U*/
  /*T(input_file) = G(input_file)*/
  /*T(n_0) = G(n_0)*/
  /*T(config) = G(config)*/
  /*T(max_size) = G(max_size)*/
  /*T(fi) = U*/
  /*T(i) = U*/
  /*T(j) = U*/
  /*T(k) = U*/
  /*T(_n) = U*/
  
  /*sid:2*/
  fscanf((FILE *)fi, (char const   *)"%d", n_0);
  /*sid:2*/
  /*T(n_0) = T*/
  /*T(fi) = T*/
  
  /*sid:3*/
  _n = *n_0;
  /*sid:3*/
  /*T(_n) = T*/
  
  i = 0;
  /*sid:5*/
  while (i < _n) {j = 0;
    while (j < _n) {k = 0;
      while (k < _n) {fscanf((FILE *)fi, (char const   *)"%d",
                             config + (((i * _n) * _n + j * _n) + k));
        k ++;}
      
      j ++;}
    
    i ++;}
  
  /*sid:5*/
  /*T(config) = T*/
  /*T(i) = T*/
  /*T(j) = T*/
  /*T(k) = T*/
  
  fclose(fi);
  __retres = 0;
  goto return_label;
  /*sid:26*/
  fclose(fi);
  /*sid:26*/
  /*T(read_config) = G(n) + G(alive) + G(max_size) + G(n_0) + G(input_file) + G(config) + G(cube) + G(tmp_cube) + G(g)*/
  /*T(cube) = G(cube)*/
  /*T(alive) = G(alive)*/
  /*T(tmp_cube) = G(tmp_cube)*/
  /*T(n) = G(n)*/
  /*T(g) = G(g)*/
  /*T(__retres) = U*/
  /*T(input_file) = G(input_file)*/
  /*T(n_0) = G(n_0)*/
  /*T(config) = G(config)*/
  /*T(max_size) = G(max_size)*/
  /*T(fi) = U*/
  /*T(i) = U*/
  /*T(j) = U*/
  /*T(k) = U*/
  /*T(_n) = U*/
  
  __retres = -1;
  /*sid:223*/
  return_label: /* CIL Label */ 
  return (__retres);
  /*sid:223*/
  /*T(read_config) = U*/
  /*T(n_0) = T*/
  /*T(config) = T*/
  /*T(fi) = T*/
  /*T(i) = T*/
  /*T(j) = T*/
  /*T(k) = T*/
  /*T(_n) = T*/
  }

}
__inline static int max(int x , int y ) 
{ int tmp ;
  
  {/*sid:29*/
  if (x < y) {/*sid:30*/
  tmp = y;
  /*sid:30*/
  /*T(tmp) = G(x) + G(y)*/
  }
  else {/*sid:31*/
  tmp = x;
  /*sid:31*/
  /*T(tmp) = G(x) + G(y)*/
  }
  
  /*sid:29*/
  /*T(cube) = G(cube)*/
  /*T(alive) = G(alive)*/
  /*T(tmp_cube) = G(tmp_cube)*/
  /*T(n) = G(n)*/
  /*T(g) = G(g)*/
  /*T(max) = G(n) + G(alive) + G(y) + G(x) + G(cube) + G(tmp_cube) + G(g)*/
  /*T(x) = G(x)*/
  /*T(y) = G(y)*/
  /*T(tmp) = U*/
  
  /*sid:32*/
  return (tmp);
  /*sid:32*/
  /*T(max) = G(x) + G(y)*/
  }

}
__inline static int min(int x , int y ) 
{ int tmp ;
  
  {/*sid:34*/
  if (x < y) {/*sid:35*/
  tmp = x;
  /*sid:35*/
  /*T(tmp) = G(x) + G(y)*/
  }
  else {/*sid:36*/
  tmp = y;
  /*sid:36*/
  /*T(tmp) = G(x) + G(y)*/
  }
  
  /*sid:34*/
  /*T(cube) = G(cube)*/
  /*T(alive) = G(alive)*/
  /*T(tmp_cube) = G(tmp_cube)*/
  /*T(n) = G(n)*/
  /*T(g) = G(g)*/
  /*T(min) = G(n) + G(alive) + G(y) + G(x) + G(cube) + G(tmp_cube) + G(g)*/
  /*T(x) = G(x)*/
  /*T(y) = G(y)*/
  /*T(tmp) = U*/
  
  /*sid:37*/
  return (tmp);
  /*sid:37*/
  /*T(min) = G(x) + G(y)*/
  }

}
__inline static int max_distance(int x , int y , int z ) 
{ int __retres ;
  
  {/*sid:38*/
  __retres = ((x + y) + z) / 5 + 1;
  /*sid:38*/
  /*T(cube) = G(cube)*/
  /*T(alive) = G(alive)*/
  /*T(tmp_cube) = G(tmp_cube)*/
  /*T(n) = G(n)*/
  /*T(g) = G(g)*/
  /*T(__retres) = G(y) + G(x) + G(z)*/
  /*T(max_distance) = G(n) + G(alive) + G(z) + G(x) + G(y) + G(cube) + G(tmp_cube) + G(g)*/
  /*T(x) = G(x)*/
  /*T(y) = G(y)*/
  /*T(z) = G(z)*/
  
  /*sid:224*/
  return (__retres);
  /*sid:224*/
  /*T(max_distance) = G(y) + G(x) + G(z)*/
  }

}
int is_alive(int x , int y , int z , int *config , int n_0 ) 
{ int i ;
  int j ;
  int k ;
  int d ;
  int alive_cnt ;
  int cnt ;
  int i_min ;
  int i_max ;
  int j_min ;
  int j_max ;
  int k_min ;
  int k_max ;
  int __retres ;
  
  {/*sid:39*/
  alive_cnt = 0;
  /*sid:39*/
  /*T(is_alive) = G(n) + G(alive) + G(n_0) + G(z) + G(x) + G(y) + G(config) + G(cube) + G(tmp_cube) + G(g)*/
  /*T(cube) = G(cube)*/
  /*T(alive) = G(alive)*/
  /*T(tmp_cube) = G(tmp_cube)*/
  /*T(n) = G(n)*/
  /*T(g) = G(g)*/
  /*T(__retres) = U*/
  /*T(x) = G(x)*/
  /*T(y) = G(y)*/
  /*T(z) = G(z)*/
  /*T(config) = G(config)*/
  /*T(n_0) = G(n_0)*/
  /*T(i) = U*/
  /*T(j) = U*/
  /*T(k) = U*/
  /*T(d) = U*/
  /*T(alive_cnt) = U*/
  /*T(cnt) = U*/
  /*T(i_min) = U*/
  /*T(i_max) = U*/
  /*T(j_min) = U*/
  /*T(j_max) = U*/
  /*T(k_min) = U*/
  /*T(k_max) = U*/
  
  cnt = 0;
  /*sid:41*/
  d = max_distance(x, y, z);
  /*sid:41*/
  /*T(d) = G(x) + G(y) + G(z)*/
  
  /*sid:42*/
  i_min = max(x - d, 0);
  /*sid:42*/
  /*T(i_min) = G(x) + G(y) + G(z)*/
  
  /*sid:43*/
  i_max = min((x + d) + 1, n_0);
  /*sid:43*/
  /*T(i_max) = G(z) + G(y) + G(x) + G(n_0)*/
  
  /*sid:44*/
  j_min = max(y - d, 0);
  /*sid:44*/
  /*T(j_min) = G(x) + G(y) + G(z)*/
  
  /*sid:45*/
  j_max = min((y + d) + 1, n_0);
  /*sid:45*/
  /*T(j_max) = G(z) + G(y) + G(x) + G(n_0)*/
  
  /*sid:46*/
  k_min = max(z - d, 0);
  /*sid:46*/
  /*T(k_min) = G(x) + G(y) + G(z)*/
  
  /*sid:47*/
  k_max = min((z + d) + 1, n_0);
  /*sid:47*/
  /*T(k_max) = G(z) + G(y) + G(x) + G(n_0)*/
  
  /*sid:48*/
  i = i_min;
  /*sid:48*/
  /*T(i) = G(x) + G(y) + G(z)*/
  
  /*sid:49*/
  while (i < i_max) {j = j_min;
    while (j < j_max) {k = k_min;
      while (k < k_max) {if (x == i) {if (y == j) {if (z == k) {/*sid:69*/
                                                     goto __Cont;
                                                     /*sid:69*/
                                                     /*T(i) = G(x) + G(y) + G(z)*/
                                                     /*T(alive_cnt) = U*/
                                                     /*T(cnt) = U*/
                                                     }
                                        }
                           }
        
        if (*(config + (((i * n_0) * n_0 + j * n_0) + k))) {alive_cnt ++;}
        
        cnt ++;
        /*sid:78*/
        __Cont: /* CIL Label */ 
        k ++;
        /*sid:78*/
        /*T(i) = G(n_0) + G(x) + G(y) + G(z)*/
        /*T(alive_cnt) = G(config) + G(z) + G(y) + G(x) + G(n_0)*/
        /*T(cnt) = G(z) + G(y) + G(x) + G(n_0)*/
        }
      
      j ++;}
    
    i ++;}
  
  /*sid:49*/
  /*T(i) = G(n_0) + G(x) + G(y) + G(z)*/
  /*T(j) = G(z) + G(y) + G(x) + G(n_0)*/
  /*T(k) = G(z) + G(y) + G(x) + G(n_0)*/
  /*T(alive_cnt) = G(config) + G(z) + G(y) + G(x) + G(n_0)*/
  /*T(cnt) = G(z) + G(y) + G(x) + G(n_0)*/
  
  if (alive_cnt * 100 < cnt * 25) {/*sid:83*/
    __retres = 0;
    /*sid:83*/
    /*T(__retres) = G(config) + G(z) + G(y) + G(x) + G(n_0)*/
    
    goto return_label;}
  
  if (alive_cnt * 100 > cnt * 75) {/*sid:87*/
    __retres = 0;
    /*sid:87*/
    /*T(__retres) = G(config) + G(z) + G(y) + G(x) + G(n_0)*/
    
    goto return_label;}
  
  if (alive_cnt * 100 > cnt * 45) {if (alive_cnt * 100 < cnt * 55) {if
                                      (*(config + (((x * n_0) * n_0 + y * n_0) + z))) {/*sid:95*/
                                     __retres = 0;
                                     /*sid:95*/
                                     /*T(__retres) = G(config) + G(z) + G(y) + G(x) + G(n_0)*/
                                     
                                     goto return_label;}
                                     
                                     /*sid:97*/
                                     __retres = 1;
                                     /*sid:97*/
                                     /*T(__retres) = G(config) + G(z) + G(y) + G(x) + G(n_0)*/
                                     
                                     goto return_label;}
    }
  
  /*sid:100*/
  __retres = 1;
  /*sid:100*/
  /*T(__retres) = G(config) + G(z) + G(y) + G(x) + G(n_0)*/
  
  /*sid:229*/
  return_label: /* CIL Label */ 
  return (__retres);
  /*sid:229*/
  /*T(is_alive) = G(config) + G(z) + G(y) + G(x) + G(n_0)*/
  }

}
int print_config(char *output_file , int n_0 , int g_0 , int *config ,
                 int *alive_0 ) 
{ FILE *fo ;
  int i ;
  int j ;
  int k ;
  int tmp ;
  int tmp_0 ;
  int __retres ;
  
  {/*sid:101*/
  while (1) {fo = fopen((char const   *)output_file, (char const   *)"w");
    if (! (fo != (void *)0)) {perror("Unable to open output file");
      goto fopen_err;}
    
    break;}
  
  /*sid:101*/
  /*T(print_config) = G(n) + G(alive) + G(alive_0) + G(g_0) + G(output_file) + G(n_0) + G(config) + G(cube) + G(tmp_cube) + G(g)*/
  /*T(cube) = G(cube)*/
  /*T(alive) = G(alive)*/
  /*T(tmp_cube) = G(tmp_cube)*/
  /*T(n) = G(n)*/
  /*T(g) = G(g)*/
  /*T(__retres) = U*/
  /*T(output_file) = G(output_file)*/
  /*T(n_0) = G(n_0)*/
  /*T(g_0) = G(g_0)*/
  /*T(config) = G(config)*/
  /*T(alive_0) = G(alive_0)*/
  /*T(fo) = U*/
  /*T(i) = U*/
  /*T(j) = U*/
  /*T(k) = U*/
  /*T(tmp) = U*/
  /*T(tmp_0) = U*/
  
  i = 0;
  /*sid:109*/
  while (i < n_0) {j = 0;
    while (j < n_0) {k = 0;
      while (k < n_0) {while (1) {/*sid:124*/
                         tmp = fprintf((FILE *)fo, (char const   *)"%d ",
                                       *(config + (((i * n_0) * n_0 + j * n_0) + k)));
                         /*sid:124*/
                         /*T(cube) = G(config) + G(n_0)*/
                         /*T(alive) = G(config) + G(n_0)*/
                         /*T(tmp_cube) = G(config) + G(n_0)*/
                         /*T(n) = G(config) + G(n_0)*/
                         /*T(g) = G(config) + G(n_0)*/
                         
                         if (! (tmp != 0)) {perror("Unable to write to output file");
                           goto write_err;}
                         
                         break;}
        
        /*sid:130*/
        k ++;
        /*sid:130*/
        /*T(cube) = G(config) + G(n_0) + G(cube)*/
        /*T(alive) = G(config) + G(n_0) + G(alive)*/
        /*T(tmp_cube) = G(config) + G(n_0) + G(tmp_cube)*/
        /*T(n) = G(config) + G(n_0) + G(n)*/
        /*T(g) = G(config) + G(n_0) + G(g)*/
        }
      
      fprintf((FILE *)fo, (char const   *)"\n");
      j ++;}
    
    fprintf((FILE *)fo, (char const   *)"\n");
    i ++;}
  
  /*sid:109*/
  /*T(cube) = G(n_0) + G(config) + G(cube)*/
  /*T(alive) = G(n_0) + G(config) + G(alive)*/
  /*T(tmp_cube) = G(n_0) + G(config) + G(tmp_cube)*/
  /*T(n) = G(n_0) + G(config) + G(n)*/
  /*T(g) = G(n_0) + G(config) + G(g)*/
  /*T(i) = G(n_0)*/
  /*T(j) = G(n_0)*/
  /*T(k) = G(n_0)*/
  /*T(tmp) = G(n_0)*/
  
  /*sid:135*/
  i = 0;
  /*sid:135*/
  /*T(i) = U*/
  
  /*sid:136*/
  while (i < g_0) {while (1) {/*sid:141*/
                     tmp_0 = fprintf((FILE *)fo, (char const   *)"%d\n",
                                     *(alive_0 + i));
                     /*sid:141*/
                     /*T(cube) = G(alive_0) + G(g_0)*/
                     /*T(alive) = G(alive_0) + G(g_0)*/
                     /*T(tmp_cube) = G(alive_0) + G(g_0)*/
                     /*T(n) = G(alive_0) + G(g_0)*/
                     /*T(g) = G(alive_0) + G(g_0)*/
                     
                     if (! (tmp_0 != 0)) {perror("Unable to write to output file");
                       /*sid:145*/
                       goto write_err;
                       /*sid:145*/
                       /*T(cube) = G(g_0) + G(alive_0) + G(config) + G(n_0)*/
                       /*T(alive) = G(g_0) + G(alive_0) + G(config) + G(n_0)*/
                       /*T(tmp_cube) = G(g_0) + G(alive_0) + G(config) + G(n_0)*/
                       /*T(n) = G(g_0) + G(alive_0) + G(config) + G(n_0)*/
                       /*T(g) = G(g_0) + G(alive_0) + G(config) + G(n_0)*/
                       /*T(i) = G(g_0) + G(n_0)*/
                       }
                     
                     break;}
    
    /*sid:147*/
    i ++;
    /*sid:147*/
    /*T(cube) = G(g_0) + G(alive_0) + G(n_0) + G(config) + G(cube)*/
    /*T(alive) = G(g_0) + G(alive_0) + G(n_0) + G(config) + G(alive)*/
    /*T(tmp_cube) = G(g_0) + G(alive_0) + G(n_0) + G(config) + G(tmp_cube)*/
    /*T(n) = G(g_0) + G(alive_0) + G(n_0) + G(config) + G(n)*/
    /*T(g) = G(g_0) + G(alive_0) + G(n_0) + G(config) + G(g)*/
    }
  
  /*sid:136*/
  /*T(cube) = G(g_0) + G(alive_0) + G(n_0) + G(config) + G(cube)*/
  /*T(alive) = G(g_0) + G(alive_0) + G(n_0) + G(config) + G(alive)*/
  /*T(tmp_cube) = G(g_0) + G(alive_0) + G(n_0) + G(config) + G(tmp_cube)*/
  /*T(n) = G(g_0) + G(alive_0) + G(n_0) + G(config) + G(n)*/
  /*T(g) = G(g_0) + G(alive_0) + G(n_0) + G(config) + G(g)*/
  /*T(i) = G(g_0)*/
  /*T(tmp_0) = G(g_0)*/
  
  fclose(fo);
  __retres = 0;
  goto return_label;
  /*sid:150*/
  write_err: ;
  /*sid:150*/
  /*T(cube) = G(alive_0) + G(g_0) + G(config) + G(n_0)*/
  /*T(alive) = G(alive_0) + G(g_0) + G(config) + G(n_0)*/
  /*T(tmp_cube) = G(alive_0) + G(g_0) + G(config) + G(n_0)*/
  /*T(n) = G(alive_0) + G(g_0) + G(config) + G(n_0)*/
  /*T(g) = G(alive_0) + G(g_0) + G(config) + G(n_0)*/
  /*T(i) = G(g_0) + G(n_0)*/
  /*T(tmp_0) = G(g_0)*/
  
  /*sid:151*/
  fclose(fo);
  /*sid:151*/
  /*T(cube) = G(n_0) + G(config) + G(g_0) + G(alive_0) + G(cube)*/
  /*T(alive) = G(n_0) + G(config) + G(g_0) + G(alive_0) + G(alive)*/
  /*T(tmp_cube) = G(n_0) + G(config) + G(g_0) + G(alive_0) + G(tmp_cube)*/
  /*T(n) = G(n_0) + G(config) + G(g_0) + G(alive_0) + G(n)*/
  /*T(g) = G(n_0) + G(config) + G(g_0) + G(alive_0) + G(g)*/
  
  /*sid:152*/
  fopen_err: 
  __retres = -1;
  /*sid:152*/
  /*T(cube) = G(g_0) + G(alive_0) + G(n_0) + G(config) + G(cube)*/
  /*T(alive) = G(g_0) + G(alive_0) + G(n_0) + G(config) + G(alive)*/
  /*T(tmp_cube) = G(g_0) + G(alive_0) + G(n_0) + G(config) + G(tmp_cube)*/
  /*T(n) = G(g_0) + G(alive_0) + G(n_0) + G(config) + G(n)*/
  /*T(g) = G(g_0) + G(alive_0) + G(n_0) + G(config) + G(g)*/
  /*T(__retres) = G(n_0)*/
  /*T(i) = G(n_0) + G(g_0)*/
  /*T(j) = G(n_0)*/
  /*T(k) = G(n_0)*/
  /*T(tmp) = G(n_0)*/
  /*T(tmp_0) = G(g_0)*/
  
  /*sid:231*/
  return_label: /* CIL Label */ 
  return (__retres);
  /*sid:231*/
  /*T(print_config) = G(n_0)*/
  /*T(__retres) = G(n_0)*/
  /*T(i) = G(n_0) + G(g_0)*/
  }

}
int dbg_print_config(int n_0 , int *config ) 
{ int i ;
  int j ;
  int k ;
  int __retres ;
  
  {/*sid:153*/
  i = 0;
  /*sid:153*/
  /*T(dbg_print_config) = G(n) + G(alive) + G(config) + G(n_0) + G(cube) + G(tmp_cube) + G(g)*/
  /*T(cube) = G(cube)*/
  /*T(alive) = G(alive)*/
  /*T(tmp_cube) = G(tmp_cube)*/
  /*T(n) = G(n)*/
  /*T(g) = G(g)*/
  /*T(__retres) = U*/
  /*T(n_0) = G(n_0)*/
  /*T(config) = G(config)*/
  /*T(i) = U*/
  /*T(j) = U*/
  /*T(k) = U*/
  
  /*sid:154*/
  while (i < n_0) {j = 0;
    while (j < n_0) {k = 0;
      while (k < n_0) {/*sid:168*/
        printf((char const   *)"%d ",
               *(config + (((i * n_0) * n_0 + j * n_0) + k)));
        /*sid:168*/
        /*T(cube) = G(config) + G(n_0)*/
        /*T(alive) = G(config) + G(n_0)*/
        /*T(tmp_cube) = G(config) + G(n_0)*/
        /*T(n) = G(config) + G(n_0)*/
        /*T(g) = G(config) + G(n_0)*/
        
        /*sid:169*/
        k ++;
        /*sid:169*/
        /*T(cube) = G(config) + G(n_0) + G(cube)*/
        /*T(alive) = G(config) + G(n_0) + G(alive)*/
        /*T(tmp_cube) = G(config) + G(n_0) + G(tmp_cube)*/
        /*T(n) = G(config) + G(n_0) + G(n)*/
        /*T(g) = G(config) + G(n_0) + G(g)*/
        }
      
      printf((char const   *)"\n");
      j ++;}
    
    printf((char const   *)"\n\n");
    i ++;}
  
  /*sid:154*/
  /*T(cube) = G(n_0) + G(config) + G(cube)*/
  /*T(alive) = G(n_0) + G(config) + G(alive)*/
  /*T(tmp_cube) = G(n_0) + G(config) + G(tmp_cube)*/
  /*T(n) = G(n_0) + G(config) + G(n)*/
  /*T(g) = G(n_0) + G(config) + G(g)*/
  /*T(i) = G(n_0)*/
  /*T(j) = G(n_0)*/
  /*T(k) = G(n_0)*/
  
  printf((char const   *)"\n");
  __retres = 0;
  /*sid:232*/
  return (__retres);
  /*sid:232*/
  /*T(dbg_print_config) = U*/
  }

}
extern  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                 char ** __restrict  __endptr ,
                                                 int __base )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__,
__noreturn__)) void exit(int __status ) ;
int cube[(128 * 128) * 128] ;
int alive[256] ;
int tmp_cube[(128 * 128) * 128] ;
int n ;
int g ;
int main(int argc , char **argv ) 
{ int i ;
  int j ;
  int k ;
  int cnt ;
  int *old_config ;
  int *curr_config ;
  int *aux ;
  int tmp ;
  int tmp_0 ;
  int tmp_1 ;
  int __retres ;
  
  {/*sid:176*/
  g = (int )strtol((char const   *)*(argv + 1),
                   (char **)((char **)((void *)0)), 10);
  /*sid:176*/
  /*T(cube) = G(cube)*/
  /*T(alive) = G(alive)*/
  /*T(tmp_cube) = G(tmp_cube)*/
  /*T(n) = G(n)*/
  /*T(g) = U*/
  /*T(argc) = G(argc)*/
  /*T(argv) = G(argv)*/
  /*T(i) = U*/
  /*T(j) = U*/
  /*T(k) = U*/
  /*T(cnt) = U*/
  /*T(old_config) = U*/
  /*T(curr_config) = U*/
  /*T(aux) = U*/
  /*T(tmp) = U*/
  /*T(tmp_0) = U*/
  /*T(tmp_1) = U*/
  /*T(__retres) = U*/
  /*T(main) = G(n) + G(alive) + G(argv) + G(argc) + G(cube) + G(tmp_cube) + G(g)*/
  
  while (1) {/*sid:178*/
    tmp = read_config(*(argv + 2), & n, cube, 128);
    /*sid:178*/
    /*T(cube) = T*/
    /*T(n) = T*/
    
    if (! (tmp == 0)) {perror("Unable to read initial config");
      goto err;}
    
    break;}
  
  /*sid:184*/
  old_config = cube;
  /*sid:184*/
  /*T(old_config) = T*/
  
  /*sid:185*/
  curr_config = tmp_cube;
  /*sid:185*/
  /*T(curr_config) = G(tmp_cube)*/
  
  cnt = 0;
  /*sid:187*/
  while (cnt < g) {/*sid:191*/
    i = 0;
    /*sid:191*/
    /*T(i) = U*/
    
    /*sid:192*/
    while (i < n) {j = 0;
      while (j < n) {k = 0;
        while (k < n) {tmp_0 = is_alive(i, j, k, old_config, n);
          if (tmp_0)
          {*(curr_config + (((i * n) * n + j * n) + k)) = 1;
          (alive[cnt]) ++;}
          else {*(curr_config + (((i * n) * n + j * n) + k)) = 0;}
          
          k ++;}
        
        j ++;}
      
      i ++;}
    
    /*sid:192*/
    /*T(i) = T*/
    
    aux = old_config;
    old_config = curr_config;
    curr_config = aux;
    cnt ++;}
  
  /*sid:187*/
  /*T(alive) = T*/
  /*T(i) = T*/
  /*T(j) = T*/
  /*T(k) = T*/
  /*T(curr_config) = T*/
  /*T(aux) = T*/
  /*T(tmp_0) = T*/
  
  /*sid:218*/
  tmp_1 = print_config(*(argv + 3), n, g, old_config, alive);
  /*sid:218*/
  /*T(tmp_cube) = T*/
  /*T(g) = T*/
  /*T(tmp_1) = T*/
  
  exit(tmp_1);
  err: ;
  exit(1);
  /*sid:233*/
  return (__retres);
  /*sid:233*/
  /*T(cube) = G(cube)*/
  /*T(alive) = G(alive)*/
  /*T(tmp_cube) = G(tmp_cube)*/
  /*T(n) = G(n)*/
  /*T(g) = G(g)*/
  /*T(argc) = G(argc)*/
  /*T(argv) = G(argv)*/
  /*T(i) = U*/
  /*T(j) = U*/
  /*T(k) = U*/
  /*T(cnt) = U*/
  /*T(old_config) = U*/
  /*T(curr_config) = U*/
  /*T(aux) = U*/
  /*T(tmp) = U*/
  /*T(tmp_0) = U*/
  /*T(tmp_1) = U*/
  /*T(__retres) = U*/
  /*T(main) = G(n) + G(alive) + G(argv) + G(argc) + G(cube) + G(tmp_cube) + G(g)*/
  }

}
}}}
----