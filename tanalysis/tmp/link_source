/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is false */

typedef unsigned int size_t;
typedef long long __quad_t;
typedef long __off_t;
typedef __quad_t __off64_t;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
typedef __off_t off_t;
typedef unsigned int Elf32_Addr;
typedef unsigned short Elf32_Half;
typedef unsigned int Elf32_Off;
typedef unsigned int Elf32_Word;
struct __anonstruct_Elf32_Ehdr_18 {
   unsigned char e_ident[16] ;
   Elf32_Half e_type ;
   Elf32_Half e_machine ;
   Elf32_Word e_version ;
   Elf32_Addr e_entry ;
   Elf32_Off e_phoff ;
   Elf32_Off e_shoff ;
   Elf32_Word e_flags ;
   Elf32_Half e_ehsize ;
   Elf32_Half e_phentsize ;
   Elf32_Half e_phnum ;
   Elf32_Half e_shentsize ;
   Elf32_Half e_shnum ;
   Elf32_Half e_shstrndx ;
};
typedef struct __anonstruct_Elf32_Ehdr_18 Elf32_Ehdr;
struct __anonstruct_Elf32_Shdr_20 {
   Elf32_Word sh_name ;
   Elf32_Word sh_type ;
   Elf32_Word sh_flags ;
   Elf32_Addr sh_addr ;
   Elf32_Off sh_offset ;
   Elf32_Word sh_size ;
   Elf32_Word sh_link ;
   Elf32_Word sh_info ;
   Elf32_Word sh_addralign ;
   Elf32_Word sh_entsize ;
};
typedef struct __anonstruct_Elf32_Shdr_20 Elf32_Shdr;
enum __anonenum_Elf_Type_50 {
    ELF_T_BYTE = 0,
    ELF_T_ADDR = 1,
    ELF_T_DYN = 2,
    ELF_T_EHDR = 3,
    ELF_T_HALF = 4,
    ELF_T_OFF = 5,
    ELF_T_PHDR = 6,
    ELF_T_RELA = 7,
    ELF_T_REL = 8,
    ELF_T_SHDR = 9,
    ELF_T_SWORD = 10,
    ELF_T_SYM = 11,
    ELF_T_WORD = 12,
    ELF_T_SXWORD = 13,
    ELF_T_XWORD = 14,
    ELF_T_VDEF = 15,
    ELF_T_VNEED = 16,
    ELF_T_NUM = 17
} ;
typedef enum __anonenum_Elf_Type_50 Elf_Type;
struct Elf;
typedef struct Elf Elf;
struct Elf_Scn;
typedef struct Elf_Scn Elf_Scn;
struct __anonstruct_Elf_Data_53 {
   void *d_buf ;
   Elf_Type d_type ;
   size_t d_size ;
   off_t d_off ;
   size_t d_align ;
   unsigned int d_version ;
};
typedef struct __anonstruct_Elf_Data_53 Elf_Data;
struct StructSectionEDL;
struct StructSegmentEDL {
   unsigned int type ;
   unsigned long adresse ;
   unsigned long position ;
   unsigned int tailleMemoire ;
   unsigned int tailleFichier ;
   unsigned long adresse1ereSection ;
   unsigned long position1ereSection ;
   struct StructSectionEDL **sections ;
   unsigned int nbSections ;
};
struct StructObjetEDL;
enum enumCategorieSection {
    INSTRUCTIONS = 0,
    DONNEES_INITIALISEES = 1,
    DONNEES_LECTURE_SEULE = 2,
    DONNEES_NON_INITIALISEES = 3,
    DONNEES_NON_ALLOUABLES = 4,
    TABLE_CHAINES = 5,
    TABLE_SYMBOLES = 6,
    TABLE_TRANSLATION = 7
} ;
typedef enum enumCategorieSection CategorieSection;
struct StructNoeudSection {
   struct StructSectionEDL *section ;
   struct StructNoeudSection *suivant ;
};
typedef struct StructNoeudSection NoeudSection;
struct StructIterateurObjet {
   NoeudSection *listesSections[(int )TABLE_TRANSLATION + 1] ;
   NoeudSection *dernieresSections[(int )TABLE_TRANSLATION + 1] ;
   NoeudSection *sectionCourante ;
   unsigned int finSections ;
   CategorieSection categorieCourante ;
};
typedef unsigned int ModeOuvertureEDL;
typedef unsigned int BoutismeEDL;
typedef unsigned int ClasseEDL;
typedef unsigned int SystemeEDL;
typedef unsigned int TypeObjetEDL;
typedef unsigned int ProcesseurEDL;
typedef unsigned int VersionEDL;
typedef unsigned int FlagsObjetEDL;
struct StructObjetEDL {
   char *nom ;
   int fd ;
   ModeOuvertureEDL mode ;
   BoutismeEDL boutisme ;
   ClasseEDL classe ;
   SystemeEDL systeme ;
   TypeObjetEDL type ;
   ProcesseurEDL processeur ;
   VersionEDL version ;
   FlagsObjetEDL flags ;
   unsigned int estCopie ;
   struct StructSectionEDL **sections ;
   unsigned int nbSections ;
   unsigned int nbMax ;
   struct StructSectionEDL *tableNomsSection ;
   struct StructSegmentEDL *segments ;
   unsigned int nbSegments ;
   unsigned long pointEntree ;
   unsigned long tailleFichier ;
   struct StructIterateurObjet *iterateur ;
   Elf *elf ;
   Elf32_Ehdr *ehdr ;
};
struct StructChaineEDL {
   unsigned int indexElf ;
   unsigned int estSuffixe ;
   unsigned int longueur ;
   unsigned int nbReferences ;
   char *chaine ;
};
typedef struct StructChaineEDL ChaineEDL;
struct StructTableChainesEDL {
   ChaineEDL **chaines ;
   unsigned int nbChaines ;
   unsigned int nbMax ;
};
typedef unsigned int PorteeSymboleEDL;
typedef unsigned int TypeSymboleEDL;
typedef unsigned int NatureDefinitionEDL;
struct StructSymboleEDL {
   struct StructChaineEDL *nom ;
   unsigned long valeur ;
   unsigned int taille ;
   PorteeSymboleEDL portee ;
   TypeSymboleEDL type ;
   NatureDefinitionEDL natureDefinition ;
   struct StructSectionEDL *sectionDefinition ;
   struct StructSymboleEDL *symboleImage ;
   struct StructSectionEDL *tableSymbolesOrigine ;
};
typedef struct StructSymboleEDL SymboleEDL;
struct StructTableSymbolesEDL {
   SymboleEDL **symbolesLocaux ;
   SymboleEDL **symbolesGlobaux ;
   unsigned int nbLocaux ;
   unsigned int nbGlobaux ;
   unsigned int nbMaxLocaux ;
   unsigned int nbMaxGlobaux ;
   struct StructSectionEDL *tableChaines ;
};
typedef unsigned int TypeTranslationEDL;
struct StructTranslationEDL {
   unsigned long adresse ;
   struct StructSymboleEDL *symbole ;
   TypeTranslationEDL type ;
};
typedef struct StructTranslationEDL TranslationEDL;
struct StructTableTranslationEDL {
   TranslationEDL *translations ;
   unsigned int nbTranslations ;
   struct StructSectionEDL *tableSymboles ;
   struct StructSectionEDL *sectionCode ;
};
struct StructSectionProgrammeEDL {
   unsigned int decalageContenu ;
};
typedef unsigned int TypeSectionEDL;
typedef unsigned int FlagsSectionEDL;
struct StructSectionEDL {
   struct StructObjetEDL *objetParent ;
   struct StructObjetEDL *parentInitial ;
   struct StructChaineEDL *nom ;
   TypeSectionEDL type ;
   FlagsSectionEDL flags ;
   unsigned int alignement ;
   unsigned int tailleElement ;
   unsigned long adresse ;
   unsigned long position ;
   struct StructTableChainesEDL *tableChaines ;
   struct StructTableSymbolesEDL *tableSymboles ;
   struct StructTableTranslationEDL *tableTranslation ;
   struct StructSectionProgrammeEDL *sectionProgramme ;
   struct StructSectionEDL *sectionImage ;
   void *contenuElf ;
   unsigned int tailleContenuElf ;
   unsigned int indexElf ;
   Elf_Scn *descripteurLibelf ;
   Elf_Data *descripteurContenu ;
   Elf32_Shdr *descripteurElf ;
};
struct __anonstruct_Elf32_Rel_7 {
   Elf32_Addr r_offset ;
   Elf32_Word r_info ;
};
typedef struct __anonstruct_Elf32_Rel_7 Elf32_Rel;
enum __anonenum_Elf_Cmd_46 {
    ELF_C_NULL = 0,
    ELF_C_READ = 1,
    ELF_C_WRITE = 2,
    ELF_C_CLR = 3,
    ELF_C_SET = 4,
    ELF_C_FDDONE = 5,
    ELF_C_FDREAD = 6,
    ELF_C_RDWR = 7,
    ELF_C_NUM = 8
} ;
typedef struct StructObjetEDL ObjetEDL;
typedef struct StructSectionEDL SectionEDL;
typedef struct StructTableTranslationEDL TableTranslationEDL;
struct __anonstruct_Elf32_Sym_26 {
   Elf32_Word st_name ;
   Elf32_Addr st_value ;
   Elf32_Word st_size ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf32_Half st_shndx ;
};
typedef struct __anonstruct_Elf32_Sym_26 Elf32_Sym;
enum __anonenum_Elf_Cmd_52 {
    ELF_C_NULL_0 = 0,
    ELF_C_READ_0 = 1,
    ELF_C_WRITE_0 = 2,
    ELF_C_CLR_0 = 3,
    ELF_C_SET_0 = 4,
    ELF_C_FDDONE_0 = 5,
    ELF_C_FDREAD_0 = 6,
    ELF_C_RDWR_0 = 7,
    ELF_C_NUM_0 = 8
} ;
typedef struct StructSectionProgrammeEDL SectionProgrammeEDL;
typedef struct StructTableSymbolesEDL TableSymbolesEDL;
enum __anonenum_natureSource_58 {
    GLOBAL = 0,
    FAIBLE = 1,
    ABSOLU = 2,
    COMMUN = 3,
    INDEFINI = 4,
    INCONNU = 5
} ;
struct __anonstruct_Elf32_Phdr_34 {
   Elf32_Word p_type ;
   Elf32_Off p_offset ;
   Elf32_Addr p_vaddr ;
   Elf32_Addr p_paddr ;
   Elf32_Word p_filesz ;
   Elf32_Word p_memsz ;
   Elf32_Word p_flags ;
   Elf32_Word p_align ;
};
typedef struct __anonstruct_Elf32_Phdr_34 Elf32_Phdr;
typedef struct StructIterateurObjet IterateurObjet;
typedef struct StructSegmentEDL SegmentEDL;
enum __anonenum_Elf_Cmd_53 {
    ELF_C_NULL_1 = 0,
    ELF_C_READ_1 = 1,
    ELF_C_WRITE_1 = 2,
    ELF_C_CLR_1 = 3,
    ELF_C_SET_1 = 4,
    ELF_C_FDDONE_1 = 5,
    ELF_C_FDREAD_1 = 6,
    ELF_C_RDWR_1 = 7,
    ELF_C_NUM_1 = 8
} ;
struct StructNoeudNom {
   unsigned int alignementMax ;
   NoeudSection *sections ;
   NoeudSection *derniereSection ;
   struct StructNoeudNom *suivant ;
};
typedef struct StructNoeudNom NoeudNom;
struct StructIterateurGlobal {
   NoeudNom *listesNoms[(int )TABLE_TRANSLATION + 1] ;
   NoeudNom *nomCourant ;
   unsigned int finNoms ;
   NoeudSection *sectionCourante ;
   unsigned int finSections ;
   CategorieSection categorieCourante ;
};
typedef struct StructIterateurGlobal IterateurGlobal;
enum __anonenum_Elf_Cmd_48 {
    ELF_C_NULL_2 = 0,
    ELF_C_READ_2 = 1,
    ELF_C_WRITE_2 = 2,
    ELF_C_CLR_2 = 3,
    ELF_C_SET_2 = 4,
    ELF_C_FDDONE_2 = 5,
    ELF_C_FDREAD_2 = 6,
    ELF_C_RDWR_2 = 7,
    ELF_C_NUM_2 = 8
} ;
enum __anonenum_Elf_Cmd_54 {
    ELF_C_NULL_3 = 0,
    ELF_C_READ_3 = 1,
    ELF_C_WRITE_3 = 2,
    ELF_C_CLR_3 = 3,
    ELF_C_SET_3 = 4,
    ELF_C_FDDONE_3 = 5,
    ELF_C_FDREAD_3 = 6,
    ELF_C_RDWR_3 = 7,
    ELF_C_NUM_3 = 8
} ;
typedef struct StructTableChainesEDL TableChainesEDL;
enum __anonenum_Elf_Cmd_55 {
    ELF_C_NULL_4 = 0,
    ELF_C_READ_4 = 1,
    ELF_C_WRITE_4 = 2,
    ELF_C_CLR_4 = 3,
    ELF_C_SET_4 = 4,
    ELF_C_FDDONE_4 = 5,
    ELF_C_FDREAD_4 = 6,
    ELF_C_RDWR_4 = 7,
    ELF_C_NUM_4 = 8
} ;
extern FILE *fopen(char const   * __restrict  __filename ,
                   char const   * __restrict  __modes ) ;
extern int fprintf(FILE * __restrict  __stream ,
                   char const   * __restrict  __format  , ...) ;
static FILE *journal ;
void journaliser(char *sp ) ;
static unsigned int premiereFois  = 1U;
void journaliser(char *sp ) 
{ 
  
  {/*sid:2*/
  if (premiereFois) {premiereFois = 0U;
    /*sid:4*/
    journal = fopen((char const   *)"libedl.log", (char const   *)"w");
    /*sid:4*/
    /*T(journal) = G(premiereFois)*/
    
    fprintf((FILE *)journal, (char const   *)"sous-programmes non realises ");
    /*sid:6*/
    fprintf((FILE *)journal,
            (char const   *)"(invocation de la version libedl) :\n");
    /*sid:6*/
    /*T(journal) = G(premiereFois) + G(journal)*/
    }
  
  /*sid:2*/
  /*T(journaliser) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(sp) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(sp) = G(sp)*/
  
  /*sid:8*/
  fprintf((FILE *)journal, (char const   *)"- %s()\n", sp);
  /*sid:8*/
  /*T(journal) = G(sp)*/
  /*T(premiereFois) = G(sp)*/
  /*T(sectionBss) = G(sp)*/
  /*T(adresseText) = G(sp)*/
  /*T(adresseData) = G(sp)*/
  /*T(adresseRodata) = G(sp)*/
  /*T(adresseBss) = G(sp)*/
  /*T(adresseStack) = G(sp)*/
  /*T(nomPtEntree) = G(sp)*/
  /*T(boutismeHote) = G(sp)*/
  /*T(iterateurGlobal) = G(sp)*/
  /*T(objets) = G(sp)*/
  /*T(copieSuperficielle) = G(sp)*/
  /*T(objets_0) = G(sp)*/
  /*T(nbFichiersDonnees) = G(sp)*/
  
  /*sid:3423*/
  return;
  /*sid:3423*/
  /*T(journaliser) = U*/
  }

}
unsigned long alignement(unsigned long adresse , unsigned int alignement_0 ) ;
void cloreSectionVide(struct StructSectionEDL *section ) ;
void fusionnerSectionVide(struct StructSectionEDL *sectionSource ,
                          struct StructSectionEDL *sectionCible ) ;
void etendreSectionVide(struct StructSectionEDL *section ,
                        unsigned int delta , unsigned int align ,
                        unsigned long *tailleIntermediaire ) ;
void cloreSectionVide(struct StructSectionEDL *section ) 
{ Elf_Data *descripteurContenu ;
  
  {/*sid:10*/
  descripteurContenu = section->descripteurContenu;
  /*sid:10*/
  /*T(cloreSectionVide) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(descripteurContenu) = G(section)*/
  
  descripteurContenu->d_buf = (void *)0;
  /*sid:3424*/
  return;
  /*sid:3424*/
  /*T(cloreSectionVide) = U*/
  }

}
void fusionnerSectionVide(struct StructSectionEDL *sectionSource ,
                          struct StructSectionEDL *sectionCible ) 
{ unsigned int tailleSource ;
  unsigned int tailleCible ;
  
  {/*sid:13*/
  tailleSource = sectionSource->tailleContenuElf;
  /*sid:13*/
  /*T(sectionSource) = G(sectionSource)*/
  /*T(sectionCible) = G(sectionCible)*/
  /*T(tailleSource) = G(sectionSource)*/
  /*T(tailleCible) = U*/
  /*T(fusionnerSectionVide) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(sectionCible) + G(sectionSource) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  /*sid:14*/
  tailleCible = sectionCible->tailleContenuElf;
  /*sid:14*/
  /*T(tailleCible) = G(sectionCible)*/
  
  /*sid:15*/
  tailleCible += tailleSource;
  /*sid:15*/
  /*T(tailleCible) = G(sectionCible) + G(sectionSource)*/
  
  /*sid:16*/
  sectionCible->tailleContenuElf = tailleCible;
  /*sid:16*/
  /*T(sectionCible) = G(sectionSource) + G(sectionCible)*/
  
  /*sid:3425*/
  return;
  /*sid:3425*/
  /*T(fusionnerSectionVide) = U*/
  }

}
void etendreSectionVide(struct StructSectionEDL *section ,
                        unsigned int delta , unsigned int align ,
                        unsigned long *tailleIntermediaire ) 
{ unsigned long tailleAlignee ;
  
  {/*sid:18*/
  tailleAlignee = alignement((unsigned long )section->tailleContenuElf, align);
  /*sid:18*/
  /*T(etendreSectionVide) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(tailleIntermediaire) + G(delta) + G(section) + G(align) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(delta) = G(delta)*/
  /*T(align) = G(align)*/
  /*T(tailleIntermediaire) = G(tailleIntermediaire)*/
  /*T(tailleAlignee) = G(section) + G(align)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  /*sid:19*/
  section->tailleContenuElf = (unsigned int )(tailleAlignee + (unsigned long )delta);
  /*sid:19*/
  /*T(section) = G(delta) + G(align) + G(section)*/
  
  if (tailleIntermediaire != (void *)0) {/*sid:22*/
    *tailleIntermediaire = tailleAlignee;
    /*sid:22*/
    /*T(tailleIntermediaire) = G(section) + G(align) + G(tailleIntermediaire)*/
    }
  
  /*sid:3426*/
  return;
  /*sid:3426*/
  /*T(etendreSectionVide) = U*/
  /*T(tailleIntermediaire) = G(align) + G(section) + G(tailleIntermediaire)*/
  }

}
extern int printf(char const   * __restrict  __format  , ...) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb ,
                                                  size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__,
__noreturn__)) void exit(int __status ) ;
struct StructSectionEDL *sectionSelonIndex(ObjetEDL *objet ,
                                           unsigned int index_0 ) ;
unsigned int indexSymbole(struct StructSectionEDL *section ,
                          SymboleEDL *symbole ) ;
SymboleEDL *symboleSelonIndex(struct StructSectionEDL *section ,
                              unsigned int index_0 ) ;
void ouvrirTableTranslation(struct StructSectionEDL *section ) ;
void creerTableTranslation(struct StructSectionEDL *section ,
                           struct StructSectionEDL *tableSymboles ,
                           struct StructSectionEDL *sectionCode ,
                           unsigned int nbMax ) ;
void copierContenuTranslation(struct StructSectionEDL *tableSource ,
                              struct StructSectionEDL *tableCible ) ;
void cloreTableTranslation(struct StructSectionEDL *section ) ;
void fermerTableTranslation(struct StructSectionEDL *section ) ;
void fusionnerTableTranslation(struct StructSectionEDL *sectionSource ,
                               struct StructSectionEDL *sectionCible ) ;
void completerSectionCode(struct StructSectionEDL *section ) ;
void ajouterTranslation(struct StructSectionEDL *sectionCible ,
                        TranslationEDL *translationSource ,
                        TranslationEDL **translationResultat ) ;
unsigned int tailleTableTranslation(struct StructSectionEDL *section ) ;
void afficherTranslations(struct StructSectionEDL *section ) ;
static void completerEmplacement(struct StructSectionEDL *sectionCode ,
                                 TranslationEDL translation ) ;
static void ajusterEmplacement(TranslationEDL translationSource ,
                               TranslationEDL translationCible ,
                               struct StructSectionEDL *sectionCodeCible ) ;
static void ajusterOffset(TranslationEDL *translation ,
                          struct StructSectionEDL *sectionCodeSource ) ;
static unsigned long inversionBoutismeMot(unsigned long donnee ) ;
static unsigned short inversionBoutismeDemiMot(unsigned short donnee ) ;
static unsigned long alignementMot(void *donnee ) ;
static unsigned short alignementDemiMot(void *donnee ) ;
static void desalignerMot(unsigned long donnee , void *resultat ) ;
static void desalignerDemiMot(unsigned short donnee , void *resultat ) ;
static void verifierValeur(long valeur , long min , long max ) ;
static void afficherTitreTranslations(void) ;
static void afficherTranslation(TranslationEDL translation ) ;
static void libererFormatInterneTranslation(struct StructSectionEDL *section ) ;
void ouvrirTableTranslation(struct StructSectionEDL *section ) 
{ ObjetEDL *objet ;
  TableTranslationEDL *tableTranslation ;
  unsigned int nbTranslations ;
  Elf32_Rel *translationsSource ;
  TranslationEDL *translationsCible ;
  unsigned int indexTableSymboles ;
  unsigned int indexSectionCode ;
  SectionEDL *tableSymboles ;
  SectionEDL *sectionCode ;
  unsigned int indexSymbole_0 ;
  unsigned int type ;
  unsigned int i ;
  
  {/*sid:25*/
  tableTranslation = (TableTranslationEDL *)malloc(sizeof(TableTranslationEDL ));
  /*sid:25*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(ouvrirTableTranslation) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(objet) = U*/
  /*T(tableTranslation) = U*/
  /*T(nbTranslations) = U*/
  /*T(translationsSource) = U*/
  /*T(translationsCible) = U*/
  /*T(indexTableSymboles) = U*/
  /*T(indexSectionCode) = U*/
  /*T(tableSymboles) = U*/
  /*T(sectionCode) = U*/
  /*T(indexSymbole_0) = U*/
  /*T(type) = U*/
  /*T(i) = U*/
  
  /*sid:26*/
  nbTranslations = section->tailleContenuElf / sizeof(Elf32_Rel );
  /*sid:26*/
  /*T(nbTranslations) = G(section)*/
  
  /*sid:27*/
  translationsCible = (TranslationEDL *)calloc(nbTranslations,
                                               sizeof(TranslationEDL ));
  /*sid:27*/
  /*T(translationsCible) = G(section)*/
  
  /*sid:28*/
  translationsSource = (Elf32_Rel *)section->contenuElf;
  /*sid:28*/
  /*T(translationsSource) = G(section)*/
  
  /*sid:29*/
  objet = section->objetParent;
  /*sid:29*/
  /*T(objet) = G(section)*/
  
  /*sid:30*/
  indexTableSymboles = (section->descripteurElf)->sh_link;
  /*sid:30*/
  /*T(indexTableSymboles) = G(section)*/
  
  /*sid:31*/
  tableSymboles = sectionSelonIndex(objet, indexTableSymboles);
  /*sid:31*/
  /*T(tableSymboles) = G(section)*/
  
  i = 0U;
  /*sid:33*/
  while (i < nbTranslations) {(translationsCible + i)->adresse = (unsigned long )(
                              translationsSource + i)->r_offset;
    indexSymbole_0 = (translationsSource + i)->r_info >> 8;
    (translationsCible + i)->symbole = symboleSelonIndex(tableSymboles,
                                                         indexSymbole_0);
    type = (unsigned int )((unsigned char )(translationsSource + i)->r_info);
    (translationsCible + i)->type = type;
    i ++;}
  
  /*sid:33*/
  /*T(indexSymbole_0) = G(section)*/
  /*T(type) = G(section)*/
  /*T(i) = G(section)*/
  
  /*sid:43*/
  tableTranslation->translations = translationsCible;
  /*sid:43*/
  /*T(tableTranslation) = G(section)*/
  
  tableTranslation->nbTranslations = nbTranslations;
  tableTranslation->tableSymboles = tableSymboles;
  /*sid:46*/
  indexSectionCode = (section->descripteurElf)->sh_info;
  /*sid:46*/
  /*T(indexSectionCode) = G(section)*/
  
  /*sid:47*/
  sectionCode = sectionSelonIndex(objet, indexSectionCode);
  /*sid:47*/
  /*T(sectionCode) = G(section)*/
  
  tableTranslation->sectionCode = sectionCode;
  section->tableTranslation = tableTranslation;
  /*sid:3427*/
  return;
  /*sid:3427*/
  /*T(ouvrirTableTranslation) = U*/
  }

}
void creerTableTranslation(struct StructSectionEDL *section ,
                           struct StructSectionEDL *tableSymboles ,
                           struct StructSectionEDL *sectionCode ,
                           unsigned int nbMax ) 
{ 
  
  {/*sid:51*/
  section->contenuElf = (void *)0;
  /*sid:51*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(creerTableTranslation) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(nbMax) + G(tableSymboles) + G(section) + G(sectionCode) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(tableSymboles) = G(tableSymboles)*/
  /*T(sectionCode) = G(sectionCode)*/
  /*T(nbMax) = G(nbMax)*/
  
  section->tableTranslation = (struct StructTableTranslationEDL *)calloc(
  1U, sizeof(TableTranslationEDL ));
  (section->tableTranslation)->translations = (TranslationEDL *)calloc(
  nbMax, sizeof(TranslationEDL ));
  (section->tableTranslation)->nbTranslations = 0U;
  /*sid:55*/
  (section->tableTranslation)->tableSymboles = tableSymboles;
  /*sid:55*/
  /*T(section) = G(tableSymboles) + G(section)*/
  
  /*sid:56*/
  (section->tableTranslation)->sectionCode = sectionCode;
  /*sid:56*/
  /*T(section) = G(sectionCode) + G(tableSymboles) + G(section)*/
  
  /*sid:3428*/
  return;
  /*sid:3428*/
  /*T(creerTableTranslation) = U*/
  }

}
void copierContenuTranslation(struct StructSectionEDL *tableSource ,
                              struct StructSectionEDL *tableCible ) 
{ TranslationEDL *translationsSource ;
  unsigned int nbTranslations ;
  unsigned int i ;
  
  {/*sid:58*/
  translationsSource = (tableSource->tableTranslation)->translations;
  /*sid:58*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(copierContenuTranslation) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(tableCible) + G(tableSource) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(tableSource) = G(tableSource)*/
  /*T(tableCible) = G(tableCible)*/
  /*T(translationsSource) = G(tableSource)*/
  /*T(nbTranslations) = U*/
  /*T(i) = U*/
  
  /*sid:59*/
  nbTranslations = (tableSource->tableTranslation)->nbTranslations;
  /*sid:59*/
  /*T(nbTranslations) = G(tableSource)*/
  
  i = 0U;
  /*sid:61*/
  while (i != nbTranslations) {ajouterTranslation(tableCible,
                                                  translationsSource + i,
                                                  (TranslationEDL **)((void *)0));
    i ++;}
  
  /*sid:61*/
  /*T(i) = G(tableSource)*/
  
  /*sid:3429*/
  return;
  /*sid:3429*/
  /*T(copierContenuTranslation) = U*/
  }

}
void cloreTableTranslation(struct StructSectionEDL *section ) 
{ Elf32_Shdr *descripteurElf ;
  Elf_Data *descripteurContenu ;
  TranslationEDL *translationsSource ;
  unsigned int nbTranslations ;
  SectionEDL *tableSymboles ;
  Elf32_Rel *translationsCible ;
  unsigned int indexSymboleSource ;
  unsigned int i ;
  
  {/*sid:68*/
  translationsSource = (section->tableTranslation)->translations;
  /*sid:68*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(cloreTableTranslation) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(descripteurElf) = U*/
  /*T(descripteurContenu) = U*/
  /*T(translationsSource) = G(section)*/
  /*T(nbTranslations) = U*/
  /*T(tableSymboles) = U*/
  /*T(translationsCible) = U*/
  /*T(indexSymboleSource) = U*/
  /*T(i) = U*/
  
  /*sid:69*/
  nbTranslations = (section->tableTranslation)->nbTranslations;
  /*sid:69*/
  /*T(nbTranslations) = G(section)*/
  
  /*sid:70*/
  tableSymboles = (section->tableTranslation)->tableSymboles;
  /*sid:70*/
  /*T(tableSymboles) = G(section)*/
  
  section->contenuElf = calloc(nbTranslations, sizeof(Elf32_Rel ));
  /*sid:72*/
  translationsCible = (Elf32_Rel *)section->contenuElf;
  /*sid:72*/
  /*T(translationsCible) = G(section)*/
  
  i = 0U;
  /*sid:74*/
  while (i != nbTranslations) {(translationsCible + i)->r_offset = (unsigned int )(
                               translationsSource + i)->adresse;
    indexSymboleSource = indexSymbole(tableSymboles,
                                      (translationsSource + i)->symbole);
    (translationsCible + i)->r_info = (indexSymboleSource << 8) + (unsigned int )((unsigned char )(
                                      translationsSource + i)->type);
    i ++;}
  
  /*sid:74*/
  /*T(indexSymboleSource) = G(section)*/
  /*T(i) = G(section)*/
  
  section->tailleContenuElf = nbTranslations * sizeof(Elf32_Rel );
  /*sid:83*/
  descripteurElf = section->descripteurElf;
  /*sid:83*/
  /*T(descripteurElf) = G(section)*/
  
  descripteurElf->sh_link = ((section->tableTranslation)->tableSymboles)->indexElf;
  descripteurElf->sh_info = ((section->tableTranslation)->sectionCode)->indexElf;
  /*sid:86*/
  descripteurContenu = section->descripteurContenu;
  /*sid:86*/
  /*T(descripteurContenu) = G(section)*/
  
  descripteurContenu->d_buf = section->contenuElf;
  descripteurContenu->d_type = ELF_T_REL;
  /*sid:3430*/
  return;
  /*sid:3430*/
  /*T(cloreTableTranslation) = U*/
  }

}
void fermerTableTranslation(struct StructSectionEDL *section ) 
{ 
  
  {/*sid:90*/
  libererFormatInterneTranslation(section);
  /*sid:90*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(fermerTableTranslation) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  
  if ((section->objetParent)->mode == (ModeOuvertureEDL )ELF_C_WRITE) {if
     (section->contenuElf != (void *)0) {free(section->contenuElf);
    section->contenuElf = (void *)0;}
    }
  
  /*sid:3431*/
  return;
  /*sid:3431*/
  /*T(fermerTableTranslation) = G(section)*/
  }

}
void fusionnerTableTranslation(struct StructSectionEDL *sectionSource ,
                               struct StructSectionEDL *sectionCible ) 
{ TableTranslationEDL *tableTranslationSource ;
  TranslationEDL *translationsSource ;
  unsigned int nbTranslationsSource ;
  SectionEDL *sectionCodeSource ;
  TableTranslationEDL *tableTranslationCible ;
  SectionEDL *sectionCodeCible ;
  TranslationEDL translationSource ;
  TranslationEDL *translationCible ;
  unsigned int i ;
  
  {/*sid:100*/
  tableTranslationSource = sectionSource->tableTranslation;
  /*sid:100*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(fusionnerTableTranslation) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(sectionCible) + G(sectionSource) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(sectionSource) = G(sectionSource)*/
  /*T(sectionCible) = G(sectionCible)*/
  /*T(tableTranslationSource) = G(sectionSource)*/
  /*T(translationsSource) = U*/
  /*T(nbTranslationsSource) = U*/
  /*T(sectionCodeSource) = U*/
  /*T(tableTranslationCible) = U*/
  /*T(sectionCodeCible) = U*/
  /*T(translationSource) = U*/
  /*T(translationCible) = U*/
  /*T(i) = U*/
  
  /*sid:101*/
  translationsSource = tableTranslationSource->translations;
  /*sid:101*/
  /*T(translationsSource) = G(sectionSource)*/
  
  /*sid:102*/
  nbTranslationsSource = tableTranslationSource->nbTranslations;
  /*sid:102*/
  /*T(nbTranslationsSource) = G(sectionSource)*/
  
  /*sid:103*/
  sectionCodeSource = tableTranslationSource->sectionCode;
  /*sid:103*/
  /*T(sectionCodeSource) = G(sectionSource)*/
  
  /*sid:104*/
  tableTranslationCible = sectionCible->tableTranslation;
  /*sid:104*/
  /*T(tableTranslationCible) = G(sectionCible)*/
  
  /*sid:105*/
  sectionCodeCible = tableTranslationCible->sectionCode;
  /*sid:105*/
  /*T(sectionCodeCible) = G(sectionCible)*/
  
  i = 0U;
  /*sid:107*/
  while (i != nbTranslationsSource) {translationSource = *(translationsSource + i);
    ajouterTranslation(sectionCible, & translationSource, & translationCible);
    ajusterOffset(translationCible, sectionCodeSource);
    ajusterEmplacement(translationSource, *translationCible, sectionCodeCible);
    i ++;}
  
  /*sid:107*/
  /*T(translationSource) = G(sectionSource)*/
  /*T(translationCible) = G(sectionCible) + G(sectionSource)*/
  /*T(i) = G(sectionSource)*/
  
  /*sid:3432*/
  return;
  /*sid:3432*/
  /*T(fusionnerTableTranslation) = U*/
  }

}
void completerSectionCode(struct StructSectionEDL *section ) 
{ TableTranslationEDL *tableTranslation ;
  TranslationEDL *translations ;
  unsigned int nbTranslations ;
  SectionEDL *sectionCode ;
  unsigned int i ;
  
  {/*sid:117*/
  tableTranslation = section->tableTranslation;
  /*sid:117*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(completerSectionCode) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(tableTranslation) = G(section)*/
  /*T(translations) = U*/
  /*T(nbTranslations) = U*/
  /*T(sectionCode) = U*/
  /*T(i) = U*/
  
  /*sid:118*/
  translations = tableTranslation->translations;
  /*sid:118*/
  /*T(translations) = G(section)*/
  
  /*sid:119*/
  nbTranslations = tableTranslation->nbTranslations;
  /*sid:119*/
  /*T(nbTranslations) = G(section)*/
  
  /*sid:120*/
  sectionCode = tableTranslation->sectionCode;
  /*sid:120*/
  /*T(sectionCode) = G(section)*/
  
  i = 0U;
  /*sid:122*/
  while (i != nbTranslations) {completerEmplacement(sectionCode,
                                                    *(translations + i));
    i ++;}
  
  /*sid:122*/
  /*T(i) = G(section)*/
  
  /*sid:3433*/
  return;
  /*sid:3433*/
  /*T(completerSectionCode) = U*/
  }

}
void ajouterTranslation(struct StructSectionEDL *sectionCible ,
                        TranslationEDL *translationSource ,
                        TranslationEDL **translationResultat ) 
{ TableTranslationEDL *tableTranslation ;
  TranslationEDL *translations ;
  unsigned int nbTranslations ;
  
  {/*sid:129*/
  tableTranslation = sectionCible->tableTranslation;
  /*sid:129*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(ajouterTranslation) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(translationResultat) + G(sectionCible) + G(translationSource) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(sectionCible) = G(sectionCible)*/
  /*T(translationSource) = G(translationSource)*/
  /*T(translationResultat) = G(translationResultat)*/
  /*T(tableTranslation) = G(sectionCible)*/
  /*T(translations) = U*/
  /*T(nbTranslations) = U*/
  
  /*sid:130*/
  translations = tableTranslation->translations;
  /*sid:130*/
  /*T(translations) = G(sectionCible)*/
  
  /*sid:131*/
  nbTranslations = tableTranslation->nbTranslations;
  /*sid:131*/
  /*T(nbTranslations) = G(sectionCible)*/
  
  /*sid:132*/
  (translations + nbTranslations)->adresse = translationSource->adresse;
  /*sid:132*/
  /*T(translations) = G(translationSource) + G(sectionCible)*/
  
  (translations + nbTranslations)->type = translationSource->type;
  (translations + nbTranslations)->symbole = (translationSource->symbole)->symboleImage;
  /*sid:135*/
  tableTranslation->translations = translations;
  /*sid:135*/
  /*T(tableTranslation) = G(translationSource) + G(sectionCible)*/
  
  tableTranslation->nbTranslations = nbTranslations + 1U;
  if (translationResultat != (void *)0) {/*sid:139*/
    *translationResultat = translations + nbTranslations;
    /*sid:139*/
    /*T(translationResultat) = G(translationSource) + G(sectionCible) + G(translationResultat)*/
    }
  
  /*sid:3434*/
  return;
  /*sid:3434*/
  /*T(ajouterTranslation) = U*/
  /*T(translationResultat) = G(sectionCible) + G(translationSource) + G(translationResultat)*/
  }

}
unsigned int tailleTableTranslation(struct StructSectionEDL *section ) 
{ unsigned int __retres ;
  
  {/*sid:142*/
  __retres = (section->tableTranslation)->nbTranslations;
  /*sid:142*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = G(section)*/
  /*T(tailleTableTranslation) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  
  /*sid:3435*/
  return (__retres);
  /*sid:3435*/
  /*T(tailleTableTranslation) = G(section)*/
  }

}
void afficherTranslations(struct StructSectionEDL *section ) 
{ TranslationEDL *translations ;
  unsigned int nbTranslations ;
  unsigned int i ;
  
  {/*sid:143*/
  printf((char const   *)"%s:%s\n", (section->objetParent)->nom,
         (section->nom)->chaine);
  /*sid:143*/
  /*T(journal) = G(section)*/
  /*T(premiereFois) = G(section)*/
  /*T(sectionBss) = G(section)*/
  /*T(adresseText) = G(section)*/
  /*T(adresseData) = G(section)*/
  /*T(adresseRodata) = G(section)*/
  /*T(adresseBss) = G(section)*/
  /*T(adresseStack) = G(section)*/
  /*T(nomPtEntree) = G(section)*/
  /*T(boutismeHote) = G(section)*/
  /*T(iterateurGlobal) = G(section)*/
  /*T(objets) = G(section)*/
  /*T(copieSuperficielle) = G(section)*/
  /*T(objets_0) = G(section)*/
  /*T(nbFichiersDonnees) = G(section)*/
  /*T(afficherTranslations) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(translations) = U*/
  /*T(nbTranslations) = U*/
  /*T(i) = U*/
  
  /*sid:144*/
  afficherTitreTranslations();
  /*sid:144*/
  /*T(journal) = U*/
  /*T(premiereFois) = U*/
  /*T(sectionBss) = U*/
  /*T(adresseText) = U*/
  /*T(adresseData) = U*/
  /*T(adresseRodata) = U*/
  /*T(adresseBss) = U*/
  /*T(adresseStack) = U*/
  /*T(nomPtEntree) = U*/
  /*T(boutismeHote) = U*/
  /*T(iterateurGlobal) = U*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = U*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = U*/
  
  /*sid:145*/
  translations = (section->tableTranslation)->translations;
  /*sid:145*/
  /*T(translations) = G(section)*/
  
  /*sid:146*/
  nbTranslations = (section->tableTranslation)->nbTranslations;
  /*sid:146*/
  /*T(nbTranslations) = G(section)*/
  
  i = 0U;
  /*sid:148*/
  while (i != nbTranslations) {afficherTranslation(*(translations + i));
    i ++;}
  
  /*sid:148*/
  /*T(journal) = G(section)*/
  /*T(premiereFois) = G(section)*/
  /*T(sectionBss) = G(section)*/
  /*T(adresseText) = G(section)*/
  /*T(adresseData) = G(section)*/
  /*T(adresseRodata) = G(section)*/
  /*T(adresseBss) = G(section)*/
  /*T(adresseStack) = G(section)*/
  /*T(nomPtEntree) = G(section)*/
  /*T(boutismeHote) = G(section)*/
  /*T(iterateurGlobal) = G(section)*/
  /*T(objets) = G(section)*/
  /*T(copieSuperficielle) = G(section)*/
  /*T(objets_0) = G(section)*/
  /*T(nbFichiersDonnees) = G(section)*/
  /*T(i) = G(section)*/
  
  printf((char const   *)"\n");
  /*sid:3436*/
  return;
  /*sid:3436*/
  /*T(afficherTranslations) = U*/
  }

}
static void completerEmplacement(struct StructSectionEDL *sectionCode ,
                                 TranslationEDL translation ) 
{ 
  
  /*sid:3437*/
  return;
  /*sid:3437*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(completerEmplacement) = U*/
  /*T(sectionCode) = G(sectionCode)*/
  /*T(translation) = G(translation)*/
  

}
static void ajusterEmplacement(TranslationEDL translationSource ,
                               TranslationEDL translationCible ,
                               struct StructSectionEDL *sectionCodeCible ) 
{ 
  
  /*sid:3438*/
  return;
  /*sid:3438*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(ajusterEmplacement) = U*/
  /*T(translationSource) = G(translationSource)*/
  /*T(translationCible) = G(translationCible)*/
  /*T(sectionCodeCible) = G(sectionCodeCible)*/
  

}
static void ajusterOffset(TranslationEDL *translation ,
                          struct StructSectionEDL *sectionCodeSource ) 
{ 
  
  {/*sid:158*/
  translation->adresse += (unsigned long )(sectionCodeSource->sectionProgramme)->decalageContenu;
  /*sid:158*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(ajusterOffset) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(sectionCodeSource) + G(translation) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(translation) = G(sectionCodeSource) + G(translation)*/
  /*T(sectionCodeSource) = G(sectionCodeSource)*/
  
  /*sid:3439*/
  return;
  /*sid:3439*/
  /*T(ajusterOffset) = U*/
  }

}
static unsigned long inversionBoutismeMot(unsigned long donnee ) 
{ unsigned int resultat ;
  unsigned char *pDonnee ;
  unsigned char *pResultat ;
  unsigned long __retres ;
  
  {/*sid:161*/
  pDonnee = (unsigned char *)(& donnee);
  /*sid:161*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = U*/
  /*T(inversionBoutismeMot) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(donnee) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(donnee) = G(donnee)*/
  /*T(resultat) = U*/
  /*T(pDonnee) = G(donnee)*/
  /*T(pResultat) = U*/
  
  pResultat = (unsigned char *)(& resultat);
  /*sid:164*/
  *pResultat = *(pDonnee + 3);
  /*sid:164*/
  /*T(pResultat) = G(donnee)*/
  
  *(pResultat + 1) = *(pDonnee + 2);
  *(pResultat + 2) = *(pDonnee + 1);
  *(pResultat + 3) = *pDonnee;
  __retres = (unsigned long )resultat;
  /*sid:3440*/
  return (__retres);
  /*sid:3440*/
  /*T(inversionBoutismeMot) = U*/
  }

}
static unsigned short inversionBoutismeDemiMot(unsigned short donnee ) 
{ unsigned short resultat ;
  unsigned char *pDonnee ;
  unsigned char *pResultat ;
  
  {/*sid:170*/
  pDonnee = (unsigned char *)(& donnee);
  /*sid:170*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(inversionBoutismeDemiMot) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(donnee) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(donnee) = G(donnee)*/
  /*T(resultat) = U*/
  /*T(pDonnee) = G(donnee)*/
  /*T(pResultat) = U*/
  
  pResultat = (unsigned char *)(& resultat);
  /*sid:173*/
  *pResultat = *(pDonnee + 1);
  /*sid:173*/
  /*T(pResultat) = G(donnee)*/
  
  *(pResultat + 1) = *pDonnee;
  /*sid:175*/
  return (resultat);
  /*sid:175*/
  /*T(inversionBoutismeDemiMot) = U*/
  }

}
static unsigned long alignementMot(void *donnee ) 
{ unsigned long resultat ;
  unsigned char *pDonnee ;
  unsigned char *pResultat ;
  
  {/*sid:177*/
  pDonnee = (unsigned char *)donnee;
  /*sid:177*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(alignementMot) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(donnee) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(donnee) = G(donnee)*/
  /*T(resultat) = U*/
  /*T(pDonnee) = G(donnee)*/
  /*T(pResultat) = U*/
  
  pResultat = (unsigned char *)(& resultat);
  /*sid:180*/
  *pResultat = *pDonnee;
  /*sid:180*/
  /*T(pResultat) = G(donnee)*/
  
  *(pResultat + 1) = *(pDonnee + 1);
  *(pResultat + 2) = *(pDonnee + 2);
  *(pResultat + 3) = *(pDonnee + 3);
  /*sid:184*/
  return (resultat);
  /*sid:184*/
  /*T(alignementMot) = U*/
  }

}
static unsigned short alignementDemiMot(void *donnee ) 
{ unsigned short resultat ;
  unsigned char *pDonnee ;
  unsigned char *pResultat ;
  
  {/*sid:186*/
  pDonnee = (unsigned char *)donnee;
  /*sid:186*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(alignementDemiMot) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(donnee) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(donnee) = G(donnee)*/
  /*T(resultat) = U*/
  /*T(pDonnee) = G(donnee)*/
  /*T(pResultat) = U*/
  
  pResultat = (unsigned char *)(& resultat);
  /*sid:189*/
  *pResultat = *pDonnee;
  /*sid:189*/
  /*T(pResultat) = G(donnee)*/
  
  *(pResultat + 1) = *(pDonnee + 1);
  /*sid:191*/
  return (resultat);
  /*sid:191*/
  /*T(alignementDemiMot) = U*/
  }

}
static void desalignerMot(unsigned long donnee , void *resultat ) 
{ unsigned char *pDonnee ;
  unsigned char *pResultat ;
  
  {/*sid:193*/
  pDonnee = (unsigned char *)(& donnee);
  /*sid:193*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(desalignerMot) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(resultat) + G(donnee) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(donnee) = G(donnee)*/
  /*T(resultat) = G(resultat)*/
  /*T(pDonnee) = G(donnee)*/
  /*T(pResultat) = U*/
  
  /*sid:195*/
  pResultat = (unsigned char *)resultat;
  /*sid:195*/
  /*T(pResultat) = G(resultat)*/
  
  /*sid:196*/
  *pResultat = *pDonnee;
  /*sid:196*/
  /*T(pResultat) = G(donnee) + G(resultat)*/
  
  *(pResultat + 1) = *(pDonnee + 1);
  *(pResultat + 2) = *(pDonnee + 2);
  *(pResultat + 3) = *(pDonnee + 3);
  /*sid:3441*/
  return;
  /*sid:3441*/
  /*T(desalignerMot) = U*/
  }

}
static void desalignerDemiMot(unsigned short donnee , void *resultat ) 
{ unsigned char *pDonnee ;
  unsigned char *pResultat ;
  
  {/*sid:202*/
  pDonnee = (unsigned char *)(& donnee);
  /*sid:202*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(desalignerDemiMot) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(resultat) + G(donnee) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(donnee) = G(donnee)*/
  /*T(resultat) = G(resultat)*/
  /*T(pDonnee) = G(donnee)*/
  /*T(pResultat) = U*/
  
  /*sid:204*/
  pResultat = (unsigned char *)resultat;
  /*sid:204*/
  /*T(pResultat) = G(resultat)*/
  
  /*sid:205*/
  *pResultat = *pDonnee;
  /*sid:205*/
  /*T(pResultat) = G(donnee) + G(resultat)*/
  
  *(pResultat + 1) = *(pDonnee + 1);
  /*sid:3442*/
  return;
  /*sid:3442*/
  /*T(desalignerDemiMot) = U*/
  }

}
static void verifierValeur(long valeur , long min , long max ) 
{ 
  
  {/*sid:209*/
  if (valeur < min)
  {/*sid:210*/
  printf((char const   *)"%s%s\n", "erreur : ",
         "depassement capacite translation ");
  /*sid:210*/
  /*T(journal) = U*/
  /*T(premiereFois) = U*/
  /*T(sectionBss) = U*/
  /*T(adresseText) = U*/
  /*T(adresseData) = U*/
  /*T(adresseRodata) = U*/
  /*T(adresseBss) = U*/
  /*T(adresseStack) = U*/
  /*T(nomPtEntree) = U*/
  /*T(boutismeHote) = U*/
  /*T(iterateurGlobal) = U*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = U*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = U*/
  
  exit(1);}
  else {if (valeur > max) {/*sid:214*/
          printf((char const   *)"%s%s\n", "erreur : ",
                 "depassement capacite translation ");
          /*sid:214*/
          /*T(journal) = U*/
          /*T(premiereFois) = U*/
          /*T(sectionBss) = U*/
          /*T(adresseText) = U*/
          /*T(adresseData) = U*/
          /*T(adresseRodata) = U*/
          /*T(adresseBss) = U*/
          /*T(adresseStack) = U*/
          /*T(nomPtEntree) = U*/
          /*T(boutismeHote) = U*/
          /*T(iterateurGlobal) = U*/
          /*T(objets) = U*/
          /*T(copieSuperficielle) = U*/
          /*T(objets_0) = U*/
          /*T(nbFichiersDonnees) = U*/
          
          exit(1);}
  }
  
  /*sid:209*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(verifierValeur) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(max) + G(valeur) + G(min) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(valeur) = G(valeur)*/
  /*T(min) = G(min)*/
  /*T(max) = G(max)*/
  
  /*sid:3443*/
  return;
  /*sid:3443*/
  /*T(verifierValeur) = G(max) + G(valeur) + G(min)*/
  }

}
static void afficherTitreTranslations(void) 
{ 
  
  {/*sid:218*/
  printf((char const   *)"%s\n", " offset  | type | nom symbole");
  /*sid:218*/
  /*T(journal) = U*/
  /*T(premiereFois) = U*/
  /*T(sectionBss) = U*/
  /*T(adresseText) = U*/
  /*T(adresseData) = U*/
  /*T(adresseRodata) = U*/
  /*T(adresseBss) = U*/
  /*T(adresseStack) = U*/
  /*T(nomPtEntree) = U*/
  /*T(boutismeHote) = U*/
  /*T(iterateurGlobal) = U*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = U*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = U*/
  /*T(afficherTitreTranslations) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  printf((char const   *)"---------|------|------------\n");
  /*sid:3444*/
  return;
  /*sid:3444*/
  /*T(afficherTitreTranslations) = U*/
  }

}
static void afficherTranslation(TranslationEDL translation ) 
{ 
  
  {/*sid:221*/
  printf((char const   *)"%08lx |  %2d  | %-30s\n", translation.adresse,
         translation.type, ((translation.symbole)->nom)->chaine);
  /*sid:221*/
  /*T(journal) = G(translation)*/
  /*T(premiereFois) = G(translation)*/
  /*T(sectionBss) = G(translation)*/
  /*T(adresseText) = G(translation)*/
  /*T(adresseData) = G(translation)*/
  /*T(adresseRodata) = G(translation)*/
  /*T(adresseBss) = G(translation)*/
  /*T(adresseStack) = G(translation)*/
  /*T(nomPtEntree) = G(translation)*/
  /*T(boutismeHote) = G(translation)*/
  /*T(iterateurGlobal) = G(translation)*/
  /*T(objets) = G(translation)*/
  /*T(copieSuperficielle) = G(translation)*/
  /*T(objets_0) = G(translation)*/
  /*T(nbFichiersDonnees) = G(translation)*/
  /*T(afficherTranslation) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(translation) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(translation) = G(translation)*/
  
  /*sid:3445*/
  return;
  /*sid:3445*/
  /*T(afficherTranslation) = U*/
  }

}
static void libererFormatInterneTranslation(struct StructSectionEDL *section ) 
{ 
  
  {/*sid:224*/
  if (section->tableTranslation != (void *)0) {if ((section->tableTranslation)->translations != (void *)0) {
                                                 free((void *)(section->tableTranslation)->translations);}
    
    free((void *)section->tableTranslation);
    section->tableTranslation = (struct StructTableTranslationEDL *)((void *)0);}
  
  /*sid:224*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(libererFormatInterneTranslation) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  
  /*sid:3446*/
  return;
  /*sid:3446*/
  /*T(libererFormatInterneTranslation) = U*/
  }

}
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr ,
                                                   size_t __size )  __attribute__((__warn_unused_result__)) ;
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest ,
                                                  void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest ,
                                                  char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 ,
                                                char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
void ajouterSectionBss(ObjetEDL *objet ,
                       struct StructSectionEDL **sectionResultat ) ;
struct StructSectionEDL *sectionSelonNomEtType(ObjetEDL *objet , char *nom ,
                                               unsigned int type ) ;
char *nomPointEntree(void) ;
void ajouterChaine(struct StructSectionEDL *section , char *chaineC ,
                   unsigned int index_0 , unsigned int estSuffixe_0 ,
                   ChaineEDL **chaineAjoutee ) ;
void supprimerChaine(struct StructSectionEDL *section , ChaineEDL *chaine ) ;
void extraireChaineSelonIndex(struct StructSectionEDL *section ,
                              unsigned int index_0 , ChaineEDL **chaine ) ;
void dupliquerChaine(ChaineEDL *chaineSource , ChaineEDL **chaineCible ) ;
ChaineEDL *creationChaine(char *chaineC , unsigned int index_0 ,
                          unsigned int estSuffixe_0 ) ;
void libererChaine(ChaineEDL **chaine ) ;
void ouvrirTableSymboles(struct StructSectionEDL *section ) ;
void creerTableSymboles(struct StructSectionEDL *section ,
                        struct StructSectionEDL *tableChaines ,
                        unsigned int nbMax ) ;
void copierContenuSymboles(struct StructSectionEDL *tableSource ,
                           struct StructSectionEDL *tableCible ) ;
void cloreTableSymboles(struct StructSectionEDL *section ) ;
void fermerTableSymboles(struct StructSectionEDL *section ) ;
void fusionnerTableSymboles(struct StructSectionEDL *sectionSource ,
                            struct StructSectionEDL *sectionCible ) ;
void ajouterSymbole(struct StructSectionEDL *section ,
                    SymboleEDL *symboleSource , SymboleEDL **symboleResultat ) ;
void promouvoirSymbolesCommuns(struct StructSectionEDL *section ) ;
void ajusterSymbolesCRT(struct StructSectionEDL *section ,
                        unsigned long bssStart , unsigned long bssEnd ) ;
void implanterTableSymboles(struct StructSectionEDL *section ) ;
void supprimerSymboleSelonNom(struct StructSectionEDL *section ,
                              struct StructChaineEDL *nomSymbole ) ;
void supprimerSymbolesSectionInutiles(struct StructSectionEDL *section ) ;
unsigned int tailleTableSymboles(struct StructSectionEDL *section ) ;
void afficherSymboles(struct StructSectionEDL *section ) ;
static void fusionnerSymboleLocal(SymboleEDL *symboleSource ,
                                  struct StructSectionEDL *sectionSource ,
                                  struct StructSectionEDL *sectionCible ) ;
static void fusionnerSymboleGlobal(SymboleEDL *symboleSource ,
                                   struct StructSectionEDL *sectionSource ,
                                   struct StructSectionEDL *sectionCible ,
                                   unsigned int *erreur ) ;
static void afficherTitreSymboles(void) ;
static void afficherSymbole(SymboleEDL symbole , unsigned int indexElf ) ;
static void libererFormatInterneSymboles(struct StructSectionEDL *section ) ;
static SymboleEDL *symboleGlobalSelonNom(struct StructSectionEDL *tableSymboles ,
                                         struct StructChaineEDL *nomSymbole ) ;
static SymboleEDL *symboleSectionSelonNom(struct StructSectionEDL *tableSymboles ,
                                          struct StructChaineEDL *nomSymbole ) ;
static void supprimerSymbole(struct StructSectionEDL *section ,
                             SymboleEDL *symbole ) ;
void ouvrirTableSymboles(struct StructSectionEDL *section ) 
{ ObjetEDL *objet ;
  TableSymbolesEDL *tableSymboles ;
  Elf32_Sym *symbolesSource ;
  SymboleEDL **symbolesLocaux ;
  SymboleEDL **symbolesGlobaux ;
  unsigned int nbLocaux ;
  unsigned int nbGlobaux ;
  unsigned int nbSymboles ;
  unsigned int indexTableChaines ;
  SectionEDL *tableChaines ;
  unsigned int indexNom ;
  SectionEDL *sectionDefinition ;
  unsigned int i ;
  unsigned int j ;
  
  {/*sid:233*/
  tableSymboles = (TableSymbolesEDL *)calloc(1U, sizeof(TableSymbolesEDL ));
  /*sid:233*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(ouvrirTableSymboles) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(objet) = U*/
  /*T(tableSymboles) = U*/
  /*T(symbolesSource) = U*/
  /*T(symbolesLocaux) = U*/
  /*T(symbolesGlobaux) = U*/
  /*T(nbLocaux) = U*/
  /*T(nbGlobaux) = U*/
  /*T(nbSymboles) = U*/
  /*T(indexTableChaines) = U*/
  /*T(tableChaines) = U*/
  /*T(indexNom) = U*/
  /*T(sectionDefinition) = U*/
  /*T(i) = U*/
  /*T(j) = U*/
  
  /*sid:234*/
  nbSymboles = section->tailleContenuElf / sizeof(Elf32_Sym );
  /*sid:234*/
  /*T(nbSymboles) = G(section)*/
  
  /*sid:235*/
  nbLocaux = (section->descripteurElf)->sh_info;
  /*sid:235*/
  /*T(nbLocaux) = G(section)*/
  
  /*sid:236*/
  nbGlobaux = nbSymboles - nbLocaux;
  /*sid:236*/
  /*T(nbGlobaux) = G(section)*/
  
  /*sid:237*/
  symbolesLocaux = (SymboleEDL **)calloc(nbLocaux, sizeof(SymboleEDL *));
  /*sid:237*/
  /*T(symbolesLocaux) = G(section)*/
  
  /*sid:238*/
  symbolesGlobaux = (SymboleEDL **)calloc(nbGlobaux, sizeof(SymboleEDL *));
  /*sid:238*/
  /*T(symbolesGlobaux) = G(section)*/
  
  /*sid:239*/
  objet = section->objetParent;
  /*sid:239*/
  /*T(objet) = G(section)*/
  
  /*sid:240*/
  indexTableChaines = (section->descripteurElf)->sh_link;
  /*sid:240*/
  /*T(indexTableChaines) = G(section)*/
  
  /*sid:241*/
  tableChaines = sectionSelonIndex(objet, indexTableChaines);
  /*sid:241*/
  /*T(tableChaines) = G(section)*/
  
  /*sid:242*/
  symbolesSource = (Elf32_Sym *)section->contenuElf;
  /*sid:242*/
  /*T(symbolesSource) = G(section)*/
  
  i = 0U;
  /*sid:244*/
  while (i != nbLocaux) {*(symbolesLocaux + i) = (SymboleEDL *)calloc(
                         1U, sizeof(SymboleEDL ));
    (*(symbolesLocaux + i))->valeur = (unsigned long )(symbolesSource + i)->st_value;
    (*(symbolesLocaux + i))->taille = (symbolesSource + i)->st_size;
    (*(symbolesLocaux + i))->portee = (unsigned int )((int )(symbolesSource + i)->st_info >> 4);
    (*(symbolesLocaux + i))->type = (unsigned int )((int )(symbolesSource + i)->st_info & 15);
    (*(symbolesLocaux + i))->natureDefinition = (unsigned int )(symbolesSource + i)->st_shndx;
    switch ((int )(symbolesSource + i)->st_shndx) {case 0: 
    case 65521: 
    sectionDefinition = (SectionEDL *)((void *)0);
    break;
    default: ;
    sectionDefinition = sectionSelonIndex(objet,
                                          (unsigned int )(symbolesSource + i)->st_shndx);}
    
    (*(symbolesLocaux + i))->sectionDefinition = sectionDefinition;
    if ((*(symbolesLocaux + i))->type == (TypeSymboleEDL )3)
    {dupliquerChaine(sectionDefinition->nom, & (*(symbolesLocaux + i))->nom);}
    else {indexNom = (symbolesSource + i)->st_name;
    extraireChaineSelonIndex(tableChaines, indexNom,
                             & (*(symbolesLocaux + i))->nom);}
    
    i ++;}
  
  /*sid:244*/
  /*T(indexNom) = G(section)*/
  /*T(sectionDefinition) = G(section)*/
  /*T(i) = G(section)*/
  
  /*sid:266*/
  i = 0U;
  /*sid:266*/
  /*T(i) = U*/
  
  /*sid:267*/
  j = nbLocaux;
  /*sid:267*/
  /*T(j) = G(section)*/
  
  /*sid:268*/
  while (i != nbGlobaux) {*(symbolesGlobaux + i) = (SymboleEDL *)calloc(
                          1U, sizeof(SymboleEDL ));
    (*(symbolesGlobaux + i))->valeur = (unsigned long )(symbolesSource + j)->st_value;
    (*(symbolesGlobaux + i))->taille = (symbolesSource + j)->st_size;
    (*(symbolesGlobaux + i))->portee = (unsigned int )((int )(symbolesSource + j)->st_info >> 4);
    (*(symbolesGlobaux + i))->type = (unsigned int )((int )(symbolesSource + j)->st_info & 15);
    (*(symbolesGlobaux + i))->natureDefinition = (unsigned int )(symbolesSource + j)->st_shndx;
    switch ((int )(symbolesSource + j)->st_shndx) {case 0: 
    case 65521: 
    case 65522: 
    sectionDefinition = (SectionEDL *)((void *)0);
    break;
    default: ;
    sectionDefinition = sectionSelonIndex(objet,
                                          (unsigned int )(symbolesSource + j)->st_shndx);}
    
    (*(symbolesGlobaux + i))->sectionDefinition = sectionDefinition;
    indexNom = (symbolesSource + j)->st_name;
    extraireChaineSelonIndex(tableChaines, indexNom,
                             & (*(symbolesGlobaux + i))->nom);
    (*(symbolesGlobaux + i))->tableSymbolesOrigine = section;
    i ++;
    j ++;}
  
  /*sid:268*/
  /*T(i) = G(section)*/
  
  /*sid:289*/
  tableSymboles->symbolesLocaux = symbolesLocaux;
  /*sid:289*/
  /*T(tableSymboles) = G(section)*/
  
  tableSymboles->symbolesGlobaux = symbolesGlobaux;
  tableSymboles->nbLocaux = nbLocaux;
  tableSymboles->nbGlobaux = nbGlobaux;
  tableSymboles->nbMaxLocaux = nbLocaux;
  tableSymboles->nbMaxGlobaux = nbGlobaux;
  tableSymboles->tableChaines = tableChaines;
  section->tableSymboles = tableSymboles;
  /*sid:3447*/
  return;
  /*sid:3447*/
  /*T(ouvrirTableSymboles) = U*/
  }

}
void creerTableSymboles(struct StructSectionEDL *section ,
                        struct StructSectionEDL *tableChaines ,
                        unsigned int nbMax ) 
{ SymboleEDL symboleNul ;
  
  {/*sid:298*/
  section->contenuElf = (void *)0;
  /*sid:298*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(creerTableSymboles) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(nbMax) + G(section) + G(tableChaines) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(tableChaines) = G(tableChaines)*/
  /*T(nbMax) = G(nbMax)*/
  /*T(symboleNul) = U*/
  
  section->tableSymboles = (struct StructTableSymbolesEDL *)calloc(1U,
                                                                   sizeof(TableSymbolesEDL ));
  (section->tableSymboles)->symbolesLocaux = (SymboleEDL **)calloc(nbMax,
                                                                   sizeof(SymboleEDL *));
  (section->tableSymboles)->symbolesGlobaux = (SymboleEDL **)calloc(nbMax,
                                                                    sizeof(SymboleEDL *));
  (section->tableSymboles)->nbLocaux = 0U;
  (section->tableSymboles)->nbGlobaux = 0U;
  /*sid:304*/
  (section->tableSymboles)->nbMaxLocaux = nbMax;
  /*sid:304*/
  /*T(section) = G(nbMax) + G(section)*/
  
  (section->tableSymboles)->nbMaxGlobaux = nbMax;
  /*sid:306*/
  (section->tableSymboles)->tableChaines = tableChaines;
  /*sid:306*/
  /*T(section) = G(tableChaines) + G(nbMax) + G(section)*/
  
  symboleNul.nom = creationChaine((char *)"", 0U, 0U);
  symboleNul.valeur = 0UL;
  symboleNul.taille = 0U;
  symboleNul.portee = 0U;
  symboleNul.type = 0U;
  symboleNul.natureDefinition = 0U;
  symboleNul.sectionDefinition = (struct StructSectionEDL *)((void *)0);
  symboleNul.tableSymbolesOrigine = (struct StructSectionEDL *)((void *)0);
  ajouterSymbole(section, & symboleNul, (SymboleEDL **)((void *)0));
  libererChaine(& symboleNul.nom);
  /*sid:3448*/
  return;
  /*sid:3448*/
  /*T(creerTableSymboles) = U*/
  }

}
void copierContenuSymboles(struct StructSectionEDL *tableSource ,
                           struct StructSectionEDL *tableCible ) 
{ SymboleEDL **locauxSource ;
  SymboleEDL **globauxSource ;
  unsigned int nbLocaux ;
  unsigned int nbGlobaux ;
  unsigned int i ;
  
  {/*sid:318*/
  locauxSource = (tableSource->tableSymboles)->symbolesLocaux;
  /*sid:318*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(copierContenuSymboles) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(tableCible) + G(tableSource) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(tableSource) = G(tableSource)*/
  /*T(tableCible) = G(tableCible)*/
  /*T(locauxSource) = G(tableSource)*/
  /*T(globauxSource) = U*/
  /*T(nbLocaux) = U*/
  /*T(nbGlobaux) = U*/
  /*T(i) = U*/
  
  /*sid:319*/
  globauxSource = (tableSource->tableSymboles)->symbolesGlobaux;
  /*sid:319*/
  /*T(globauxSource) = G(tableSource)*/
  
  /*sid:320*/
  nbLocaux = (tableSource->tableSymboles)->nbLocaux;
  /*sid:320*/
  /*T(nbLocaux) = G(tableSource)*/
  
  /*sid:321*/
  nbGlobaux = (tableSource->tableSymboles)->nbGlobaux;
  /*sid:321*/
  /*T(nbGlobaux) = G(tableSource)*/
  
  i = 1U;
  /*sid:323*/
  while (i != nbLocaux) {ajouterSymbole(tableCible, *(locauxSource + i),
                                        (SymboleEDL **)((void *)0));
    i ++;}
  
  /*sid:323*/
  /*T(i) = G(tableSource)*/
  
  /*sid:329*/
  i = 0U;
  /*sid:329*/
  /*T(i) = U*/
  
  /*sid:330*/
  while (i != nbGlobaux) {ajouterSymbole(tableCible, *(globauxSource + i),
                                         (SymboleEDL **)((void *)0));
    i ++;}
  
  /*sid:330*/
  /*T(i) = G(tableSource)*/
  
  /*sid:3449*/
  return;
  /*sid:3449*/
  /*T(copierContenuSymboles) = U*/
  }

}
void cloreTableSymboles(struct StructSectionEDL *section ) 
{ Elf32_Shdr *descripteurElf ;
  Elf_Data *descripteurContenu ;
  SymboleEDL **symbolesLocaux ;
  SymboleEDL **symbolesGlobaux ;
  SymboleEDL **symbolesTemp ;
  unsigned int nbLocaux ;
  unsigned int nbGlobaux ;
  SectionEDL *tableChaines ;
  Elf32_Sym *symbolesCible ;
  unsigned int i ;
  unsigned int j ;
  
  {/*sid:337*/
  symbolesLocaux = (section->tableSymboles)->symbolesLocaux;
  /*sid:337*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(cloreTableSymboles) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(descripteurElf) = U*/
  /*T(descripteurContenu) = U*/
  /*T(symbolesLocaux) = G(section)*/
  /*T(symbolesGlobaux) = U*/
  /*T(symbolesTemp) = U*/
  /*T(nbLocaux) = U*/
  /*T(nbGlobaux) = U*/
  /*T(tableChaines) = U*/
  /*T(symbolesCible) = U*/
  /*T(i) = U*/
  /*T(j) = U*/
  
  /*sid:338*/
  symbolesGlobaux = (section->tableSymboles)->symbolesGlobaux;
  /*sid:338*/
  /*T(symbolesGlobaux) = G(section)*/
  
  /*sid:339*/
  nbLocaux = (section->tableSymboles)->nbLocaux;
  /*sid:339*/
  /*T(nbLocaux) = G(section)*/
  
  /*sid:340*/
  nbGlobaux = (section->tableSymboles)->nbGlobaux;
  /*sid:340*/
  /*T(nbGlobaux) = G(section)*/
  
  /*sid:341*/
  tableChaines = (section->tableSymboles)->tableChaines;
  /*sid:341*/
  /*T(tableChaines) = G(section)*/
  
  section->contenuElf = calloc(nbLocaux + nbGlobaux, sizeof(Elf32_Sym ));
  /*sid:343*/
  symbolesCible = (Elf32_Sym *)section->contenuElf;
  /*sid:343*/
  /*T(symbolesCible) = G(section)*/
  
  /*sid:344*/
  symbolesTemp = (SymboleEDL **)calloc(nbLocaux, sizeof(SymboleEDL *));
  /*sid:344*/
  /*T(symbolesTemp) = G(section)*/
  
  j = 1U;
  i = 1U;
  /*sid:347*/
  while (i != nbLocaux) {if ((*(symbolesLocaux + i))->type == (TypeSymboleEDL )3) {
                           (symbolesCible + j)->st_name = 0U;
                           (symbolesCible + j)->st_value = (unsigned int )(*(
                           symbolesLocaux + i))->valeur;
                           (symbolesCible + j)->st_size = (*(symbolesLocaux + i))->taille;
                           (symbolesCible + j)->st_info = (unsigned char )(
                           ((*(symbolesLocaux + i))->portee << 4) + (
                           (*(symbolesLocaux + i))->type & 15U));
                           (symbolesCible + j)->st_shndx = (unsigned short )((*(
                           symbolesLocaux + i))->sectionDefinition)->indexElf;
                           *(symbolesTemp + j) = *(symbolesLocaux + i);
                           j ++;}
    
    i ++;}
  
  /*sid:347*/
  /*T(i) = G(section)*/
  /*T(j) = G(section)*/
  
  symbolesCible = (Elf32_Sym *)section->contenuElf;
  /*sid:363*/
  i = 1U;
  /*sid:363*/
  /*T(i) = U*/
  
  /*sid:364*/
  while (i != nbLocaux) {if ((*(symbolesLocaux + i))->type != (TypeSymboleEDL )3) {
                           (symbolesCible + j)->st_name = ((*(symbolesLocaux + i))->nom)->indexElf;
                           (symbolesCible + j)->st_value = (unsigned int )(*(
                           symbolesLocaux + i))->valeur;
                           (symbolesCible + j)->st_size = (*(symbolesLocaux + i))->taille;
                           (symbolesCible + j)->st_info = (unsigned char )(
                           ((*(symbolesLocaux + i))->portee << 4) + (
                           (*(symbolesLocaux + i))->type & 15U));
                           if ((*(symbolesLocaux + i))->sectionDefinition != (void *)0)
                           {(symbolesCible + j)->st_shndx = (unsigned short )((*(
                            symbolesLocaux + i))->sectionDefinition)->indexElf;}
                           else {(symbolesCible + j)->st_shndx = (unsigned short )(*(
                                 symbolesLocaux + i))->natureDefinition;}
                           
                           *(symbolesTemp + j) = *(symbolesLocaux + i);
                           j ++;}
    
    i ++;}
  
  /*sid:364*/
  /*T(i) = G(section)*/
  
  /*sid:382*/
  i = 1U;
  /*sid:382*/
  /*T(i) = U*/
  
  /*sid:383*/
  while (i != nbLocaux) {*(symbolesLocaux + i) = *(symbolesTemp + i);
    i ++;}
  
  /*sid:383*/
  /*T(i) = G(section)*/
  
  free((void *)symbolesTemp);
  /*sid:390*/
  i = 0U;
  /*sid:390*/
  /*T(i) = U*/
  
  j = nbLocaux;
  /*sid:392*/
  while (i != nbGlobaux) {(symbolesCible + j)->st_name = ((*(symbolesGlobaux + i))->nom)->indexElf;
    (symbolesCible + j)->st_value = (unsigned int )(*(symbolesGlobaux + i))->valeur;
    (symbolesCible + j)->st_size = (*(symbolesGlobaux + i))->taille;
    (symbolesCible + j)->st_info = (unsigned char )(((*(symbolesGlobaux + i))->portee << 4) + (
                                                    (*(symbolesGlobaux + i))->type & 15U));
    if ((*(symbolesGlobaux + i))->sectionDefinition != (void *)0)
    {(symbolesCible + j)->st_shndx = (unsigned short )((*(symbolesGlobaux + i))->sectionDefinition)->indexElf;}
    else {(symbolesCible + j)->st_shndx = (unsigned short )(*(symbolesGlobaux + i))->natureDefinition;}
    
    i ++;
    j ++;}
  
  /*sid:392*/
  /*T(i) = G(section)*/
  
  section->tailleContenuElf = (nbLocaux + nbGlobaux) * sizeof(Elf32_Sym );
  /*sid:407*/
  descripteurElf = section->descripteurElf;
  /*sid:407*/
  /*T(descripteurElf) = G(section)*/
  
  descripteurElf->sh_link = ((section->tableSymboles)->tableChaines)->indexElf;
  descripteurElf->sh_info = (section->tableSymboles)->nbLocaux;
  /*sid:410*/
  descripteurContenu = section->descripteurContenu;
  /*sid:410*/
  /*T(descripteurContenu) = G(section)*/
  
  descripteurContenu->d_buf = section->contenuElf;
  descripteurContenu->d_type = ELF_T_SYM;
  /*sid:3450*/
  return;
  /*sid:3450*/
  /*T(cloreTableSymboles) = U*/
  }

}
void fermerTableSymboles(struct StructSectionEDL *section ) 
{ 
  
  {/*sid:414*/
  libererFormatInterneSymboles(section);
  /*sid:414*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(fermerTableSymboles) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  
  if ((section->objetParent)->mode == (ModeOuvertureEDL )ELF_C_WRITE_0) {if
     (section->contenuElf != (void *)0) {free(section->contenuElf);
    section->contenuElf = (void *)0;}
    }
  
  /*sid:3451*/
  return;
  /*sid:3451*/
  /*T(fermerTableSymboles) = G(section)*/
  }

}
void fusionnerTableSymboles(struct StructSectionEDL *sectionSource ,
                            struct StructSectionEDL *sectionCible ) 
{ SymboleEDL **symbolesLocaux ;
  SymboleEDL **symbolesGlobaux ;
  unsigned int nbLocaux ;
  unsigned int nbGlobaux ;
  unsigned int i ;
  unsigned int erreur ;
  
  {/*sid:424*/
  symbolesLocaux = (sectionSource->tableSymboles)->symbolesLocaux;
  /*sid:424*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(fusionnerTableSymboles) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(sectionCible) + G(sectionSource) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(sectionSource) = G(sectionSource)*/
  /*T(sectionCible) = G(sectionCible)*/
  /*T(symbolesLocaux) = G(sectionSource)*/
  /*T(symbolesGlobaux) = U*/
  /*T(nbLocaux) = U*/
  /*T(nbGlobaux) = U*/
  /*T(i) = U*/
  /*T(erreur) = U*/
  
  /*sid:425*/
  nbLocaux = (sectionSource->tableSymboles)->nbLocaux;
  /*sid:425*/
  /*T(nbLocaux) = G(sectionSource)*/
  
  i = 1U;
  /*sid:427*/
  while (i != nbLocaux) {fusionnerSymboleLocal(*(symbolesLocaux + i),
                                               sectionSource, sectionCible);
    i ++;}
  
  /*sid:427*/
  /*T(i) = G(sectionSource)*/
  
  /*sid:433*/
  symbolesGlobaux = (sectionSource->tableSymboles)->symbolesGlobaux;
  /*sid:433*/
  /*T(symbolesGlobaux) = G(sectionSource)*/
  
  /*sid:434*/
  nbGlobaux = (sectionSource->tableSymboles)->nbGlobaux;
  /*sid:434*/
  /*T(nbGlobaux) = G(sectionSource)*/
  
  erreur = 0U;
  /*sid:436*/
  i = 0U;
  /*sid:436*/
  /*T(i) = U*/
  
  /*sid:437*/
  while (i != nbGlobaux) {fusionnerSymboleGlobal(*(symbolesGlobaux + i),
                                                 sectionSource, sectionCible,
                                                 & erreur);
    i ++;}
  
  /*sid:437*/
  /*T(i) = G(sectionSource)*/
  /*T(erreur) = G(sectionCible) + G(sectionSource)*/
  
  if (erreur) {exit(1);}
  
  /*sid:3452*/
  return;
  /*sid:3452*/
  /*T(fusionnerTableSymboles) = G(sectionCible) + G(sectionSource)*/
  }

}
void ajouterSymbole(struct StructSectionEDL *section ,
                    SymboleEDL *symboleSource , SymboleEDL **symboleResultat ) 
{ TableSymbolesEDL *tableSymboles ;
  SymboleEDL **symboles ;
  SymboleEDL *symboleCible ;
  unsigned int nbSymboles ;
  unsigned int nbMax ;
  SectionEDL *tableChainesCible ;
  SectionEDL *sectionDefinitionSource ;
  
  {/*sid:448*/
  tableSymboles = section->tableSymboles;
  /*sid:448*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(ajouterSymbole) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(symboleResultat) + G(section) + G(symboleSource) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(symboleSource) = G(symboleSource)*/
  /*T(symboleResultat) = G(symboleResultat)*/
  /*T(tableSymboles) = G(section)*/
  /*T(symboles) = U*/
  /*T(symboleCible) = U*/
  /*T(nbSymboles) = U*/
  /*T(nbMax) = U*/
  /*T(tableChainesCible) = U*/
  /*T(sectionDefinitionSource) = U*/
  
  /*sid:449*/
  tableChainesCible = tableSymboles->tableChaines;
  /*sid:449*/
  /*T(tableChainesCible) = G(section)*/
  
  if (symboleSource->portee == (PorteeSymboleEDL )0)
  {/*sid:452*/
  symboles = tableSymboles->symbolesLocaux;
  /*sid:452*/
  /*T(symboles) = G(section) + G(symboleSource)*/
  
  /*sid:453*/
  nbSymboles = tableSymboles->nbLocaux;
  /*sid:453*/
  /*T(nbSymboles) = G(section) + G(symboleSource)*/
  
  /*sid:454*/
  nbMax = tableSymboles->nbMaxLocaux;
  /*sid:454*/
  /*T(nbMax) = G(section) + G(symboleSource)*/
  }
  else {/*sid:455*/
  symboles = tableSymboles->symbolesGlobaux;
  /*sid:455*/
  /*T(symboles) = G(section) + G(symboleSource)*/
  
  /*sid:456*/
  nbSymboles = tableSymboles->nbGlobaux;
  /*sid:456*/
  /*T(nbSymboles) = G(section) + G(symboleSource)*/
  
  /*sid:457*/
  nbMax = tableSymboles->nbMaxGlobaux;
  /*sid:457*/
  /*T(nbMax) = G(section) + G(symboleSource)*/
  }
  
  if (nbSymboles == nbMax) {nbMax ++;
    symboles = (SymboleEDL **)realloc((void *)symboles,
                                      nbMax * sizeof(SymboleEDL *));}
  
  symboleCible = (SymboleEDL *)calloc(1U, sizeof(SymboleEDL ));
  if (symboleSource->type == (TypeSymboleEDL )3)
  {dupliquerChaine((symboleSource->sectionDefinition)->nom,
                   & symboleCible->nom);}
  else {/*sid:467*/
  ajouterChaine(tableChainesCible, (symboleSource->nom)->chaine, 0U, 0U,
                & symboleCible->nom);
  /*sid:467*/
  /*T(tableChainesCible) = G(symboleSource) + G(section)*/
  }
  
  /*sid:468*/
  symboleCible->valeur = symboleSource->valeur;
  /*sid:468*/
  /*T(symboleCible) = G(symboleSource)*/
  /*T(tableChainesCible) = G(symboleSource) + G(section)*/
  
  symboleCible->taille = symboleSource->taille;
  symboleCible->portee = symboleSource->portee;
  symboleCible->type = symboleSource->type;
  symboleCible->natureDefinition = symboleSource->natureDefinition;
  /*sid:473*/
  sectionDefinitionSource = symboleSource->sectionDefinition;
  /*sid:473*/
  /*T(sectionDefinitionSource) = G(symboleSource)*/
  
  if (sectionDefinitionSource != (void *)0) {symboleCible->sectionDefinition = sectionDefinitionSource->sectionImage;}
  
  symboleSource->symboleImage = symboleCible;
  symboleCible->tableSymbolesOrigine = symboleSource->tableSymbolesOrigine;
  *(symboles + nbSymboles) = symboleCible;
  if (symboleSource->portee == (PorteeSymboleEDL )0)
  {/*sid:483*/
  tableSymboles->symbolesLocaux = symboles;
  /*sid:483*/
  /*T(tableSymboles) = G(symboleSource) + G(section)*/
  
  tableSymboles->nbLocaux = nbSymboles + 1U;
  tableSymboles->nbMaxLocaux = nbMax;}
  else {/*sid:486*/
  tableSymboles->symbolesGlobaux = symboles;
  /*sid:486*/
  /*T(tableSymboles) = G(symboleSource) + G(section)*/
  
  tableSymboles->nbGlobaux = nbSymboles + 1U;
  tableSymboles->nbMaxGlobaux = nbMax;}
  
  if (symboleResultat != (void *)0) {/*sid:491*/
    *symboleResultat = symboleCible;
    /*sid:491*/
    /*T(symboleResultat) = G(symboleSource) + G(symboleResultat)*/
    }
  
  /*sid:3453*/
  return;
  /*sid:3453*/
  /*T(ajouterSymbole) = U*/
  /*T(symboleResultat) = G(symboleSource) + G(symboleResultat)*/
  }

}
static SectionEDL *sectionBss  = (SectionEDL *)((void *)0);
void promouvoirSymbolesCommuns(struct StructSectionEDL *section ) 
{ ObjetEDL *objet ;
  TableSymbolesEDL *tableSymboles ;
  SymboleEDL **symboles ;
  unsigned int nbSymboles ;
  unsigned int i ;
  
  {/*sid:494*/
  objet = section->objetParent;
  /*sid:494*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(promouvoirSymbolesCommuns) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(objet) = G(section)*/
  /*T(tableSymboles) = U*/
  /*T(symboles) = U*/
  /*T(nbSymboles) = U*/
  /*T(i) = U*/
  
  /*sid:495*/
  tableSymboles = section->tableSymboles;
  /*sid:495*/
  /*T(tableSymboles) = G(section)*/
  
  /*sid:496*/
  symboles = tableSymboles->symbolesGlobaux;
  /*sid:496*/
  /*T(symboles) = G(section)*/
  
  /*sid:497*/
  nbSymboles = tableSymboles->nbGlobaux;
  /*sid:497*/
  /*T(nbSymboles) = G(section)*/
  
  i = 0U;
  /*sid:499*/
  while (i != nbSymboles) {if ((*(symboles + i))->natureDefinition == (NatureDefinitionEDL )65522) {if
                              (sectionBss == (void *)0) {sectionBss = sectionSelonNomEtType(
                                                         objet,
                                                         (char *)".bss", 8U);
                             if (sectionBss == (void *)0) {ajouterSectionBss(
                                                           objet, & sectionBss);}
                             }
                             
                             etendreSectionVide(sectionBss,
                                                (*(symboles + i))->taille,
                                                (unsigned int )(*(symboles + i))->valeur,
                                                & (*(symboles + i))->valeur);
                             (*(symboles + i))->sectionDefinition = sectionBss;}
    
    i ++;}
  
  /*sid:499*/
  /*T(sectionBss) = G(section) + G(sectionBss)*/
  /*T(symboles) = G(sectionBss) + G(section)*/
  /*T(i) = G(section)*/
  
  /*sid:3454*/
  return;
  /*sid:3454*/
  /*T(promouvoirSymbolesCommuns) = U*/
  }

}
void ajusterSymbolesCRT(struct StructSectionEDL *section ,
                        unsigned long bssStart , unsigned long bssEnd ) 
{ SymboleEDL *symbole ;
  ChaineEDL nom ;
  
  {/*sid:518*/
  nom.chaine = (char *)malloc(sizeof("__bss_start__"));
  /*sid:518*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(ajusterSymbolesCRT) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(bssEnd) + G(section) + G(bssStart) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(bssStart) = G(bssStart)*/
  /*T(bssEnd) = G(bssEnd)*/
  /*T(symbole) = U*/
  /*T(nom) = U*/
  
  strcpy((char *)nom.chaine, (char const   *)"__bss_start__");
  /*sid:520*/
  symbole = symboleGlobalSelonNom(section, & nom);
  /*sid:520*/
  /*T(symbole) = G(section)*/
  
  if (symbole != (void *)0) {if (symbole->natureDefinition == (NatureDefinitionEDL )0) {/*sid:525*/
                               symbole->valeur = bssStart;
                               /*sid:525*/
                               /*T(symbole) = G(bssStart) + G(section)*/
                               
                               symbole->natureDefinition = 65521U;}
    }
  
  /*sid:529*/
  free((void *)nom.chaine);
  /*sid:529*/
  /*T(symbole) = G(bssStart) + G(section)*/
  
  /*sid:530*/
  nom.chaine = (char *)malloc(sizeof("__bss_end__"));
  /*sid:530*/
  /*T(nom) = G(section)*/
  
  strcpy((char *)nom.chaine, (char const   *)"__bss_end__");
  /*sid:532*/
  symbole = symboleGlobalSelonNom(section, & nom);
  /*sid:532*/
  /*T(symbole) = G(section)*/
  
  if (symbole != (void *)0) {if (symbole->natureDefinition == (NatureDefinitionEDL )0) {/*sid:537*/
                               symbole->valeur = bssEnd;
                               /*sid:537*/
                               /*T(symbole) = G(bssEnd) + G(section)*/
                               
                               symbole->natureDefinition = 65521U;}
    }
  
  /*sid:541*/
  free((void *)nom.chaine);
  /*sid:541*/
  /*T(symbole) = G(bssEnd) + G(section)*/
  
  nom.chaine = (char *)malloc(sizeof("end"));
  strcpy((char *)nom.chaine, (char const   *)"end");
  /*sid:544*/
  symbole = symboleGlobalSelonNom(section, & nom);
  /*sid:544*/
  /*T(symbole) = G(section)*/
  
  if (symbole != (void *)0) {if (symbole->natureDefinition == (NatureDefinitionEDL )0) {
                               supprimerSymbole(section, symbole);}
    }
  
  free((void *)nom.chaine);
  /*sid:3455*/
  return;
  /*sid:3455*/
  /*T(ajusterSymbolesCRT) = G(section)*/
  }

}
void implanterTableSymboles(struct StructSectionEDL *section ) 
{ ObjetEDL *objet ;
  TableSymbolesEDL *tableSymboles ;
  SymboleEDL **symboles ;
  unsigned int nbSymboles ;
  SectionEDL *sectionDefinition ;
  unsigned int nbIndefinis ;
  unsigned int i ;
  char *tmp ;
  int tmp_0 ;
  
  {/*sid:554*/
  tableSymboles = section->tableSymboles;
  /*sid:554*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(implanterTableSymboles) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(objet) = U*/
  /*T(tableSymboles) = G(section)*/
  /*T(symboles) = U*/
  /*T(nbSymboles) = U*/
  /*T(sectionDefinition) = U*/
  /*T(nbIndefinis) = U*/
  /*T(i) = U*/
  /*T(tmp) = U*/
  /*T(tmp_0) = U*/
  
  /*sid:555*/
  symboles = tableSymboles->symbolesLocaux;
  /*sid:555*/
  /*T(symboles) = G(section)*/
  
  /*sid:556*/
  nbSymboles = tableSymboles->nbLocaux;
  /*sid:556*/
  /*T(nbSymboles) = G(section)*/
  
  i = 1U;
  /*sid:558*/
  while (i != nbSymboles) {sectionDefinition = (*(symboles + i))->sectionDefinition;
    if (sectionDefinition != (void *)0) {(*(symboles + i))->valeur += sectionDefinition->adresse;}
    
    i ++;}
  
  /*sid:558*/
  /*T(sectionDefinition) = G(section)*/
  /*T(i) = G(section)*/
  
  /*sid:567*/
  objet = section->objetParent;
  /*sid:567*/
  /*T(objet) = G(section)*/
  
  symboles = tableSymboles->symbolesGlobaux;
  nbSymboles = tableSymboles->nbGlobaux;
  nbIndefinis = 0U;
  /*sid:571*/
  i = 0U;
  /*sid:571*/
  /*T(i) = U*/
  
  /*sid:572*/
  while (i != nbSymboles) {sectionDefinition = (*(symboles + i))->sectionDefinition;
    if (sectionDefinition != (void *)0)
    {(*(symboles + i))->valeur += sectionDefinition->adresse;
    if ((*(symboles + i))->portee == (PorteeSymboleEDL )2) {(*(symboles + i))->portee = 1U;}
    
    tmp = nomPointEntree();
    tmp_0 = strcmp((char const   *)((*(symboles + i))->nom)->chaine,
                   (char const   *)tmp);
    if (tmp_0 == 0) {objet->pointEntree = (*(symboles + i))->valeur;}
    }
    else {switch ((int )(*(symboles + i))->natureDefinition) {case 0: ;
          /*sid:591*/
          printf((char const   *)"%s%s%s%s%s%s%s%s\n", "erreur : ",
                 "le symbole global ", ((*(symboles + i))->nom)->chaine,
                 " (section ", (section->nom)->chaine, ", objet ", objet->nom,
                 ") est indefini");
          /*sid:591*/
          /*T(journal) = U*/
          /*T(premiereFois) = U*/
          /*T(sectionBss) = U*/
          /*T(adresseText) = U*/
          /*T(adresseData) = U*/
          /*T(adresseRodata) = U*/
          /*T(adresseBss) = U*/
          /*T(adresseStack) = U*/
          /*T(nomPtEntree) = U*/
          /*T(boutismeHote) = U*/
          /*T(iterateurGlobal) = U*/
          /*T(objets) = U*/
          /*T(copieSuperficielle) = U*/
          /*T(objets_0) = U*/
          /*T(nbFichiersDonnees) = U*/
          
          nbIndefinis ++;
          break;
          case 65521: 
          break;
          case 65522: ;
          /*sid:596*/
          printf((char const   *)"%s%s%s%s%s%s%s%s\n",
                 "panique (implanterTableSymboles) ! : ",
                 "le symbole de programme ", ((*(symboles + i))->nom)->chaine,
                 " est un symbole commun (", (section->objetParent)->nom, ":",
                 (section->nom)->chaine, ")");
          /*sid:596*/
          /*T(journal) = U*/
          /*T(premiereFois) = U*/
          /*T(sectionBss) = U*/
          /*T(adresseText) = U*/
          /*T(adresseData) = U*/
          /*T(adresseRodata) = U*/
          /*T(adresseBss) = U*/
          /*T(adresseStack) = U*/
          /*T(nomPtEntree) = U*/
          /*T(boutismeHote) = U*/
          /*T(iterateurGlobal) = U*/
          /*T(objets) = U*/
          /*T(copieSuperficielle) = U*/
          /*T(objets_0) = U*/
          /*T(nbFichiersDonnees) = U*/
          
          exit(1);
          /*sid:598*/
          break;
          /*sid:598*/
          /*T(journal) = G(journal)*/
          /*T(premiereFois) = G(premiereFois)*/
          /*T(sectionBss) = G(sectionBss)*/
          /*T(implanterTableSymboles) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
          /*T(adresseText) = G(adresseText)*/
          /*T(adresseData) = G(adresseData)*/
          /*T(adresseRodata) = G(adresseRodata)*/
          /*T(adresseBss) = G(adresseBss)*/
          /*T(adresseStack) = G(adresseStack)*/
          /*T(nomPtEntree) = G(nomPtEntree)*/
          /*T(boutismeHote) = G(boutismeHote)*/
          /*T(iterateurGlobal) = G(iterateurGlobal)*/
          /*T(objets) = G(objets)*/
          /*T(copieSuperficielle) = G(copieSuperficielle)*/
          /*T(objets_0) = G(objets_0)*/
          /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
          /*T(section) = G(section)*/
          /*T(objet) = U*/
          /*T(tableSymboles) = U*/
          /*T(symboles) = U*/
          /*T(nbSymboles) = U*/
          /*T(sectionDefinition) = U*/
          /*T(nbIndefinis) = U*/
          /*T(i) = U*/
          /*T(tmp) = U*/
          /*T(tmp_0) = U*/
          
          default: ;
          break;}
    }
    
    /*sid:601*/
    i ++;
    /*sid:601*/
    /*T(journal) = G(journal)*/
    /*T(premiereFois) = G(premiereFois)*/
    /*T(sectionBss) = G(sectionBss)*/
    /*T(adresseText) = G(adresseText)*/
    /*T(adresseData) = G(adresseData)*/
    /*T(adresseRodata) = G(adresseRodata)*/
    /*T(adresseBss) = G(adresseBss)*/
    /*T(adresseStack) = G(adresseStack)*/
    /*T(nomPtEntree) = G(nomPtEntree)*/
    /*T(boutismeHote) = G(boutismeHote)*/
    /*T(iterateurGlobal) = G(iterateurGlobal)*/
    /*T(objets) = G(objets)*/
    /*T(copieSuperficielle) = G(copieSuperficielle)*/
    /*T(objets_0) = G(objets_0)*/
    /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
    /*T(objet) = G(nomPtEntree) + G(section)*/
    /*T(tableSymboles) = G(section)*/
    /*T(symboles) = G(section)*/
    /*T(nbSymboles) = G(section)*/
    /*T(sectionDefinition) = G(section)*/
    /*T(nbIndefinis) = G(section)*/
    /*T(i) = G(section)*/
    /*T(tmp) = G(nomPtEntree) + G(section)*/
    /*T(tmp_0) = G(nomPtEntree) + G(section)*/
    }
  
  /*sid:572*/
  /*T(objet) = G(nomPtEntree) + G(section)*/
  /*T(nbIndefinis) = G(section)*/
  /*T(i) = G(section)*/
  /*T(tmp) = G(nomPtEntree) + G(section)*/
  /*T(tmp_0) = G(nomPtEntree) + G(section)*/
  
  if (nbIndefinis != 0U) {exit(1);}
  
  /*sid:3456*/
  return;
  /*sid:3456*/
  /*T(implanterTableSymboles) = G(section)*/
  }

}
unsigned int indexSymbole(struct StructSectionEDL *section ,
                          SymboleEDL *symbole ) 
{ SymboleEDL **symboles ;
  unsigned int nbSymboles ;
  unsigned int i ;
  unsigned int __retres ;
  
  {/*sid:608*/
  if (symbole->portee == (PorteeSymboleEDL )0)
  {/*sid:609*/
  symboles = (section->tableSymboles)->symbolesLocaux;
  /*sid:609*/
  /*T(symboles) = G(section) + G(symbole)*/
  
  /*sid:610*/
  nbSymboles = (section->tableSymboles)->nbLocaux;
  /*sid:610*/
  /*T(nbSymboles) = G(section) + G(symbole)*/
  }
  else {/*sid:611*/
  symboles = (section->tableSymboles)->symbolesGlobaux;
  /*sid:611*/
  /*T(symboles) = G(section) + G(symbole)*/
  
  /*sid:612*/
  nbSymboles = (section->tableSymboles)->nbGlobaux;
  /*sid:612*/
  /*T(nbSymboles) = G(section) + G(symbole)*/
  }
  
  /*sid:608*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = U*/
  /*T(indexSymbole) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(symbole) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(symbole) = G(symbole)*/
  /*T(symboles) = U*/
  /*T(nbSymboles) = U*/
  /*T(i) = U*/
  
  i = 0U;
  /*sid:614*/
  while (i != nbSymboles) {if (*(symboles + i) == symbole) {break;}
    
    i ++;}
  
  /*sid:614*/
  /*T(i) = G(section) + G(symbole)*/
  
  if (i != nbSymboles)
  {if (symbole->portee == (PorteeSymboleEDL )0)
   {/*sid:627*/
   __retres = i;
   /*sid:627*/
   /*T(__retres) = G(section) + G(symbole)*/
   
   goto return_label;}
   else {/*sid:628*/
   __retres = (section->tableSymboles)->nbLocaux + i;
   /*sid:628*/
   /*T(__retres) = G(section) + G(symbole)*/
   
   goto return_label;}
  }
  else {/*sid:629*/
  printf((char const   *)"%s%s%s%s%s%s%s\n", "panique (indexSymbole) ! : ",
         "le symbole ", (symbole->nom)->chaine,
         " n\'existe dans pas dans la table de symboles ",
         (section->nom)->chaine, " de l\'objet ", (section->objetParent)->nom);
  /*sid:629*/
  /*T(journal) = U*/
  /*T(premiereFois) = U*/
  /*T(sectionBss) = U*/
  /*T(adresseText) = U*/
  /*T(adresseData) = U*/
  /*T(adresseRodata) = U*/
  /*T(adresseBss) = U*/
  /*T(adresseStack) = U*/
  /*T(nomPtEntree) = U*/
  /*T(boutismeHote) = U*/
  /*T(iterateurGlobal) = U*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = U*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = U*/
  
  exit(1);}
  
  /*sid:3459*/
  return_label: /* CIL Label */ 
  return (__retres);
  /*sid:3459*/
  /*T(indexSymbole) = G(section) + G(symbole)*/
  }

}
SymboleEDL *symboleSelonIndex(struct StructSectionEDL *section ,
                              unsigned int index_0 ) 
{ TableSymbolesEDL *tableSymboles ;
  SymboleEDL **symbolesLocaux ;
  SymboleEDL **symbolesGlobaux ;
  unsigned int nbLocaux ;
  unsigned int nbGlobaux ;
  unsigned int nbSymboles ;
  SymboleEDL *__retres ;
  
  {/*sid:631*/
  tableSymboles = section->tableSymboles;
  /*sid:631*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = U*/
  /*T(symboleSelonIndex) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(index_0) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(index_0) = G(index_0)*/
  /*T(tableSymboles) = G(section)*/
  /*T(symbolesLocaux) = U*/
  /*T(symbolesGlobaux) = U*/
  /*T(nbLocaux) = U*/
  /*T(nbGlobaux) = U*/
  /*T(nbSymboles) = U*/
  
  /*sid:632*/
  symbolesLocaux = tableSymboles->symbolesLocaux;
  /*sid:632*/
  /*T(symbolesLocaux) = G(section)*/
  
  /*sid:633*/
  symbolesGlobaux = tableSymboles->symbolesGlobaux;
  /*sid:633*/
  /*T(symbolesGlobaux) = G(section)*/
  
  /*sid:634*/
  nbLocaux = tableSymboles->nbLocaux;
  /*sid:634*/
  /*T(nbLocaux) = G(section)*/
  
  /*sid:635*/
  nbGlobaux = tableSymboles->nbGlobaux;
  /*sid:635*/
  /*T(nbGlobaux) = G(section)*/
  
  /*sid:636*/
  nbSymboles = nbLocaux + nbGlobaux;
  /*sid:636*/
  /*T(nbSymboles) = G(section)*/
  
  if (index_0 < nbLocaux)
  {/*sid:639*/
  __retres = *(symbolesLocaux + index_0);
  /*sid:639*/
  /*T(__retres) = G(index_0) + G(section)*/
  
  goto return_label;}
  else {if (index_0 < nbSymboles)
        {/*sid:642*/
        __retres = *((symbolesGlobaux + index_0) - nbLocaux);
        /*sid:642*/
        /*T(__retres) = G(index_0) + G(section)*/
        
        goto return_label;}
        else {/*sid:643*/
        printf((char const   *)"%s%s%d%s%s%s%s\n",
               "panique (symboleSelonIndex) ! : ", "aucun symbole d\'index ",
               index_0, " n\'existe dans la table de symboles ",
               (section->nom)->chaine, " de l\'objet ",
               (section->objetParent)->nom);
        /*sid:643*/
        /*T(journal) = U*/
        /*T(premiereFois) = U*/
        /*T(sectionBss) = U*/
        /*T(adresseText) = U*/
        /*T(adresseData) = U*/
        /*T(adresseRodata) = U*/
        /*T(adresseBss) = U*/
        /*T(adresseStack) = U*/
        /*T(nomPtEntree) = U*/
        /*T(boutismeHote) = U*/
        /*T(iterateurGlobal) = U*/
        /*T(objets) = U*/
        /*T(copieSuperficielle) = U*/
        /*T(objets_0) = U*/
        /*T(nbFichiersDonnees) = U*/
        
        exit(1);}
  }
  
  /*sid:3462*/
  return_label: /* CIL Label */ 
  return (__retres);
  /*sid:3462*/
  /*T(symboleSelonIndex) = G(index_0) + G(section)*/
  }

}
void supprimerSymboleSelonNom(struct StructSectionEDL *section ,
                              struct StructChaineEDL *nomSymbole ) 
{ SymboleEDL *symbole ;
  
  {/*sid:645*/
  symbole = symboleSectionSelonNom(section, nomSymbole);
  /*sid:645*/
  /*T(section) = G(section)*/
  /*T(nomSymbole) = G(nomSymbole)*/
  /*T(symbole) = G(section)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(supprimerSymboleSelonNom) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(nomSymbole) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  if (symbole != (void *)0) {supprimerSymbole(section, symbole);}
  else {/*sid:649*/
  symbole = symboleGlobalSelonNom(section, nomSymbole);
  /*sid:649*/
  /*T(symbole) = G(nomSymbole) + G(section)*/
  
  if (symbole != (void *)0) {/*sid:652*/
    supprimerSymbole(section, symbole);
    /*sid:652*/
    /*T(section) = G(nomSymbole) + G(section)*/
    }
  }
  
  /*sid:3463*/
  return;
  /*sid:3463*/
  /*T(section) = G(nomSymbole) + G(section)*/
  /*T(symbole) = G(nomSymbole) + G(section)*/
  /*T(supprimerSymboleSelonNom) = G(section)*/
  }

}
void supprimerSymbolesSectionInutiles(struct StructSectionEDL *section ) 
{ SymboleEDL **symbolesLocaux ;
  unsigned int nbLocaux ;
  TypeSectionEDL typeSection ;
  unsigned int i ;
  
  {/*sid:655*/
  symbolesLocaux = (section->tableSymboles)->symbolesLocaux;
  /*sid:655*/
  /*T(section) = G(section)*/
  /*T(symbolesLocaux) = G(section)*/
  /*T(nbLocaux) = U*/
  /*T(typeSection) = U*/
  /*T(i) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(supprimerSymbolesSectionInutiles) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  /*sid:656*/
  nbLocaux = (section->tableSymboles)->nbLocaux;
  /*sid:656*/
  /*T(nbLocaux) = G(section)*/
  
  i = 1U;
  /*sid:658*/
  while (i != nbLocaux) {if ((*(symbolesLocaux + i))->type == (TypeSymboleEDL )3) {
                           typeSection = ((*(symbolesLocaux + i))->sectionDefinition)->type;
                           if (typeSection != (TypeSectionEDL )1) {if
                              (typeSection != (TypeSectionEDL )8) {supprimerSymbole(
                                                                   section,
                                                                   *(
                                                                   symbolesLocaux + i));}
                             }
                           }
    
    i ++;}
  
  /*sid:658*/
  /*T(typeSection) = G(section)*/
  /*T(i) = G(section)*/
  
  /*sid:3464*/
  return;
  /*sid:3464*/
  /*T(supprimerSymbolesSectionInutiles) = U*/
  }

}
unsigned int tailleTableSymboles(struct StructSectionEDL *section ) 
{ TableSymbolesEDL *tableSymboles ;
  SymboleEDL **symbolesLocaux ;
  SymboleEDL **symbolesGlobaux ;
  unsigned int nbLocaux ;
  unsigned int nbGlobaux ;
  unsigned int tmp ;
  
  {/*sid:675*/
  tableSymboles = section->tableSymboles;
  /*sid:675*/
  /*T(section) = G(section)*/
  /*T(tableSymboles) = G(section)*/
  /*T(symbolesLocaux) = U*/
  /*T(symbolesGlobaux) = U*/
  /*T(nbLocaux) = U*/
  /*T(nbGlobaux) = U*/
  /*T(tmp) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(tailleTableSymboles) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  /*sid:676*/
  symbolesLocaux = tableSymboles->symbolesLocaux;
  /*sid:676*/
  /*T(symbolesLocaux) = G(section)*/
  
  /*sid:677*/
  symbolesGlobaux = tableSymboles->symbolesGlobaux;
  /*sid:677*/
  /*T(symbolesGlobaux) = G(section)*/
  
  /*sid:678*/
  nbLocaux = tableSymboles->nbLocaux;
  /*sid:678*/
  /*T(nbLocaux) = G(section)*/
  
  /*sid:679*/
  nbGlobaux = tableSymboles->nbGlobaux;
  /*sid:679*/
  /*T(nbGlobaux) = G(section)*/
  
  if (nbLocaux > nbGlobaux)
  {/*sid:682*/
  tmp = nbLocaux;
  /*sid:682*/
  /*T(tmp) = G(section)*/
  }
  else {/*sid:683*/
  tmp = nbGlobaux;
  /*sid:683*/
  /*T(tmp) = G(section)*/
  }
  
  /*sid:684*/
  return (tmp);
  /*sid:684*/
  /*T(tailleTableSymboles) = G(section)*/
  }

}
void afficherSymboles(struct StructSectionEDL *section ) 
{ SymboleEDL **symbolesLocaux ;
  SymboleEDL **symbolesGlobaux ;
  unsigned int nbLocaux ;
  unsigned int nbGlobaux ;
  unsigned int i ;
  
  {/*sid:685*/
  printf((char const   *)"%s:%s\n", (section->objetParent)->nom,
         (section->nom)->chaine);
  /*sid:685*/
  /*T(section) = G(section)*/
  /*T(symbolesLocaux) = U*/
  /*T(symbolesGlobaux) = U*/
  /*T(nbLocaux) = U*/
  /*T(nbGlobaux) = U*/
  /*T(i) = U*/
  /*T(journal) = G(section)*/
  /*T(premiereFois) = G(section)*/
  /*T(afficherSymboles) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(sectionBss) = G(section)*/
  /*T(adresseText) = G(section)*/
  /*T(adresseData) = G(section)*/
  /*T(adresseRodata) = G(section)*/
  /*T(adresseBss) = G(section)*/
  /*T(adresseStack) = G(section)*/
  /*T(nomPtEntree) = G(section)*/
  /*T(boutismeHote) = G(section)*/
  /*T(iterateurGlobal) = G(section)*/
  /*T(objets) = G(section)*/
  /*T(copieSuperficielle) = G(section)*/
  /*T(objets_0) = G(section)*/
  /*T(nbFichiersDonnees) = G(section)*/
  
  /*sid:686*/
  afficherTitreSymboles();
  /*sid:686*/
  /*T(journal) = U*/
  /*T(premiereFois) = U*/
  /*T(sectionBss) = U*/
  /*T(adresseText) = U*/
  /*T(adresseData) = U*/
  /*T(adresseRodata) = U*/
  /*T(adresseBss) = U*/
  /*T(adresseStack) = U*/
  /*T(nomPtEntree) = U*/
  /*T(boutismeHote) = U*/
  /*T(iterateurGlobal) = U*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = U*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = U*/
  
  /*sid:687*/
  symbolesLocaux = (section->tableSymboles)->symbolesLocaux;
  /*sid:687*/
  /*T(symbolesLocaux) = G(section)*/
  
  /*sid:688*/
  nbLocaux = (section->tableSymboles)->nbLocaux;
  /*sid:688*/
  /*T(nbLocaux) = G(section)*/
  
  i = 0U;
  /*sid:690*/
  while (i != nbLocaux) {afficherSymbole(*(*(symbolesLocaux + i)), i);
    i ++;}
  
  /*sid:690*/
  /*T(i) = G(section)*/
  /*T(journal) = G(section)*/
  /*T(premiereFois) = G(section)*/
  /*T(sectionBss) = G(section)*/
  /*T(adresseText) = G(section)*/
  /*T(adresseData) = G(section)*/
  /*T(adresseRodata) = G(section)*/
  /*T(adresseBss) = G(section)*/
  /*T(adresseStack) = G(section)*/
  /*T(nomPtEntree) = G(section)*/
  /*T(boutismeHote) = G(section)*/
  /*T(iterateurGlobal) = G(section)*/
  /*T(objets) = G(section)*/
  /*T(copieSuperficielle) = G(section)*/
  /*T(objets_0) = G(section)*/
  /*T(nbFichiersDonnees) = G(section)*/
  
  /*sid:696*/
  symbolesGlobaux = (section->tableSymboles)->symbolesGlobaux;
  /*sid:696*/
  /*T(symbolesGlobaux) = G(section)*/
  
  /*sid:697*/
  nbGlobaux = (section->tableSymboles)->nbGlobaux;
  /*sid:697*/
  /*T(nbGlobaux) = G(section)*/
  
  /*sid:698*/
  i = 0U;
  /*sid:698*/
  /*T(i) = U*/
  
  /*sid:699*/
  while (i != nbGlobaux) {afficherSymbole(*(*(symbolesGlobaux + i)),
                                          nbLocaux + i);
    i ++;}
  
  /*sid:699*/
  /*T(i) = G(section)*/
  
  printf((char const   *)"\n");
  /*sid:3465*/
  return;
  /*sid:3465*/
  /*T(afficherSymboles) = U*/
  }

}
static void fusionnerSymboleLocal(SymboleEDL *symboleSource ,
                                  struct StructSectionEDL *sectionSource ,
                                  struct StructSectionEDL *sectionCible ) 
{ SymboleEDL *symboleCible ;
  SectionEDL *sectionDefinitionSource ;
  SectionProgrammeEDL *sectionProgrammeSource ;
  
  {/*sid:707*/
  symboleCible = symboleSectionSelonNom(sectionCible, symboleSource->nom);
  /*sid:707*/
  /*T(symboleSource) = G(symboleSource)*/
  /*T(sectionSource) = G(sectionSource)*/
  /*T(sectionCible) = G(sectionCible)*/
  /*T(symboleCible) = G(sectionCible)*/
  /*T(sectionDefinitionSource) = U*/
  /*T(sectionProgrammeSource) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(fusionnerSymboleLocal) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(sectionCible) + G(symboleSource) + G(sectionSource) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  if (symboleSource->type != (TypeSymboleEDL )3) {goto _L;}
  else {if (symboleCible == (void *)0)
        {/*sid:713*/
        _L: /* CIL Label */ 
        ajouterSymbole(sectionCible, symboleSource, & symboleCible);
        /*sid:713*/
        /*T(symboleCible) = G(symboleSource) + G(sectionCible)*/
        
        /*sid:714*/
        sectionDefinitionSource = symboleSource->sectionDefinition;
        /*sid:714*/
        /*T(sectionDefinitionSource) = G(symboleSource)*/
        
        if (sectionDefinitionSource != (void *)0) {if (symboleSource->type != (TypeSymboleEDL )3) {/*sid:719*/
                                                     sectionProgrammeSource = sectionDefinitionSource->sectionProgramme;
                                                     /*sid:719*/
                                                     /*T(sectionProgrammeSource) = G(symboleSource)*/
                                                     
                                                     if (sectionProgrammeSource != (void *)0)
                                                     {symboleCible->valeur += (unsigned long )sectionProgrammeSource->decalageContenu;}
                                                     else {/*sid:723*/
                                                     printf((char const   *)"%s%s%s%s%s%s%s%s\n",
                                                            "panique (fusionnerSymboleLocal) ! : ",
                                                            "le symbole de programme ",
                                                            (symboleSource->nom)->chaine,
                                                            " est defini dans une section mal formee (",
                                                            (sectionSource->objetParent)->nom,
                                                            ":",
                                                            (sectionSource->nom)->chaine,
                                                            ")");
                                                     /*sid:723*/
                                                     /*T(journal) = U*/
                                                     /*T(premiereFois) = U*/
                                                     /*T(sectionBss) = U*/
                                                     /*T(adresseText) = U*/
                                                     /*T(adresseData) = U*/
                                                     /*T(adresseRodata) = U*/
                                                     /*T(adresseBss) = U*/
                                                     /*T(adresseStack) = U*/
                                                     /*T(nomPtEntree) = U*/
                                                     /*T(boutismeHote) = U*/
                                                     /*T(iterateurGlobal) = U*/
                                                     /*T(objets) = U*/
                                                     /*T(copieSuperficielle) = U*/
                                                     /*T(objets_0) = U*/
                                                     /*T(nbFichiersDonnees) = U*/
                                                     
                                                     exit(1);}
                                                     }
          }
        }
        else {/*sid:727*/
        symboleSource->symboleImage = symboleCible;
        /*sid:727*/
        /*T(symboleSource) = G(sectionCible) + G(symboleSource)*/
        /*T(symboleCible) = G(symboleSource) + G(sectionCible)*/
        /*T(sectionDefinitionSource) = G(symboleSource)*/
        /*T(sectionProgrammeSource) = G(symboleSource)*/
        }
  }
  
  /*sid:3466*/
  return;
  /*sid:3466*/
  /*T(symboleSource) = G(sectionCible) + G(symboleSource)*/
  /*T(sectionProgrammeSource) = G(symboleSource)*/
  /*T(fusionnerSymboleLocal) = G(symboleSource)*/
  }

}
static void fusionnerSymboleGlobal(SymboleEDL *symboleSource ,
                                   struct StructSectionEDL *sectionSource ,
                                   struct StructSectionEDL *sectionCible ,
                                   unsigned int *erreur ) 
{ SymboleEDL *symboleCible ;
  SectionEDL *sectionDefinitionSource ;
  SectionProgrammeEDL *sectionProgrammeSource ;
  SymboleEDL *symboleDefini ;
  SymboleEDL *symboleCommun ;
  SectionEDL *sectionDefini ;
  SectionEDL *sectionCommun ;
  enum __anonenum_natureSource_58 natureSource ;
  enum __anonenum_natureSource_58 natureCible ;
  unsigned int creationNouveauSymbole ;
  unsigned int remplacementTailleEtType ;
  unsigned int miseAJourSectionDefinitionEtValeur ;
  unsigned int miseAJourNatureDefinitionEtValeur ;
  unsigned int verificationAlignementEtTaille ;
  unsigned int retentionMaxAlignementEtTaille ;
  unsigned int erreurDoubleDefinition ;
  
  {/*sid:729*/
  {erreurDoubleDefinition = 0U;
   retentionMaxAlignementEtTaille = erreurDoubleDefinition;
   verificationAlignementEtTaille = retentionMaxAlignementEtTaille;
   miseAJourNatureDefinitionEtValeur = verificationAlignementEtTaille;
   miseAJourSectionDefinitionEtValeur = miseAJourNatureDefinitionEtValeur;
   remplacementTailleEtType = miseAJourSectionDefinitionEtValeur;
   creationNouveauSymbole = remplacementTailleEtType;}
  /*sid:729*/
  /*T(symboleSource) = G(symboleSource)*/
  /*T(sectionSource) = G(sectionSource)*/
  /*T(sectionCible) = G(sectionCible)*/
  /*T(erreur) = G(erreur)*/
  /*T(symboleCible) = U*/
  /*T(sectionDefinitionSource) = U*/
  /*T(sectionProgrammeSource) = U*/
  /*T(symboleDefini) = U*/
  /*T(symboleCommun) = U*/
  /*T(sectionDefini) = U*/
  /*T(sectionCommun) = U*/
  /*T(natureSource) = U*/
  /*T(natureCible) = U*/
  /*T(creationNouveauSymbole) = U*/
  /*T(remplacementTailleEtType) = U*/
  /*T(miseAJourSectionDefinitionEtValeur) = U*/
  /*T(miseAJourNatureDefinitionEtValeur) = U*/
  /*T(verificationAlignementEtTaille) = U*/
  /*T(retentionMaxAlignementEtTaille) = U*/
  /*T(erreurDoubleDefinition) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(fusionnerSymboleGlobal) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(erreur) + G(sectionSource) + G(symboleSource) + G(sectionCible) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:737*/
  symboleCible = symboleGlobalSelonNom(sectionCible, symboleSource->nom);
  /*sid:737*/
  /*T(symboleCible) = G(symboleSource) + G(sectionCible)*/
  
  if (symboleCible == (void *)0)
  {/*sid:740*/
  creationNouveauSymbole = 1U;
  /*sid:740*/
  /*T(creationNouveauSymbole) = G(symboleSource) + G(sectionCible)*/
  
  if (symboleSource->sectionDefinition != (void *)0) {/*sid:743*/
    miseAJourSectionDefinitionEtValeur = 1U;
    /*sid:743*/
    /*T(miseAJourSectionDefinitionEtValeur) = G(symboleSource) + G(sectionCible)*/
    }
  }
  else {/*sid:745*/
  symboleSource->symboleImage = symboleCible;
  /*sid:745*/
  /*T(symboleSource) = G(sectionCible) + G(symboleSource)*/
  
  if (symboleCible->sectionDefinition != (void *)0)
  {if (symboleCible->portee == (PorteeSymboleEDL )1)
   {/*sid:750*/
   natureCible = GLOBAL;
   /*sid:750*/
   /*T(natureCible) = G(symboleSource) + G(sectionCible)*/
   }
   else {/*sid:751*/
   natureCible = FAIBLE;
   /*sid:751*/
   /*T(natureCible) = G(symboleSource) + G(sectionCible)*/
   }
  }
  else {switch ((int )symboleCible->natureDefinition) {/*sid:753*/
        case 65521: 
        natureCible = ABSOLU;
        /*sid:753*/
        /*T(natureCible) = G(symboleSource) + G(sectionCible)*/
        
        break;
        /*sid:755*/
        case 65522: 
        natureCible = COMMUN;
        /*sid:755*/
        /*T(natureCible) = G(symboleSource) + G(sectionCible)*/
        
        break;
        /*sid:757*/
        case 0: 
        natureCible = INDEFINI;
        /*sid:757*/
        /*T(natureCible) = G(symboleSource) + G(sectionCible)*/
        
        break;
        default: ;
        /*sid:760*/
        natureCible = INCONNU;
        /*sid:760*/
        /*T(natureCible) = G(symboleSource) + G(sectionCible)*/
        
        break;}
  }
  
  if (symboleSource->sectionDefinition != (void *)0)
  {if (symboleSource->portee == (PorteeSymboleEDL )1)
   {/*sid:766*/
   natureSource = GLOBAL;
   /*sid:766*/
   /*T(natureSource) = G(symboleSource) + G(sectionCible)*/
   }
   else {/*sid:767*/
   natureSource = FAIBLE;
   /*sid:767*/
   /*T(natureSource) = G(symboleSource) + G(sectionCible)*/
   }
  }
  else {switch ((int )symboleSource->natureDefinition) {/*sid:769*/
        case 65521: 
        natureSource = ABSOLU;
        /*sid:769*/
        /*T(natureSource) = G(symboleSource) + G(sectionCible)*/
        
        break;
        /*sid:771*/
        case 65522: 
        natureSource = COMMUN;
        /*sid:771*/
        /*T(natureSource) = G(symboleSource) + G(sectionCible)*/
        
        break;
        /*sid:773*/
        case 0: 
        natureSource = INDEFINI;
        /*sid:773*/
        /*T(natureSource) = G(symboleSource) + G(sectionCible)*/
        
        break;
        default: ;
        /*sid:776*/
        natureSource = INCONNU;
        /*sid:776*/
        /*T(natureSource) = G(symboleSource) + G(sectionCible)*/
        
        break;}
  }
  
  if ((int )natureCible == (int )GLOBAL)
  {if ((int )natureSource == (int )COMMUN)
   {/*sid:782*/
   verificationAlignementEtTaille = 1U;
   /*sid:782*/
   /*T(verificationAlignementEtTaille) = G(symboleSource) + G(sectionCible)*/
   }
   else {goto _L_13;}
  }
  else {_L_13: /* CIL Label */ ;
  if ((int )natureCible == (int )ABSOLU)
  {if ((int )natureSource == (int )COMMUN)
   {/*sid:788*/
   verificationAlignementEtTaille = 1U;
   /*sid:788*/
   /*T(verificationAlignementEtTaille) = G(symboleSource) + G(sectionCible)*/
   }
   else {goto _L_12;}
  }
  else {_L_12: /* CIL Label */ ;
  if ((int )natureCible == (int )COMMUN)
  {if ((int )natureSource == (int )COMMUN)
   {/*sid:794*/
   retentionMaxAlignementEtTaille = 1U;
   /*sid:794*/
   /*T(retentionMaxAlignementEtTaille) = G(symboleSource) + G(sectionCible)*/
   }
   else {goto _L_11;}
  }
  else {_L_11: /* CIL Label */ ;
  if ((int )natureCible == (int )FAIBLE)
  {if ((int )natureSource == (int )ABSOLU)
   {/*sid:800*/
   remplacementTailleEtType = 1U;
   /*sid:800*/
   /*T(remplacementTailleEtType) = G(symboleSource) + G(sectionCible)*/
   
   /*sid:801*/
   miseAJourNatureDefinitionEtValeur = 1U;
   /*sid:801*/
   /*T(miseAJourNatureDefinitionEtValeur) = G(symboleSource) + G(sectionCible)*/
   }
   else {goto _L_10;}
  }
  else {_L_10: /* CIL Label */ ;
  if ((int )natureCible == (int )FAIBLE)
  {if ((int )natureSource == (int )COMMUN)
   {/*sid:807*/
   remplacementTailleEtType = 1U;
   /*sid:807*/
   /*T(remplacementTailleEtType) = G(symboleSource) + G(sectionCible)*/
   
   /*sid:808*/
   miseAJourNatureDefinitionEtValeur = 1U;
   /*sid:808*/
   /*T(miseAJourNatureDefinitionEtValeur) = G(symboleSource) + G(sectionCible)*/
   }
   else {goto _L_9;}
  }
  else {_L_9: /* CIL Label */ ;
  if ((int )natureCible == (int )INDEFINI)
  {if ((int )natureSource == (int )ABSOLU)
   {/*sid:814*/
   remplacementTailleEtType = 1U;
   /*sid:814*/
   /*T(remplacementTailleEtType) = G(symboleSource) + G(sectionCible)*/
   
   /*sid:815*/
   miseAJourNatureDefinitionEtValeur = 1U;
   /*sid:815*/
   /*T(miseAJourNatureDefinitionEtValeur) = G(symboleSource) + G(sectionCible)*/
   }
   else {goto _L_8;}
  }
  else {_L_8: /* CIL Label */ ;
  if ((int )natureCible == (int )INDEFINI)
  {if ((int )natureSource == (int )COMMUN)
   {/*sid:821*/
   remplacementTailleEtType = 1U;
   /*sid:821*/
   /*T(remplacementTailleEtType) = G(symboleSource) + G(sectionCible)*/
   
   /*sid:822*/
   miseAJourNatureDefinitionEtValeur = 1U;
   /*sid:822*/
   /*T(miseAJourNatureDefinitionEtValeur) = G(symboleSource) + G(sectionCible)*/
   }
   else {goto _L_7;}
  }
  else {_L_7: /* CIL Label */ ;
  if ((int )natureCible == (int )FAIBLE)
  {if ((int )natureSource == (int )GLOBAL)
   {/*sid:828*/
   remplacementTailleEtType = 1U;
   /*sid:828*/
   /*T(remplacementTailleEtType) = G(symboleSource) + G(sectionCible)*/
   
   /*sid:829*/
   miseAJourSectionDefinitionEtValeur = 1U;
   /*sid:829*/
   /*T(miseAJourSectionDefinitionEtValeur) = G(symboleSource) + G(sectionCible)*/
   }
   else {goto _L_6;}
  }
  else {_L_6: /* CIL Label */ ;
  if ((int )natureCible == (int )INDEFINI)
  {if ((int )natureSource == (int )GLOBAL)
   {/*sid:835*/
   remplacementTailleEtType = 1U;
   /*sid:835*/
   /*T(remplacementTailleEtType) = G(symboleSource) + G(sectionCible)*/
   
   /*sid:836*/
   miseAJourSectionDefinitionEtValeur = 1U;
   /*sid:836*/
   /*T(miseAJourSectionDefinitionEtValeur) = G(symboleSource) + G(sectionCible)*/
   }
   else {goto _L_5;}
  }
  else {_L_5: /* CIL Label */ ;
  if ((int )natureCible == (int )INDEFINI)
  {if ((int )natureSource == (int )FAIBLE)
   {/*sid:842*/
   remplacementTailleEtType = 1U;
   /*sid:842*/
   /*T(remplacementTailleEtType) = G(symboleSource) + G(sectionCible)*/
   
   /*sid:843*/
   miseAJourSectionDefinitionEtValeur = 1U;
   /*sid:843*/
   /*T(miseAJourSectionDefinitionEtValeur) = G(symboleSource) + G(sectionCible)*/
   }
   else {goto _L_4;}
  }
  else {_L_4: /* CIL Label */ ;
  if ((int )natureCible == (int )COMMUN)
  {if ((int )natureSource == (int )ABSOLU)
   {/*sid:849*/
   verificationAlignementEtTaille = 1U;
   /*sid:849*/
   /*T(verificationAlignementEtTaille) = G(symboleSource) + G(sectionCible)*/
   
   /*sid:850*/
   remplacementTailleEtType = 1U;
   /*sid:850*/
   /*T(remplacementTailleEtType) = G(symboleSource) + G(sectionCible)*/
   
   /*sid:851*/
   miseAJourNatureDefinitionEtValeur = 1U;
   /*sid:851*/
   /*T(miseAJourNatureDefinitionEtValeur) = G(symboleSource) + G(sectionCible)*/
   }
   else {goto _L_3;}
  }
  else {_L_3: /* CIL Label */ ;
  if ((int )natureCible == (int )COMMUN)
  {if ((int )natureSource == (int )GLOBAL)
   {/*sid:857*/
   verificationAlignementEtTaille = 1U;
   /*sid:857*/
   /*T(verificationAlignementEtTaille) = G(symboleSource) + G(sectionCible)*/
   
   /*sid:858*/
   remplacementTailleEtType = 1U;
   /*sid:858*/
   /*T(remplacementTailleEtType) = G(symboleSource) + G(sectionCible)*/
   
   /*sid:859*/
   miseAJourSectionDefinitionEtValeur = 1U;
   /*sid:859*/
   /*T(miseAJourSectionDefinitionEtValeur) = G(symboleSource) + G(sectionCible)*/
   }
   else {goto _L_2;}
  }
  else {_L_2: /* CIL Label */ ;
  if ((int )natureCible == (int )GLOBAL)
  {if ((int )natureSource == (int )GLOBAL)
   {/*sid:865*/
   erreurDoubleDefinition = 1U;
   /*sid:865*/
   /*T(erreurDoubleDefinition) = G(symboleSource) + G(sectionCible)*/
   }
   else {goto _L_1;}
  }
  else {_L_1: /* CIL Label */ ;
  if ((int )natureCible == (int )GLOBAL)
  {if ((int )natureSource == (int )ABSOLU)
   {/*sid:871*/
   erreurDoubleDefinition = 1U;
   /*sid:871*/
   /*T(erreurDoubleDefinition) = G(symboleSource) + G(sectionCible)*/
   }
   else {goto _L_0;}
  }
  else {_L_0: /* CIL Label */ ;
  if ((int )natureCible == (int )ABSOLU)
  {if ((int )natureSource == (int )GLOBAL)
   {/*sid:877*/
   erreurDoubleDefinition = 1U;
   /*sid:877*/
   /*T(erreurDoubleDefinition) = G(symboleSource) + G(sectionCible)*/
   }
   else {goto _L;}
  }
  else {_L: /* CIL Label */ ;
  if ((int )natureCible == (int )ABSOLU) {/*sid:882*/
    if ((int )natureSource == (int )ABSOLU) {erreurDoubleDefinition = 1U;}
    
    /*sid:882*/
    /*T(creationNouveauSymbole) = G(symboleSource) + G(sectionCible)*/
    /*T(remplacementTailleEtType) = G(symboleSource) + G(sectionCible)*/
    /*T(miseAJourSectionDefinitionEtValeur) = G(symboleSource) + G(sectionCible)*/
    /*T(miseAJourNatureDefinitionEtValeur) = G(symboleSource) + G(sectionCible)*/
    /*T(verificationAlignementEtTaille) = G(symboleSource) + G(sectionCible)*/
    /*T(retentionMaxAlignementEtTaille) = G(symboleSource) + G(sectionCible)*/
    /*T(erreurDoubleDefinition) = G(symboleSource) + G(sectionCible)*/
    }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  
  /*sid:885*/
  if (creationNouveauSymbole) {ajouterSymbole(sectionCible, symboleSource,
                                              & symboleCible);}
  
  /*sid:885*/
  /*T(symboleSource) = G(sectionCible) + G(symboleSource)*/
  /*T(natureSource) = G(symboleSource) + G(sectionCible)*/
  /*T(natureCible) = G(symboleSource) + G(sectionCible)*/
  /*T(creationNouveauSymbole) = G(symboleSource) + G(sectionCible)*/
  /*T(remplacementTailleEtType) = G(symboleSource) + G(sectionCible)*/
  /*T(miseAJourSectionDefinitionEtValeur) = G(symboleSource) + G(sectionCible)*/
  /*T(miseAJourNatureDefinitionEtValeur) = G(symboleSource) + G(sectionCible)*/
  /*T(verificationAlignementEtTaille) = G(symboleSource) + G(sectionCible)*/
  /*T(retentionMaxAlignementEtTaille) = G(symboleSource) + G(sectionCible)*/
  /*T(erreurDoubleDefinition) = G(symboleSource) + G(sectionCible)*/
  
  if (verificationAlignementEtTaille) {if ((int )natureCible == (int )COMMUN)
                                       {/*sid:892*/
                                       symboleCommun = symboleCible;
                                       /*sid:892*/
                                       /*T(symboleCommun) = G(symboleSource) + G(sectionCible)*/
                                       
                                       /*sid:893*/
                                       sectionCommun = symboleCommun->tableSymbolesOrigine;
                                       /*sid:893*/
                                       /*T(sectionCommun) = G(symboleSource) + G(sectionCible)*/
                                       
                                       /*sid:894*/
                                       symboleDefini = symboleSource;
                                       /*sid:894*/
                                       /*T(symboleDefini) = G(symboleSource) + G(sectionCible)*/
                                       
                                       /*sid:895*/
                                       sectionDefini = sectionSource;
                                       /*sid:895*/
                                       /*T(sectionDefini) = G(sectionSource) + G(symboleSource) + G(sectionCible)*/
                                       }
                                       else {/*sid:896*/
                                       symboleCommun = symboleSource;
                                       /*sid:896*/
                                       /*T(symboleCommun) = G(symboleSource) + G(sectionCible)*/
                                       
                                       /*sid:897*/
                                       sectionCommun = sectionSource;
                                       /*sid:897*/
                                       /*T(sectionCommun) = G(sectionSource) + G(symboleSource) + G(sectionCible)*/
                                       
                                       /*sid:898*/
                                       symboleDefini = symboleCible;
                                       /*sid:898*/
                                       /*T(symboleDefini) = G(symboleSource) + G(sectionCible)*/
                                       
                                       /*sid:899*/
                                       sectionDefini = symboleDefini->tableSymbolesOrigine;
                                       /*sid:899*/
                                       /*T(sectionDefini) = G(sectionSource) + G(symboleSource) + G(sectionCible)*/
                                       }
    
    /*sid:901*/
    if (symboleDefini->valeur % symboleCommun->valeur != 0UL) {printf(
                                                               (char const   *)"%s%s%ld%s%s%s%s%s%s%s%ld%s%s%s%s%s%s%s\n",
                                                               "avertissement : ",
                                                               "la valeur ",
                                                               symboleDefini->valeur,
                                                               " du symbole defini ",
                                                               (symboleDefini->nom)->chaine,
                                                               " (",
                                                               (sectionDefini->objetParent)->nom,
                                                               ":",
                                                               (sectionDefini->nom)->chaine,
                                                               ") est incompatible avec la contrainte d\'alignement ",
                                                               symboleCommun->valeur,
                                                               " du symbole commun ",
                                                               (symboleCommun->nom)->chaine,
                                                               " (",
                                                               (sectionCommun->objetParent)->nom,
                                                               ":",
                                                               (sectionCommun->nom)->chaine,
                                                               ")");}
    
    /*sid:901*/
    /*T(sectionCommun) = G(sectionSource) + G(symboleSource) + G(sectionCible)*/
    
    if (symboleCible->taille != symboleSource->taille) {printf((char const   *)"%s%s%s%s%d%s%s%s%s%s%d%s%s%s%s\n",
                                                               "avertissement : ",
                                                               "le symbole ",
                                                               (symboleDefini->nom)->chaine,
                                                               " a pour taille ",
                                                               symboleDefini->taille,
                                                               " dans ",
                                                               (sectionDefini->objetParent)->nom,
                                                               ":",
                                                               (sectionDefini->nom)->chaine,
                                                               " et pour taille ",
                                                               symboleCommun->taille,
                                                               " dans ",
                                                               (sectionCommun->objetParent)->nom,
                                                               ":",
                                                               (sectionCommun->nom)->chaine);}
    }
  
  /*sid:910*/
  if (remplacementTailleEtType) {symboleCible->taille = symboleSource->taille;
    symboleCible->type = symboleSource->type;}
  
  /*sid:910*/
  /*T(symboleDefini) = G(symboleSource) + G(sectionCible)*/
  /*T(symboleCommun) = G(symboleSource) + G(sectionCible)*/
  /*T(sectionDefini) = G(sectionSource) + G(symboleSource) + G(sectionCible)*/
  /*T(sectionCommun) = G(sectionSource) + G(symboleSource) + G(sectionCible)*/
  
  if (miseAJourSectionDefinitionEtValeur) {/*sid:916*/
    sectionDefinitionSource = symboleSource->sectionDefinition;
    /*sid:916*/
    /*T(sectionDefinitionSource) = G(symboleSource) + G(sectionCible)*/
    
    symboleCible->sectionDefinition = sectionDefinitionSource->sectionImage;
    /*sid:918*/
    sectionProgrammeSource = sectionDefinitionSource->sectionProgramme;
    /*sid:918*/
    /*T(sectionProgrammeSource) = G(symboleSource) + G(sectionCible)*/
    
    if (sectionProgrammeSource != (void *)0)
    {symboleCible->valeur = symboleSource->valeur + (unsigned long )sectionProgrammeSource->decalageContenu;}
    else {/*sid:922*/
    printf((char const   *)"%s%s%s%s%s%s%s%s\n",
           "panique (fusionnerSymboleGlobal) ! : ",
           "le symbole de programme ", (symboleSource->nom)->chaine,
           " est defini dans une section mal formee (",
           (sectionSource->objetParent)->nom, ":",
           (sectionSource->nom)->chaine, ")");
    /*sid:922*/
    /*T(journal) = U*/
    /*T(premiereFois) = U*/
    /*T(sectionBss) = U*/
    /*T(adresseText) = U*/
    /*T(adresseData) = U*/
    /*T(adresseRodata) = U*/
    /*T(adresseBss) = U*/
    /*T(adresseStack) = U*/
    /*T(nomPtEntree) = U*/
    /*T(boutismeHote) = U*/
    /*T(iterateurGlobal) = U*/
    /*T(objets) = U*/
    /*T(copieSuperficielle) = U*/
    /*T(objets_0) = U*/
    /*T(nbFichiersDonnees) = U*/
    
    exit(1);}
    }
  
  /*sid:926*/
  if (miseAJourNatureDefinitionEtValeur) {symboleCible->natureDefinition = symboleSource->natureDefinition;
    symboleCible->valeur = symboleSource->valeur;}
  
  /*sid:926*/
  /*T(sectionDefinitionSource) = G(symboleSource) + G(sectionCible)*/
  /*T(sectionProgrammeSource) = G(symboleSource) + G(sectionCible)*/
  
  if (retentionMaxAlignementEtTaille) {if (symboleSource->valeur > symboleCible->valeur) {
                                         symboleCible->valeur = symboleSource->valeur;}
    
    if (symboleSource->taille > symboleCible->taille) {symboleCible->taille = symboleSource->taille;}
    }
  
  if (erreurDoubleDefinition) {/*sid:943*/
    printf((char const   *)"%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n", "erreur : ",
           "le symbole ", (symboleCible->nom)->chaine, " (",
           (sectionCible->objetParent)->nom, ":", (sectionCible->nom)->chaine,
           ") et le symbole ", (symboleSource->nom)->chaine, " (",
           (sectionSource->objetParent)->nom, ":",
           (sectionSource->nom)->chaine,
           ") sont definis dans deux objets distincts");
    /*sid:943*/
    /*T(journal) = U*/
    /*T(premiereFois) = U*/
    /*T(sectionBss) = U*/
    /*T(adresseText) = U*/
    /*T(adresseData) = U*/
    /*T(adresseRodata) = U*/
    /*T(adresseBss) = U*/
    /*T(adresseStack) = U*/
    /*T(nomPtEntree) = U*/
    /*T(boutismeHote) = U*/
    /*T(iterateurGlobal) = U*/
    /*T(objets) = U*/
    /*T(copieSuperficielle) = U*/
    /*T(objets_0) = U*/
    /*T(nbFichiersDonnees) = U*/
    
    /*sid:944*/
    *erreur = 1U;
    /*sid:944*/
    /*T(erreur) = G(symboleSource) + G(sectionCible) + G(erreur)*/
    /*T(journal) = G(journal)*/
    /*T(premiereFois) = G(premiereFois)*/
    /*T(sectionBss) = G(sectionBss)*/
    /*T(adresseText) = G(adresseText)*/
    /*T(adresseData) = G(adresseData)*/
    /*T(adresseRodata) = G(adresseRodata)*/
    /*T(adresseBss) = G(adresseBss)*/
    /*T(adresseStack) = G(adresseStack)*/
    /*T(nomPtEntree) = G(nomPtEntree)*/
    /*T(boutismeHote) = G(boutismeHote)*/
    /*T(iterateurGlobal) = G(iterateurGlobal)*/
    /*T(objets) = G(objets)*/
    /*T(copieSuperficielle) = G(copieSuperficielle)*/
    /*T(objets_0) = G(objets_0)*/
    /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
    }
  
  /*sid:3467*/
  return;
  /*sid:3467*/
  /*T(erreur) = G(sectionCible) + G(symboleSource) + G(erreur)*/
  /*T(fusionnerSymboleGlobal) = G(symboleSource) + G(sectionCible)*/
  }

}
static SymboleEDL *symboleGlobalSelonNom(struct StructSectionEDL *tableSymboles ,
                                         struct StructChaineEDL *nomSymbole ) 
{ SymboleEDL **symbolesGlobaux ;
  unsigned int nbGlobaux ;
  unsigned int nbLocaux ;
  unsigned int i ;
  int tmp ;
  SymboleEDL *__retres ;
  
  {/*sid:947*/
  symbolesGlobaux = (tableSymboles->tableSymboles)->symbolesGlobaux;
  /*sid:947*/
  /*T(tableSymboles) = G(tableSymboles)*/
  /*T(nomSymbole) = G(nomSymbole)*/
  /*T(symbolesGlobaux) = G(tableSymboles)*/
  /*T(nbGlobaux) = U*/
  /*T(nbLocaux) = U*/
  /*T(i) = U*/
  /*T(tmp) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = U*/
  /*T(symboleGlobalSelonNom) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(nomSymbole) + G(tableSymboles) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:948*/
  nbGlobaux = (tableSymboles->tableSymboles)->nbGlobaux;
  /*sid:948*/
  /*T(nbGlobaux) = G(tableSymboles)*/
  
  i = 0U;
  /*sid:950*/
  while (i != nbGlobaux) {tmp = strcmp((char const   *)((*(symbolesGlobaux + i))->nom)->chaine,
                                       (char const   *)nomSymbole->chaine);
    if (tmp == 0) {break;}
    
    i ++;}
  
  /*sid:950*/
  /*T(i) = G(nomSymbole) + G(tableSymboles)*/
  /*T(tmp) = G(nomSymbole) + G(tableSymboles)*/
  
  if (i != nbGlobaux)
  {/*sid:961*/
  nbLocaux = (tableSymboles->tableSymboles)->nbLocaux;
  /*sid:961*/
  /*T(nbLocaux) = G(nomSymbole) + G(tableSymboles)*/
  
  /*sid:962*/
  __retres = *(symbolesGlobaux + i);
  /*sid:962*/
  /*T(__retres) = G(nomSymbole) + G(tableSymboles)*/
  
  goto return_label;}
  else {/*sid:963*/
  __retres = (SymboleEDL *)((void *)0);
  /*sid:963*/
  /*T(__retres) = G(nomSymbole) + G(tableSymboles)*/
  
  /*sid:3469*/
  goto return_label;
  /*sid:3469*/
  /*T(nbLocaux) = G(nomSymbole) + G(tableSymboles)*/
  }
  
  /*sid:3470*/
  return_label: /* CIL Label */ 
  return (__retres);
  /*sid:3470*/
  /*T(symboleGlobalSelonNom) = G(nomSymbole) + G(tableSymboles)*/
  }

}
static SymboleEDL *symboleSectionSelonNom(struct StructSectionEDL *tableSymboles ,
                                          struct StructChaineEDL *nomSymbole ) 
{ SymboleEDL **symbolesLocaux ;
  unsigned int nbLocaux ;
  unsigned int i ;
  int tmp ;
  SymboleEDL *__retres ;
  
  {/*sid:964*/
  symbolesLocaux = (tableSymboles->tableSymboles)->symbolesLocaux;
  /*sid:964*/
  /*T(tableSymboles) = G(tableSymboles)*/
  /*T(nomSymbole) = G(nomSymbole)*/
  /*T(symbolesLocaux) = G(tableSymboles)*/
  /*T(nbLocaux) = U*/
  /*T(i) = U*/
  /*T(tmp) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = U*/
  /*T(symboleSectionSelonNom) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(nomSymbole) + G(tableSymboles) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:965*/
  nbLocaux = (tableSymboles->tableSymboles)->nbLocaux;
  /*sid:965*/
  /*T(nbLocaux) = G(tableSymboles)*/
  
  i = 0U;
  /*sid:967*/
  while (i != nbLocaux) {if ((*(symbolesLocaux + i))->type == (TypeSymboleEDL )3) {
                           tmp = strcmp((char const   *)(((*(symbolesLocaux + i))->sectionDefinition)->nom)->chaine,
                                        (char const   *)nomSymbole->chaine);
                           if (tmp == 0) {break;}
                           }
    
    i ++;}
  
  /*sid:967*/
  /*T(i) = G(tableSymboles)*/
  /*T(tmp) = G(nomSymbole) + G(tableSymboles)*/
  
  if (i != nbLocaux)
  {/*sid:981*/
  __retres = *(symbolesLocaux + i);
  /*sid:981*/
  /*T(__retres) = G(tableSymboles)*/
  
  goto return_label;}
  else {/*sid:982*/
  __retres = (SymboleEDL *)((void *)0);
  /*sid:982*/
  /*T(__retres) = G(tableSymboles)*/
  
  goto return_label;}
  
  /*sid:3473*/
  return_label: /* CIL Label */ 
  return (__retres);
  /*sid:3473*/
  /*T(symboleSectionSelonNom) = G(tableSymboles)*/
  }

}
static void supprimerSymbole(struct StructSectionEDL *section ,
                             SymboleEDL *symbole ) 
{ SymboleEDL **symboles ;
  unsigned int nbSymboles ;
  PorteeSymboleEDL portee ;
  SectionEDL *tableChaines ;
  unsigned int i ;
  
  {/*sid:983*/
  portee = symbole->portee;
  /*sid:983*/
  /*T(section) = G(section)*/
  /*T(symbole) = G(symbole)*/
  /*T(symboles) = U*/
  /*T(nbSymboles) = U*/
  /*T(portee) = G(symbole)*/
  /*T(tableChaines) = U*/
  /*T(i) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(supprimerSymbole) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(symbole) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  if (portee == (PorteeSymboleEDL )0)
  {/*sid:986*/
  symboles = (section->tableSymboles)->symbolesLocaux;
  /*sid:986*/
  /*T(symboles) = G(section) + G(symbole)*/
  
  /*sid:987*/
  nbSymboles = (section->tableSymboles)->nbLocaux;
  /*sid:987*/
  /*T(nbSymboles) = G(section) + G(symbole)*/
  }
  else {/*sid:988*/
  symboles = (section->tableSymboles)->symbolesGlobaux;
  /*sid:988*/
  /*T(symboles) = G(section) + G(symbole)*/
  
  /*sid:989*/
  nbSymboles = (section->tableSymboles)->nbGlobaux;
  /*sid:989*/
  /*T(nbSymboles) = G(section) + G(symbole)*/
  }
  
  i = 0U;
  /*sid:991*/
  while (i != nbSymboles) {if (*(symboles + i) == symbole) {break;}
    
    i ++;}
  
  /*sid:991*/
  /*T(i) = G(section) + G(symbole)*/
  
  if (i != nbSymboles)
  {if (symbole->type == (TypeSymboleEDL )3) {libererChaine(& symbole->nom);}
   else {/*sid:1005*/
   tableChaines = (section->tableSymboles)->tableChaines;
   /*sid:1005*/
   /*T(tableChaines) = G(section) + G(symbole)*/
   
   supprimerChaine(tableChaines, symbole->nom);}
  
  /*sid:1007*/
  free((void *)*(symboles + i));
  /*sid:1007*/
  /*T(tableChaines) = G(section) + G(symbole)*/
  
  *(symboles + i) = *(symboles + (nbSymboles - 1U));
  if (portee == (PorteeSymboleEDL )0)
  {/*sid:1011*/
  (section->tableSymboles)->nbLocaux = nbSymboles - 1U;
  /*sid:1011*/
  /*T(section) = G(symbole) + G(section)*/
  }
  else {/*sid:1012*/
  (section->tableSymboles)->nbGlobaux = nbSymboles - 1U;
  /*sid:1012*/
  /*T(section) = G(symbole) + G(section)*/
  }
  }
  else {/*sid:1013*/
  printf((char const   *)"%s%s%s%s%s%s\n", "panique (supprimerSymbole) ! : ",
         "le symbole a supprimer n\'existe pas ",
         "dans la table de symboles ", (section->nom)->chaine,
         " de l\'objet ", (section->objetParent)->nom);
  /*sid:1013*/
  /*T(journal) = U*/
  /*T(premiereFois) = U*/
  /*T(sectionBss) = U*/
  /*T(adresseText) = U*/
  /*T(adresseData) = U*/
  /*T(adresseRodata) = U*/
  /*T(adresseBss) = U*/
  /*T(adresseStack) = U*/
  /*T(nomPtEntree) = U*/
  /*T(boutismeHote) = U*/
  /*T(iterateurGlobal) = U*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = U*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = U*/
  
  exit(1);}
  
  /*sid:3474*/
  return;
  /*sid:3474*/
  /*T(supprimerSymbole) = G(section) + G(symbole)*/
  }

}
static void afficherTitreSymboles(void) 
{ 
  
  {/*sid:1016*/
  printf((char const   *)"%s%s%s%s%s%s\n", "index | ",
         "nom                               | ", "valeur | ", "portee | ",
         "type  | ", "sect. def.");
  /*sid:1016*/
  /*T(journal) = U*/
  /*T(premiereFois) = U*/
  /*T(sectionBss) = U*/
  /*T(adresseText) = U*/
  /*T(adresseData) = U*/
  /*T(adresseRodata) = U*/
  /*T(adresseBss) = U*/
  /*T(adresseStack) = U*/
  /*T(nomPtEntree) = U*/
  /*T(boutismeHote) = U*/
  /*T(iterateurGlobal) = U*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = U*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = U*/
  /*T(afficherTitreSymboles) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  printf((char const   *)"%s%s%s%s%s%s\n", "------|-",
         "----------------------------------|-", "-------|-", "-------|-",
         "------|-", "----------");
  /*sid:3475*/
  return;
  /*sid:3475*/
  /*T(afficherTitreSymboles) = U*/
  }

}
static void afficherSymbole(SymboleEDL symbole , unsigned int indexElf ) 
{ char nomSectionDef[11] ;
  
  {/*sid:1019*/
  printf((char const   *)" %3d  | %-30s    |%8lx| ", indexElf,
         (symbole.nom)->chaine, symbole.valeur);
  /*sid:1019*/
  /*T(symbole) = G(symbole)*/
  /*T(indexElf) = G(indexElf)*/
  /*T(nomSectionDef) = U*/
  /*T(journal) = G(indexElf)*/
  /*T(premiereFois) = G(indexElf)*/
  /*T(sectionBss) = G(indexElf)*/
  /*T(adresseText) = G(indexElf)*/
  /*T(adresseData) = G(indexElf)*/
  /*T(adresseRodata) = G(indexElf)*/
  /*T(adresseBss) = G(indexElf)*/
  /*T(adresseStack) = G(indexElf)*/
  /*T(nomPtEntree) = G(indexElf)*/
  /*T(boutismeHote) = G(indexElf)*/
  /*T(iterateurGlobal) = G(indexElf)*/
  /*T(objets) = G(indexElf)*/
  /*T(copieSuperficielle) = G(indexElf)*/
  /*T(objets_0) = G(indexElf)*/
  /*T(nbFichiersDonnees) = G(indexElf)*/
  /*T(afficherSymbole) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(indexElf) + G(symbole) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  if (symbole.portee == (PorteeSymboleEDL )0)
  {/*sid:1022*/
  printf((char const   *)"%-6s |", "LOCAL");
  /*sid:1022*/
  /*T(journal) = U*/
  /*T(premiereFois) = U*/
  /*T(sectionBss) = U*/
  /*T(adresseText) = U*/
  /*T(adresseData) = U*/
  /*T(adresseRodata) = U*/
  /*T(adresseBss) = U*/
  /*T(adresseStack) = U*/
  /*T(nomPtEntree) = U*/
  /*T(boutismeHote) = U*/
  /*T(iterateurGlobal) = U*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = U*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = U*/
  }
  else {/*sid:1023*/
  printf((char const   *)"%-6s |", "GLOBAL");
  /*sid:1023*/
  /*T(journal) = U*/
  /*T(premiereFois) = U*/
  /*T(sectionBss) = U*/
  /*T(adresseText) = U*/
  /*T(adresseData) = U*/
  /*T(adresseRodata) = U*/
  /*T(adresseBss) = U*/
  /*T(adresseStack) = U*/
  /*T(nomPtEntree) = U*/
  /*T(boutismeHote) = U*/
  /*T(iterateurGlobal) = U*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = U*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = U*/
  }
  
  if (symbole.type == (TypeSymboleEDL )3)
  {printf((char const   *)"%-7s| ", "SECTION");}
  else {printf((char const   *)"%-7s| ", "");}
  
  if (symbole.sectionDefinition == (void *)0)
  {if (symbole.natureDefinition == (NatureDefinitionEDL )0)
   {printf((char const   *)"%-3s\n", "UND");}
   else {if (symbole.natureDefinition == (NatureDefinitionEDL )65521)
         {printf((char const   *)"%-3s\n", "ABS");}
         else {if (symbole.natureDefinition == (NatureDefinitionEDL )65522)
               {printf((char const   *)"%-3s\n", "COM");}
               else {printf((char const   *)"%-3s\n", "   ");}
         }
   }
  }
  else {memcpy((void *)(nomSectionDef),
               (void const   *)((symbole.sectionDefinition)->nom)->chaine, 10U);
  /*sid:1041*/
  nomSectionDef[10] = (char )'\000';
  /*sid:1041*/
  /*T(nomSectionDef) = G(symbole)*/
  
  /*sid:1042*/
  printf((char const   *)"%s\n", nomSectionDef);
  /*sid:1042*/
  /*T(journal) = G(symbole)*/
  /*T(premiereFois) = G(symbole)*/
  /*T(sectionBss) = G(symbole)*/
  /*T(adresseText) = G(symbole)*/
  /*T(adresseData) = G(symbole)*/
  /*T(adresseRodata) = G(symbole)*/
  /*T(adresseBss) = G(symbole)*/
  /*T(adresseStack) = G(symbole)*/
  /*T(nomPtEntree) = G(symbole)*/
  /*T(boutismeHote) = G(symbole)*/
  /*T(iterateurGlobal) = G(symbole)*/
  /*T(objets) = G(symbole)*/
  /*T(copieSuperficielle) = G(symbole)*/
  /*T(objets_0) = G(symbole)*/
  /*T(nbFichiersDonnees) = G(symbole)*/
  }
  
  /*sid:3476*/
  return;
  /*sid:3476*/
  /*T(nomSectionDef) = G(symbole)*/
  /*T(journal) = G(symbole)*/
  /*T(premiereFois) = G(symbole)*/
  /*T(sectionBss) = G(symbole)*/
  /*T(adresseText) = G(symbole)*/
  /*T(adresseData) = G(symbole)*/
  /*T(adresseRodata) = G(symbole)*/
  /*T(adresseBss) = G(symbole)*/
  /*T(adresseStack) = G(symbole)*/
  /*T(nomPtEntree) = G(symbole)*/
  /*T(boutismeHote) = G(symbole)*/
  /*T(iterateurGlobal) = G(symbole)*/
  /*T(objets) = G(symbole)*/
  /*T(copieSuperficielle) = G(symbole)*/
  /*T(objets_0) = G(symbole)*/
  /*T(nbFichiersDonnees) = G(symbole)*/
  /*T(afficherSymbole) = G(symbole)*/
  }

}
static void libererFormatInterneSymboles(struct StructSectionEDL *section ) 
{ TableSymbolesEDL *tableSymboles ;
  SymboleEDL *symbole ;
  unsigned int i ;
  
  {/*sid:1045*/
  if (section->tableSymboles != (void *)0) {/*sid:1046*/
    tableSymboles = section->tableSymboles;
    /*sid:1046*/
    /*T(tableSymboles) = G(section)*/
    
    if (tableSymboles->symbolesLocaux != (void *)0) {/*sid:1049*/
      i = 0U;
      /*sid:1049*/
      /*T(i) = G(section)*/
      
      /*sid:1050*/
      while (i != tableSymboles->nbLocaux) {if (*(tableSymboles->symbolesLocaux + i) != (void *)0) {
                                              symbole = *(tableSymboles->symbolesLocaux + i);
                                              if (symbole->type == (TypeSymboleEDL )3) {
                                                libererChaine(& symbole->nom);}
                                              
                                              free((void *)*(tableSymboles->symbolesLocaux + i));}
        
        i ++;}
      
      /*sid:1050*/
      /*T(symbole) = G(section)*/
      
      free((void *)tableSymboles->symbolesLocaux);}
    
    /*sid:1067*/
    if (tableSymboles->symbolesGlobaux != (void *)0) {i = 0U;
      while (i != tableSymboles->nbGlobaux) {if (*(tableSymboles->symbolesGlobaux + i) != (void *)0) {
                                               free((void *)*(tableSymboles->symbolesGlobaux + i));}
        
        i ++;}
      
      free((void *)tableSymboles->symbolesGlobaux);}
    
    /*sid:1067*/
    /*T(symbole) = G(section)*/
    /*T(i) = G(section)*/
    
    free((void *)section->tableSymboles);
    section->tableSymboles = (struct StructTableSymbolesEDL *)((void *)0);}
  
  /*sid:1045*/
  /*T(section) = G(section)*/
  /*T(tableSymboles) = U*/
  /*T(symbole) = U*/
  /*T(i) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(libererFormatInterneSymboles) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3477*/
  return;
  /*sid:3477*/
  /*T(tableSymboles) = G(section)*/
  /*T(symbole) = G(section)*/
  /*T(i) = G(section)*/
  /*T(libererFormatInterneSymboles) = U*/
  }

}
CategorieSection categorieSection(struct StructSectionEDL *section ) ;
void demarrerIterObjet(IterateurObjet *iterateur , CategorieSection categorie ) ;
void avancerIterObjet(IterateurObjet *iterateur ) ;
struct StructSectionEDL *sectionCouranteIterObjet(IterateurObjet *iterateur ) ;
unsigned int finIterObjet(IterateurObjet *iterateur ) ;
void creerSegments(struct StructObjetEDL *objetCible ) ;
void cloreSegments(struct StructObjetEDL *objet ) ;
void fermerSegments(struct StructObjetEDL *objet ) ;
void implanterSectionsAllouables(struct StructObjetEDL *objet ) ;
void memoriserAdresseText(unsigned long adresse ) ;
void memoriserAdresseData(unsigned long adresse ) ;
void memoriserAdresseRodata(unsigned long adresse ) ;
void memoriserAdresseBss(unsigned long adresse ) ;
void afficherSegments(struct StructObjetEDL *objet ) ;
static void determinerSegments(struct StructObjetEDL *objet ) ;
static void repartirSectionsAllouables(struct StructObjetEDL *objet ) ;
static void fusionnerSegments(SegmentEDL *segments , unsigned int *nbSegments ) ;
static void verifierChevauchementSegments(SegmentEDL *segments ,
                                          unsigned int nbSegments ) ;
static unsigned long adresseText  = 32768UL;
static unsigned long adresseData  = 32768UL;
static unsigned long adresseRodata  = 32768UL;
static unsigned long adresseBss  = 32768UL;
void creerSegments(struct StructObjetEDL *objetCible ) 
{ 
  
  {/*sid:1084*/
  determinerSegments(objetCible);
  /*sid:1084*/
  /*T(objetCible) = G(adresseBss) + G(adresseData) + G(adresseText) + G(adresseRodata) + G(objetCible)*/
  /*T(creerSegments) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objetCible) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(journal) = G(adresseText) + G(adresseRodata) + G(adresseBss) + G(adresseData) + G(journal)*/
  /*T(premiereFois) = G(adresseText) + G(adresseRodata) + G(adresseBss) + G(adresseData) + G(premiereFois)*/
  /*T(sectionBss) = G(adresseText) + G(adresseRodata) + G(adresseBss) + G(adresseData) + G(sectionBss)*/
  /*T(adresseText) = G(adresseData) + G(adresseBss) + G(adresseRodata) + G(adresseText)*/
  /*T(adresseData) = G(adresseText) + G(adresseRodata) + G(adresseBss) + G(adresseData)*/
  /*T(adresseRodata) = G(adresseText) + G(adresseBss) + G(adresseData) + G(adresseRodata)*/
  /*T(adresseBss) = G(adresseText) + G(adresseRodata) + G(adresseData) + G(adresseBss)*/
  /*T(adresseStack) = G(adresseText) + G(adresseRodata) + G(adresseBss) + G(adresseData) + G(adresseStack)*/
  /*T(nomPtEntree) = G(adresseText) + G(adresseRodata) + G(adresseBss) + G(adresseData) + G(nomPtEntree)*/
  /*T(boutismeHote) = G(adresseText) + G(adresseRodata) + G(adresseBss) + G(adresseData) + G(boutismeHote)*/
  /*T(iterateurGlobal) = G(adresseText) + G(adresseRodata) + G(adresseBss) + G(adresseData) + G(iterateurGlobal)*/
  /*T(objets) = G(adresseText) + G(adresseRodata) + G(adresseBss) + G(adresseData) + G(objets)*/
  /*T(copieSuperficielle) = G(adresseText) + G(adresseRodata) + G(adresseBss) + G(adresseData) + G(copieSuperficielle)*/
  /*T(objets_0) = G(adresseText) + G(adresseRodata) + G(adresseBss) + G(adresseData) + G(objets_0)*/
  /*T(nbFichiersDonnees) = G(adresseText) + G(adresseRodata) + G(adresseBss) + G(adresseData) + G(nbFichiersDonnees)*/
  
  repartirSectionsAllouables(objetCible);
  /*sid:3478*/
  return;
  /*sid:3478*/
  /*T(creerSegments) = U*/
  }

}
void cloreSegments(struct StructObjetEDL *objet ) 
{ SegmentEDL *segments ;
  unsigned int nbSegments ;
  Elf32_Phdr *phdr ;
  unsigned int i ;
  
  {/*sid:1087*/
  segments = objet->segments;
  /*sid:1087*/
  /*T(cloreSegments) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(objet) = G(objet)*/
  /*T(segments) = G(objet)*/
  /*T(nbSegments) = U*/
  /*T(phdr) = U*/
  /*T(i) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  /*sid:1088*/
  nbSegments = objet->nbSegments;
  /*sid:1088*/
  /*T(nbSegments) = G(objet)*/
  
  if (nbSegments != 0U) {/*sid:1091*/
    i = 0U;
    /*sid:1091*/
    /*T(i) = G(objet)*/
    
    /*sid:1092*/
    while (i != nbSegments) {(phdr + i)->p_type = 1U;
      (phdr + i)->p_offset = (unsigned int )(segments + i)->position;
      (phdr + i)->p_vaddr = (unsigned int )(segments + i)->adresse;
      (phdr + i)->p_paddr = (phdr + i)->p_vaddr;
      (phdr + i)->p_filesz = (segments + i)->tailleFichier;
      (phdr + i)->p_memsz = (segments + i)->tailleMemoire;
      (phdr + i)->p_align = 32768U;
      (phdr + i)->p_flags = 0U;
      if ((segments + i)->type & 1U) {(phdr + i)->p_flags |= (unsigned int )(
                                      4 | 1);}
      
      if ((segments + i)->type & 2U)
      {(phdr + i)->p_flags |= (unsigned int )(4 | 2);}
      else {if ((segments + i)->type & 8U) {(phdr + i)->p_flags |= (unsigned int )(
                                            4 | 2);}
      }
      
      if ((segments + i)->type & 4U) {(phdr + i)->p_flags |= 4U;}
      
      i ++;}
    
    /*sid:1092*/
    /*T(phdr) = G(objet)*/
    }
  
  /*sid:3479*/
  return;
  /*sid:3479*/
  /*T(cloreSegments) = G(objet)*/
  /*T(phdr) = G(objet)*/
  /*T(i) = G(objet)*/
  }

}
void fermerSegments(struct StructObjetEDL *objet ) 
{ unsigned int i ;
  
  {/*sid:1123*/
  if (objet->segments != (void *)0) {/*sid:1124*/
    i = 0U;
    /*sid:1124*/
    /*T(i) = G(objet)*/
    
    while (i != objet->nbSegments) {if ((objet->segments + i)->sections != (void *)0) {
                                      free((void *)(objet->segments + i)->sections);}
      
      i ++;}
    
    free((void *)objet->segments);
    objet->segments = (struct StructSegmentEDL *)((void *)0);}
  
  /*sid:1123*/
  /*T(fermerSegments) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(objet) = G(objet)*/
  /*T(i) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  /*sid:3480*/
  return;
  /*sid:3480*/
  /*T(fermerSegments) = U*/
  /*T(i) = G(objet)*/
  }

}
void implanterSectionsAllouables(struct StructObjetEDL *objet ) 
{ SegmentEDL *segments ;
  unsigned int nbSegments ;
  SectionEDL *section ;
  unsigned int i ;
  unsigned int noSegment ;
  unsigned long adresse ;
  unsigned long position ;
  
  {/*sid:1138*/
  nbSegments = objet->nbSegments;
  /*sid:1138*/
  /*T(implanterSectionsAllouables) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(objet) = G(objet)*/
  /*T(segments) = U*/
  /*T(nbSegments) = G(objet)*/
  /*T(section) = U*/
  /*T(i) = U*/
  /*T(noSegment) = U*/
  /*T(adresse) = U*/
  /*T(position) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  if (nbSegments != 0U) {/*sid:1141*/
    segments = objet->segments;
    /*sid:1141*/
    /*T(segments) = G(objet)*/
    
    /*sid:1142*/
    section = *((segments + 0)->sections + 0);
    /*sid:1142*/
    /*T(section) = G(objet)*/
    
    section->adresse = (segments + 0)->adresse1ereSection;
    section->position = (segments + 0)->position1ereSection;
    /*sid:1145*/
    adresse = section->adresse + (unsigned long )section->tailleContenuElf;
    /*sid:1145*/
    /*T(adresse) = G(objet)*/
    
    /*sid:1146*/
    position = section->position + (unsigned long )section->tailleContenuElf;
    /*sid:1146*/
    /*T(position) = G(objet)*/
    
    /*sid:1147*/
    i = 1U;
    /*sid:1147*/
    /*T(i) = G(objet)*/
    
    while (i != (segments + 0)->nbSections) {section = *((segments + 0)->sections + i);
      section->adresse = alignement(adresse, section->alignement);
      section->position = alignement(position, section->alignement);
      adresse = section->adresse + (unsigned long )section->tailleContenuElf;
      if (section->type != (TypeSectionEDL )8) {position = section->position + (unsigned long )section->tailleContenuElf;}
      
      i ++;}
    
    (segments + 0)->tailleMemoire = (unsigned int )(adresse - (segments + 0)->adresse);
    (segments + 0)->tailleFichier = (unsigned int )(position - (segments + 0)->position);}
  
  /*sid:1164*/
  noSegment = 1U;
  /*sid:1164*/
  /*T(segments) = G(objet)*/
  /*T(section) = G(objet)*/
  /*T(i) = G(objet)*/
  /*T(adresse) = G(objet)*/
  /*T(position) = G(objet)*/
  
  /*sid:1165*/
  while (noSegment != nbSegments) {(segments + noSegment)->position = alignement(
                                   position, 32768U);
    section = *((segments + noSegment)->sections + 0);
    section->adresse = (segments + noSegment)->adresse;
    section->position = (segments + noSegment)->position;
    adresse = section->adresse + (unsigned long )section->tailleContenuElf;
    position = section->position;
    if (section->type != (TypeSectionEDL )8) {position += (unsigned long )section->tailleContenuElf;}
    
    i = 1U;
    while (i != (segments + noSegment)->nbSections) {section = *((segments + noSegment)->sections + i);
      section->adresse = alignement(adresse, section->alignement);
      section->position = alignement(position, section->alignement);
      adresse = section->adresse + (unsigned long )section->tailleContenuElf;
      position = section->position;
      if (section->type != (TypeSectionEDL )8) {position += (unsigned long )section->tailleContenuElf;}
      
      i ++;}
    
    (segments + noSegment)->tailleMemoire = (unsigned int )(adresse - (
                                                            segments + noSegment)->adresse);
    (segments + noSegment)->tailleFichier = (unsigned int )(position - (
                                                            segments + noSegment)->position);
    noSegment ++;}
  
  /*sid:1165*/
  /*T(noSegment) = G(objet)*/
  
  verifierChevauchementSegments(segments, nbSegments);
  objet->tailleFichier = position;
  /*sid:3481*/
  return;
  /*sid:3481*/
  /*T(implanterSectionsAllouables) = U*/
  }

}
void memoriserAdresseText(unsigned long adresse ) 
{ 
  
  {/*sid:1200*/
  adresseText = adresse;
  /*sid:1200*/
  /*T(memoriserAdresseText) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(adresse) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(adresse) = G(adresse)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresse)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  /*sid:3482*/
  return;
  /*sid:3482*/
  /*T(memoriserAdresseText) = U*/
  }

}
void memoriserAdresseData(unsigned long adresse ) 
{ 
  
  {/*sid:1202*/
  adresseData = adresse;
  /*sid:1202*/
  /*T(memoriserAdresseData) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(adresse) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(adresse) = G(adresse)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresse)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  /*sid:3483*/
  return;
  /*sid:3483*/
  /*T(memoriserAdresseData) = U*/
  }

}
void memoriserAdresseRodata(unsigned long adresse ) 
{ 
  
  {/*sid:1204*/
  adresseRodata = adresse;
  /*sid:1204*/
  /*T(memoriserAdresseRodata) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(adresse) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(adresse) = G(adresse)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresse)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  /*sid:3484*/
  return;
  /*sid:3484*/
  /*T(memoriserAdresseRodata) = U*/
  }

}
void memoriserAdresseBss(unsigned long adresse ) 
{ 
  
  {/*sid:1206*/
  adresseBss = adresse;
  /*sid:1206*/
  /*T(memoriserAdresseBss) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(adresse) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(adresse) = G(adresse)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresse)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  /*sid:3485*/
  return;
  /*sid:3485*/
  /*T(memoriserAdresseBss) = U*/
  }

}
void afficherSegments(struct StructObjetEDL *objet ) 
{ SegmentEDL *segments ;
  unsigned int nbSegments ;
  unsigned int i ;
  unsigned int type ;
  unsigned int rang ;
  
  {/*sid:1208*/
  segments = objet->segments;
  /*sid:1208*/
  /*T(afficherSegments) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(objet) = G(objet)*/
  /*T(segments) = G(objet)*/
  /*T(nbSegments) = U*/
  /*T(i) = U*/
  /*T(type) = U*/
  /*T(rang) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  /*sid:1209*/
  nbSegments = objet->nbSegments;
  /*sid:1209*/
  /*T(nbSegments) = G(objet)*/
  
  printf((char const   *)"nature | position |  adresse | taille fichier | ");
  printf((char const   *)"taille memoire |     type     \n");
  printf((char const   *)"-------|----------|----------|----------------|-");
  printf((char const   *)"---------------|--------------\n");
  i = 0U;
  /*sid:1215*/
  while (i != nbSegments) {printf((char const   *)" LOAD  | ");
    /*sid:1220*/
    printf((char const   *)"%8lx | ", (segments + i)->position);
    /*sid:1220*/
    /*T(journal) = G(objet)*/
    /*T(premiereFois) = G(objet)*/
    /*T(sectionBss) = G(objet)*/
    /*T(adresseText) = G(objet)*/
    /*T(adresseData) = G(objet)*/
    /*T(adresseRodata) = G(objet)*/
    /*T(adresseBss) = G(objet)*/
    /*T(adresseStack) = G(objet)*/
    /*T(nomPtEntree) = G(objet)*/
    /*T(boutismeHote) = G(objet)*/
    /*T(iterateurGlobal) = G(objet)*/
    /*T(objets) = G(objet)*/
    /*T(copieSuperficielle) = G(objet)*/
    /*T(objets_0) = G(objet)*/
    /*T(nbFichiersDonnees) = G(objet)*/
    
    printf((char const   *)"%8lx |    ", (segments + i)->adresse);
    printf((char const   *)"%8x    |    ", (segments + i)->tailleFichier);
    printf((char const   *)"%8x    | ", (segments + i)->tailleMemoire);
    rang = 0U;
    while (rang != sizeof((segments + i)->type)) {type = (segments + i)->type & (unsigned int )(
                                                         1 << rang);
      switch ((int )type) {case 1: ;
      printf((char const   *)"TXT ");
      break;
      case 2: ;
      printf((char const   *)"DAT ");
      break;
      case 4: ;
      printf((char const   *)"ROD ");
      break;
      case 8: ;
      printf((char const   *)"BSS ");
      break;
      default: ;
      break;}
      
      rang ++;}
    
    printf((char const   *)"\n");
    /*sid:1247*/
    i ++;
    /*sid:1247*/
    /*T(journal) = G(objet) + G(journal)*/
    /*T(premiereFois) = G(objet) + G(premiereFois)*/
    /*T(sectionBss) = G(objet) + G(sectionBss)*/
    /*T(adresseText) = G(objet) + G(adresseText)*/
    /*T(adresseData) = G(objet) + G(adresseData)*/
    /*T(adresseRodata) = G(objet) + G(adresseRodata)*/
    /*T(adresseBss) = G(objet) + G(adresseBss)*/
    /*T(adresseStack) = G(objet) + G(adresseStack)*/
    /*T(nomPtEntree) = G(objet) + G(nomPtEntree)*/
    /*T(boutismeHote) = G(objet) + G(boutismeHote)*/
    /*T(iterateurGlobal) = G(objet) + G(iterateurGlobal)*/
    /*T(objets) = G(objet) + G(objets)*/
    /*T(copieSuperficielle) = G(objet) + G(copieSuperficielle)*/
    /*T(objets_0) = G(objet) + G(objets_0)*/
    /*T(nbFichiersDonnees) = G(objet) + G(nbFichiersDonnees)*/
    }
  
  /*sid:1215*/
  /*T(i) = G(objet)*/
  /*T(type) = G(objet)*/
  /*T(rang) = G(objet)*/
  /*T(journal) = G(objet) + G(journal)*/
  /*T(premiereFois) = G(objet) + G(premiereFois)*/
  /*T(sectionBss) = G(objet) + G(sectionBss)*/
  /*T(adresseText) = G(objet) + G(adresseText)*/
  /*T(adresseData) = G(objet) + G(adresseData)*/
  /*T(adresseRodata) = G(objet) + G(adresseRodata)*/
  /*T(adresseBss) = G(objet) + G(adresseBss)*/
  /*T(adresseStack) = G(objet) + G(adresseStack)*/
  /*T(nomPtEntree) = G(objet) + G(nomPtEntree)*/
  /*T(boutismeHote) = G(objet) + G(boutismeHote)*/
  /*T(iterateurGlobal) = G(objet) + G(iterateurGlobal)*/
  /*T(objets) = G(objet) + G(objets)*/
  /*T(copieSuperficielle) = G(objet) + G(copieSuperficielle)*/
  /*T(objets_0) = G(objet) + G(objets_0)*/
  /*T(nbFichiersDonnees) = G(objet) + G(nbFichiersDonnees)*/
  
  printf((char const   *)"\n");
  /*sid:3486*/
  return;
  /*sid:3486*/
  /*T(afficherSegments) = U*/
  }

}
static void determinerSegments(struct StructObjetEDL *objet ) 
{ SegmentEDL *segments ;
  unsigned int nbSegments ;
  IterateurObjet *iterateur ;
  CategorieSection categorie ;
  SectionEDL *sectionCourante ;
  unsigned int nbSectionsInstructions ;
  unsigned int nbSectionsInitialisees ;
  unsigned int nbSectionsLectureSeule ;
  unsigned int nbSectionsNonInitialisees ;
  unsigned int i ;
  unsigned int tmp_0 ;
  unsigned int tmp_1 ;
  unsigned int tmp_2 ;
  unsigned int tmp_3 ;
  
  {/*sid:1251*/
  if ((adresseText & (unsigned long )(32768 - 1)) != 0UL) {/*sid:1252*/
    printf((char const   *)"adresse segment text requise : %lx, ", adresseText);
    /*sid:1252*/
    /*T(journal) = G(adresseText)*/
    /*T(premiereFois) = G(adresseText)*/
    /*T(sectionBss) = G(adresseText)*/
    /*T(adresseData) = G(adresseText)*/
    /*T(adresseRodata) = G(adresseText)*/
    /*T(adresseBss) = G(adresseText)*/
    /*T(adresseStack) = G(adresseText)*/
    /*T(nomPtEntree) = G(adresseText)*/
    /*T(boutismeHote) = G(adresseText)*/
    /*T(iterateurGlobal) = G(adresseText)*/
    /*T(objets) = G(adresseText)*/
    /*T(copieSuperficielle) = G(adresseText)*/
    /*T(objets_0) = G(adresseText)*/
    /*T(nbFichiersDonnees) = G(adresseText)*/
    
    adresseText &= (unsigned long )(~ (32768 - 1));
    /*sid:1254*/
    printf((char const   *)"adresse segment text retenue : %lx\n", adresseText);
    /*sid:1254*/
    /*T(journal) = G(adresseText) + G(journal)*/
    /*T(premiereFois) = G(adresseText) + G(premiereFois)*/
    /*T(sectionBss) = G(adresseText) + G(sectionBss)*/
    /*T(adresseData) = G(adresseText) + G(adresseData)*/
    /*T(adresseRodata) = G(adresseText) + G(adresseRodata)*/
    /*T(adresseBss) = G(adresseText) + G(adresseBss)*/
    /*T(adresseStack) = G(adresseText) + G(adresseStack)*/
    /*T(nomPtEntree) = G(adresseText) + G(nomPtEntree)*/
    /*T(boutismeHote) = G(adresseText) + G(boutismeHote)*/
    /*T(iterateurGlobal) = G(adresseText) + G(iterateurGlobal)*/
    /*T(objets) = G(adresseText) + G(objets)*/
    /*T(copieSuperficielle) = G(adresseText) + G(copieSuperficielle)*/
    /*T(objets_0) = G(adresseText) + G(objets_0)*/
    /*T(nbFichiersDonnees) = G(adresseText) + G(nbFichiersDonnees)*/
    }
  
  /*sid:1251*/
  /*T(objet) = G(objet)*/
  /*T(segments) = U*/
  /*T(nbSegments) = U*/
  /*T(iterateur) = U*/
  /*T(categorie) = U*/
  /*T(sectionCourante) = U*/
  /*T(nbSectionsInstructions) = U*/
  /*T(nbSectionsInitialisees) = U*/
  /*T(nbSectionsLectureSeule) = U*/
  /*T(nbSectionsNonInitialisees) = U*/
  /*T(i) = U*/
  /*T(tmp_0) = U*/
  /*T(tmp_1) = U*/
  /*T(tmp_2) = U*/
  /*T(tmp_3) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(determinerSegments) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:1257*/
  if ((adresseData & (unsigned long )(32768 - 1)) != 0UL) {/*sid:1258*/
    printf((char const   *)"adresse segment data requise : %lx, ", adresseData);
    /*sid:1258*/
    /*T(journal) = G(adresseText) + G(adresseData)*/
    /*T(premiereFois) = G(adresseText) + G(adresseData)*/
    /*T(sectionBss) = G(adresseText) + G(adresseData)*/
    /*T(adresseText) = G(adresseText) + G(adresseData)*/
    /*T(adresseRodata) = G(adresseText) + G(adresseData)*/
    /*T(adresseBss) = G(adresseText) + G(adresseData)*/
    /*T(adresseStack) = G(adresseText) + G(adresseData)*/
    /*T(nomPtEntree) = G(adresseText) + G(adresseData)*/
    /*T(boutismeHote) = G(adresseText) + G(adresseData)*/
    /*T(iterateurGlobal) = G(adresseText) + G(adresseData)*/
    /*T(objets) = G(adresseText) + G(adresseData)*/
    /*T(copieSuperficielle) = G(adresseText) + G(adresseData)*/
    /*T(objets_0) = G(adresseText) + G(adresseData)*/
    /*T(nbFichiersDonnees) = G(adresseText) + G(adresseData)*/
    
    adresseData &= (unsigned long )(~ (32768 - 1));
    /*sid:1260*/
    printf((char const   *)"adresse segment data retenue : %lx\n", adresseData);
    /*sid:1260*/
    /*T(journal) = G(adresseData) + G(adresseText) + G(journal)*/
    /*T(premiereFois) = G(adresseData) + G(adresseText) + G(premiereFois)*/
    /*T(sectionBss) = G(adresseData) + G(adresseText) + G(sectionBss)*/
    /*T(adresseRodata) = G(adresseData) + G(adresseText) + G(adresseRodata)*/
    /*T(adresseBss) = G(adresseData) + G(adresseText) + G(adresseBss)*/
    /*T(adresseStack) = G(adresseData) + G(adresseText) + G(adresseStack)*/
    /*T(nomPtEntree) = G(adresseData) + G(adresseText) + G(nomPtEntree)*/
    /*T(boutismeHote) = G(adresseData) + G(adresseText) + G(boutismeHote)*/
    /*T(iterateurGlobal) = G(adresseData) + G(adresseText) + G(iterateurGlobal)*/
    /*T(objets) = G(adresseData) + G(adresseText) + G(objets)*/
    /*T(copieSuperficielle) = G(adresseData) + G(adresseText) + G(copieSuperficielle)*/
    /*T(objets_0) = G(adresseData) + G(adresseText) + G(objets_0)*/
    /*T(nbFichiersDonnees) = G(adresseData) + G(adresseText) + G(nbFichiersDonnees)*/
    }
  
  /*sid:1257*/
  /*T(journal) = G(adresseText) + G(journal)*/
  /*T(premiereFois) = G(adresseText) + G(premiereFois)*/
  /*T(sectionBss) = G(adresseText) + G(sectionBss)*/
  /*T(adresseData) = G(adresseText) + G(adresseData)*/
  /*T(adresseRodata) = G(adresseText) + G(adresseRodata)*/
  /*T(adresseBss) = G(adresseText) + G(adresseBss)*/
  /*T(adresseStack) = G(adresseText) + G(adresseStack)*/
  /*T(nomPtEntree) = G(adresseText) + G(nomPtEntree)*/
  /*T(boutismeHote) = G(adresseText) + G(boutismeHote)*/
  /*T(iterateurGlobal) = G(adresseText) + G(iterateurGlobal)*/
  /*T(objets) = G(adresseText) + G(objets)*/
  /*T(copieSuperficielle) = G(adresseText) + G(copieSuperficielle)*/
  /*T(objets_0) = G(adresseText) + G(objets_0)*/
  /*T(nbFichiersDonnees) = G(adresseText) + G(nbFichiersDonnees)*/
  
  /*sid:1263*/
  if ((adresseRodata & (unsigned long )(32768 - 1)) != 0UL) {/*sid:1264*/
    printf((char const   *)"adresse segment rodata requise : %lx, ",
           adresseRodata);
    /*sid:1264*/
    /*T(journal) = G(adresseData) + G(adresseText) + G(adresseRodata)*/
    /*T(premiereFois) = G(adresseData) + G(adresseText) + G(adresseRodata)*/
    /*T(sectionBss) = G(adresseData) + G(adresseText) + G(adresseRodata)*/
    /*T(adresseText) = G(adresseData) + G(adresseText) + G(adresseRodata)*/
    /*T(adresseData) = G(adresseData) + G(adresseText) + G(adresseRodata)*/
    /*T(adresseBss) = G(adresseData) + G(adresseText) + G(adresseRodata)*/
    /*T(adresseStack) = G(adresseData) + G(adresseText) + G(adresseRodata)*/
    /*T(nomPtEntree) = G(adresseData) + G(adresseText) + G(adresseRodata)*/
    /*T(boutismeHote) = G(adresseData) + G(adresseText) + G(adresseRodata)*/
    /*T(iterateurGlobal) = G(adresseData) + G(adresseText) + G(adresseRodata)*/
    /*T(objets) = G(adresseData) + G(adresseText) + G(adresseRodata)*/
    /*T(copieSuperficielle) = G(adresseData) + G(adresseText) + G(adresseRodata)*/
    /*T(objets_0) = G(adresseData) + G(adresseText) + G(adresseRodata)*/
    /*T(nbFichiersDonnees) = G(adresseData) + G(adresseText) + G(adresseRodata)*/
    
    adresseRodata &= (unsigned long )(~ (32768 - 1));
    /*sid:1266*/
    printf((char const   *)"adresse segment data retenue : %lx\n",
           adresseRodata);
    /*sid:1266*/
    /*T(journal) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(journal)*/
    /*T(premiereFois) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(premiereFois)*/
    /*T(sectionBss) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(sectionBss)*/
    /*T(adresseBss) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(adresseBss)*/
    /*T(adresseStack) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(adresseStack)*/
    /*T(nomPtEntree) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(nomPtEntree)*/
    /*T(boutismeHote) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(boutismeHote)*/
    /*T(iterateurGlobal) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(iterateurGlobal)*/
    /*T(objets) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(objets)*/
    /*T(copieSuperficielle) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(copieSuperficielle)*/
    /*T(objets_0) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(objets_0)*/
    /*T(nbFichiersDonnees) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(nbFichiersDonnees)*/
    }
  
  /*sid:1263*/
  /*T(journal) = G(adresseData) + G(adresseText) + G(journal)*/
  /*T(premiereFois) = G(adresseData) + G(adresseText) + G(premiereFois)*/
  /*T(sectionBss) = G(adresseData) + G(adresseText) + G(sectionBss)*/
  /*T(adresseText) = G(adresseData) + G(adresseText)*/
  /*T(adresseRodata) = G(adresseData) + G(adresseText) + G(adresseRodata)*/
  /*T(adresseBss) = G(adresseData) + G(adresseText) + G(adresseBss)*/
  /*T(adresseStack) = G(adresseData) + G(adresseText) + G(adresseStack)*/
  /*T(nomPtEntree) = G(adresseData) + G(adresseText) + G(nomPtEntree)*/
  /*T(boutismeHote) = G(adresseData) + G(adresseText) + G(boutismeHote)*/
  /*T(iterateurGlobal) = G(adresseData) + G(adresseText) + G(iterateurGlobal)*/
  /*T(objets) = G(adresseData) + G(adresseText) + G(objets)*/
  /*T(copieSuperficielle) = G(adresseData) + G(adresseText) + G(copieSuperficielle)*/
  /*T(objets_0) = G(adresseData) + G(adresseText) + G(objets_0)*/
  /*T(nbFichiersDonnees) = G(adresseData) + G(adresseText) + G(nbFichiersDonnees)*/
  
  /*sid:1269*/
  if ((adresseBss & (unsigned long )(32768 - 1)) != 0UL) {/*sid:1270*/
    printf((char const   *)"adresse segment bss requise : %lx, ", adresseBss);
    /*sid:1270*/
    /*T(journal) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(adresseBss)*/
    /*T(premiereFois) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(adresseBss)*/
    /*T(sectionBss) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(adresseBss)*/
    /*T(adresseText) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(adresseBss)*/
    /*T(adresseData) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(adresseBss)*/
    /*T(adresseRodata) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(adresseBss)*/
    /*T(adresseStack) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(adresseBss)*/
    /*T(nomPtEntree) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(adresseBss)*/
    /*T(boutismeHote) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(adresseBss)*/
    /*T(iterateurGlobal) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(adresseBss)*/
    /*T(objets) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(adresseBss)*/
    /*T(copieSuperficielle) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(adresseBss)*/
    /*T(objets_0) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(adresseBss)*/
    /*T(nbFichiersDonnees) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(adresseBss)*/
    
    adresseBss &= (unsigned long )(~ (32768 - 1));
    /*sid:1272*/
    printf((char const   *)"adresse segment bss retenue : %lx\n", adresseBss);
    /*sid:1272*/
    /*T(journal) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(journal)*/
    /*T(premiereFois) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(premiereFois)*/
    /*T(sectionBss) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(sectionBss)*/
    /*T(adresseStack) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(adresseStack)*/
    /*T(nomPtEntree) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(nomPtEntree)*/
    /*T(boutismeHote) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(boutismeHote)*/
    /*T(iterateurGlobal) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(iterateurGlobal)*/
    /*T(objets) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(objets)*/
    /*T(copieSuperficielle) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(copieSuperficielle)*/
    /*T(objets_0) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(objets_0)*/
    /*T(nbFichiersDonnees) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(nbFichiersDonnees)*/
    }
  
  /*sid:1269*/
  /*T(journal) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(journal)*/
  /*T(premiereFois) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(premiereFois)*/
  /*T(sectionBss) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(sectionBss)*/
  /*T(adresseText) = G(adresseRodata) + G(adresseData) + G(adresseText)*/
  /*T(adresseData) = G(adresseRodata) + G(adresseText) + G(adresseData)*/
  /*T(adresseBss) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(adresseBss)*/
  /*T(adresseStack) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(adresseStack)*/
  /*T(nomPtEntree) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(nomPtEntree)*/
  /*T(boutismeHote) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(boutismeHote)*/
  /*T(iterateurGlobal) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(iterateurGlobal)*/
  /*T(objets) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(objets)*/
  /*T(copieSuperficielle) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(copieSuperficielle)*/
  /*T(objets_0) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(objets_0)*/
  /*T(nbFichiersDonnees) = G(adresseRodata) + G(adresseData) + G(adresseText) + G(nbFichiersDonnees)*/
  
  /*sid:1274*/
  nbSegments = 4U;
  /*sid:1274*/
  /*T(journal) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(journal)*/
  /*T(premiereFois) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(premiereFois)*/
  /*T(sectionBss) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(sectionBss)*/
  /*T(adresseText) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText)*/
  /*T(adresseData) = G(adresseBss) + G(adresseRodata) + G(adresseText) + G(adresseData)*/
  /*T(adresseRodata) = G(adresseBss) + G(adresseData) + G(adresseText) + G(adresseRodata)*/
  /*T(adresseStack) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(adresseStack)*/
  /*T(nomPtEntree) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(nomPtEntree)*/
  /*T(boutismeHote) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(boutismeHote)*/
  /*T(iterateurGlobal) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(iterateurGlobal)*/
  /*T(objets) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(objets)*/
  /*T(copieSuperficielle) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(copieSuperficielle)*/
  /*T(objets_0) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(objets_0)*/
  /*T(nbFichiersDonnees) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(nbFichiersDonnees)*/
  
  segments = (SegmentEDL *)calloc(nbSegments, sizeof(SegmentEDL ));
  (segments + 0)->type = 1U;
  /*sid:1277*/
  (segments + 0)->adresse = adresseText;
  /*sid:1277*/
  /*T(segments) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText)*/
  
  (segments + 1)->type = 2U;
  (segments + 1)->adresse = adresseData;
  (segments + 2)->type = 4U;
  (segments + 2)->adresse = adresseRodata;
  (segments + 3)->type = 8U;
  (segments + 3)->adresse = adresseBss;
  /*sid:1284*/
  iterateur = objet->iterateur;
  /*sid:1284*/
  /*T(iterateur) = G(objet)*/
  
  nbSectionsInstructions = 0U;
  nbSectionsInitialisees = 0U;
  nbSectionsLectureSeule = 0U;
  nbSectionsNonInitialisees = 0U;
  demarrerIterObjet(iterateur, INSTRUCTIONS);
  /*sid:1290*/
  while (1) {tmp_0 = finIterObjet(iterateur);
    if (tmp_0) {break;}
    
    sectionCourante = sectionCouranteIterObjet(iterateur);
    categorie = categorieSection(sectionCourante);
    if ((int )categorie != (int )INSTRUCTIONS) {break;}
    
    nbSectionsInstructions ++;
    avancerIterObjet(iterateur);}
  
  /*sid:1290*/
  /*T(categorie) = G(objet)*/
  /*T(sectionCourante) = G(objet)*/
  /*T(nbSectionsInstructions) = G(objet)*/
  /*T(tmp_0) = G(objet)*/
  
  /*sid:1302*/
  while (1) {tmp_1 = finIterObjet(iterateur);
    if (tmp_1) {break;}
    
    sectionCourante = sectionCouranteIterObjet(iterateur);
    categorie = categorieSection(sectionCourante);
    if ((int )categorie != (int )DONNEES_INITIALISEES) {break;}
    
    nbSectionsInitialisees ++;
    avancerIterObjet(iterateur);}
  
  /*sid:1302*/
  /*T(nbSectionsInitialisees) = G(objet)*/
  /*T(tmp_1) = G(objet)*/
  
  /*sid:1314*/
  while (1) {tmp_2 = finIterObjet(iterateur);
    if (tmp_2) {break;}
    
    sectionCourante = sectionCouranteIterObjet(iterateur);
    categorie = categorieSection(sectionCourante);
    if ((int )categorie != (int )DONNEES_LECTURE_SEULE) {break;}
    
    nbSectionsLectureSeule ++;
    avancerIterObjet(iterateur);}
  
  /*sid:1314*/
  /*T(nbSectionsLectureSeule) = G(objet)*/
  /*T(tmp_2) = G(objet)*/
  
  /*sid:1326*/
  while (1) {tmp_3 = finIterObjet(iterateur);
    if (tmp_3) {break;}
    
    sectionCourante = sectionCouranteIterObjet(iterateur);
    categorie = categorieSection(sectionCourante);
    if ((int )categorie != (int )DONNEES_NON_INITIALISEES) {break;}
    
    nbSectionsNonInitialisees ++;
    avancerIterObjet(iterateur);}
  
  /*sid:1326*/
  /*T(nbSectionsNonInitialisees) = G(objet)*/
  /*T(tmp_3) = G(objet)*/
  
  if (nbSectionsInstructions == 0U) {printf((char const   *)"%s%s%s\n",
                                            "attention ! : l\'objet ",
                                            objet->nom,
                                            " ne contient aucune section d\'instructions allouable");}
  
  /*sid:1342*/
  (segments + 0)->nbSections = nbSectionsInstructions;
  /*sid:1342*/
  /*T(segments) = G(objet) + G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText)*/
  
  i = 1U;
  while (i != nbSegments) {(segments + i)->nbSections = 0U;
    i ++;}
  
  i = 0U;
  while (i != nbSegments) {if ((segments + i)->type & 2U) {(segments + i)->nbSections += nbSectionsInitialisees;}
    
    if ((segments + i)->type & 4U) {(segments + i)->nbSections += nbSectionsLectureSeule;}
    
    if ((segments + i)->type & 8U) {(segments + i)->nbSections += nbSectionsNonInitialisees;}
    
    i ++;}
  
  i = nbSegments - 1U;
  /*sid:1369*/
  while (i != 0U) {if ((segments + i)->nbSections == 0U) {nbSegments --;}
                   else {if ((segments + (i - 1U))->nbSections == 0U) {
                           (segments + (i - 1U))->type = (segments + i)->type;
                           (segments + (i - 1U))->nbSections = (segments + i)->nbSections;
                           (segments + (i - 1U))->adresse = (segments + i)->adresse;
                           nbSegments --;}
                   }
    
    i --;}
  
  /*sid:1369*/
  /*T(nbSegments) = G(objet) + G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText)*/
  /*T(i) = G(objet) + G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText)*/
  
  if (nbSegments != 0U) {(segments + 0)->position = 0UL;
    (segments + 0)->position1ereSection = (unsigned long )(sizeof(Elf32_Ehdr ) + 
                                                           sizeof(Elf32_Phdr ) * nbSegments);
    (segments + 0)->adresse1ereSection = (segments + 0)->adresse + (segments + 0)->position1ereSection;
    i = 1U;
    while (i != nbSegments) {(segments + i)->adresse1ereSection = (segments + i)->adresse;
      i ++;}
    }
  
  objet->segments = (struct StructSegmentEDL *)realloc((void *)segments,
                                                       nbSegments * sizeof(SegmentEDL ));
  /*sid:1398*/
  objet->nbSegments = nbSegments;
  /*sid:1398*/
  /*T(objet) = G(adresseText) + G(adresseData) + G(adresseRodata) + G(adresseBss) + G(objet)*/
  
  /*sid:3487*/
  return;
  /*sid:3487*/
  /*T(determinerSegments) = U*/
  }

}
static void repartirSectionsAllouables(struct StructObjetEDL *objet ) 
{ SegmentEDL *segments ;
  unsigned int nbSegments ;
  SectionEDL ***sectionsSegment ;
  IterateurObjet *iterateur ;
  SectionEDL *sectionCourante ;
  CategorieSection categorie ;
  unsigned int i ;
  unsigned int tmp_1 ;
  unsigned int tmp_2 ;
  unsigned int tmp_3 ;
  unsigned int tmp_4 ;
  
  {/*sid:1400*/
  segments = objet->segments;
  /*sid:1400*/
  /*T(objet) = G(objet)*/
  /*T(segments) = G(objet)*/
  /*T(nbSegments) = U*/
  /*T(sectionsSegment) = U*/
  /*T(iterateur) = U*/
  /*T(sectionCourante) = U*/
  /*T(categorie) = U*/
  /*T(i) = U*/
  /*T(tmp_1) = U*/
  /*T(tmp_2) = U*/
  /*T(tmp_3) = U*/
  /*T(tmp_4) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(repartirSectionsAllouables) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:1401*/
  nbSegments = objet->nbSegments;
  /*sid:1401*/
  /*T(nbSegments) = G(objet)*/
  
  /*sid:1402*/
  iterateur = objet->iterateur;
  /*sid:1402*/
  /*T(iterateur) = G(objet)*/
  
  if (nbSegments != 0U) {/*sid:1405*/
    sectionsSegment = (SectionEDL ***)calloc(nbSegments, sizeof(SectionEDL **));
    /*sid:1405*/
    /*T(sectionsSegment) = G(objet)*/
    }
  
  /*sid:1407*/
  i = 0U;
  /*sid:1407*/
  /*T(sectionsSegment) = G(objet)*/
  
  /*sid:1408*/
  while (i != nbSegments) {*(sectionsSegment + i) = (SectionEDL **)calloc(
                           (segments + i)->nbSections, sizeof(SectionEDL *));
    (segments + i)->sections = *(sectionsSegment + i);
    i ++;}
  
  /*sid:1408*/
  /*T(i) = G(objet)*/
  
  /*sid:1415*/
  i = 0U;
  /*sid:1415*/
  /*T(i) = U*/
  
  /*sid:1416*/
  while (i != nbSegments) {if ((segments + i)->type & 1U) {demarrerIterObjet(
                                                           iterateur,
                                                           INSTRUCTIONS);
                             while (1) {tmp_1 = finIterObjet(iterateur);
                               if (tmp_1) {break;}
                               
                               sectionCourante = sectionCouranteIterObjet(
                               iterateur);
                               categorie = categorieSection(sectionCourante);
                               if ((int )categorie != (int )INSTRUCTIONS) {break;}
                               
                               *(*(sectionsSegment + i)) = sectionCourante;
                               (*(sectionsSegment + i)) ++;
                               avancerIterObjet(iterateur);}
                             }
    
    if ((segments + i)->type & 2U) {demarrerIterObjet(iterateur,
                                                      DONNEES_INITIALISEES);
      while (1) {tmp_2 = finIterObjet(iterateur);
        if (tmp_2) {break;}
        
        sectionCourante = sectionCouranteIterObjet(iterateur);
        categorie = categorieSection(sectionCourante);
        if ((int )categorie != (int )DONNEES_INITIALISEES) {break;}
        
        *(*(sectionsSegment + i)) = sectionCourante;
        (*(sectionsSegment + i)) ++;
        avancerIterObjet(iterateur);}
      }
    
    if ((segments + i)->type & 4U) {demarrerIterObjet(iterateur,
                                                      DONNEES_LECTURE_SEULE);
      while (1) {tmp_3 = finIterObjet(iterateur);
        if (tmp_3) {break;}
        
        sectionCourante = sectionCouranteIterObjet(iterateur);
        categorie = categorieSection(sectionCourante);
        if ((int )categorie != (int )DONNEES_LECTURE_SEULE) {break;}
        
        *(*(sectionsSegment + i)) = sectionCourante;
        (*(sectionsSegment + i)) ++;
        avancerIterObjet(iterateur);}
      }
    
    if ((segments + i)->type & 8U) {demarrerIterObjet(iterateur,
                                                      DONNEES_NON_INITIALISEES);
      while (1) {tmp_4 = finIterObjet(iterateur);
        if (tmp_4) {break;}
        
        sectionCourante = sectionCouranteIterObjet(iterateur);
        categorie = categorieSection(sectionCourante);
        if ((int )categorie != (int )DONNEES_NON_INITIALISEES) {break;}
        
        *(*(sectionsSegment + i)) = sectionCourante;
        (*(sectionsSegment + i)) ++;
        avancerIterObjet(iterateur);}
      }
    
    i ++;}
  
  /*sid:1416*/
  /*T(sectionCourante) = G(objet)*/
  /*T(categorie) = G(objet)*/
  /*T(i) = G(objet)*/
  /*T(tmp_1) = G(objet)*/
  /*T(tmp_2) = G(objet)*/
  /*T(tmp_3) = G(objet)*/
  /*T(tmp_4) = G(objet)*/
  
  free((void *)sectionsSegment);
  /*sid:3488*/
  return;
  /*sid:3488*/
  /*T(repartirSectionsAllouables) = U*/
  }

}
static void fusionnerSegments(SegmentEDL *segments , unsigned int *nbSegments ) 
{ 
  
  /*sid:3489*/
  return;
  /*sid:3489*/
  /*T(segments) = G(segments)*/
  /*T(nbSegments) = G(nbSegments)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(fusionnerSegments) = U*/
  

}
static void verifierChevauchementSegments(SegmentEDL *segments ,
                                          unsigned int nbSegments ) 
{ 
  
  /*sid:3490*/
  return;
  /*sid:3490*/
  /*T(segments) = G(segments)*/
  /*T(nbSegments) = G(nbSegments)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(verifierChevauchementSegments) = U*/
  

}
void ouvrirTableChaines(struct StructSectionEDL *section ) ;
void creerTableChaines(struct StructSectionEDL *section , unsigned int nbMax ) ;
void copierContenuChaines(struct StructSectionEDL *tableSource ,
                          struct StructSectionEDL *tableCible ) ;
void cloreTableChaines(struct StructSectionEDL *section ) ;
void fermerTableChaines(struct StructSectionEDL *section ) ;
void fusionnerTableChaines(struct StructSectionEDL *sectionSource ,
                           struct StructSectionEDL *sectionCible ) ;
unsigned int tailleTableChaines(struct StructSectionEDL *section ) ;
void ouvrirSectionProgramme(struct StructSectionEDL *section ) ;
void creerSectionProgramme(struct StructSectionEDL *section ,
                           unsigned int tailleMax ) ;
void cloreSectionProgramme(struct StructSectionEDL *section ) ;
void fermerSectionProgramme(struct StructSectionEDL *section ) ;
void fusionnerSectionProgramme(struct StructSectionEDL *sectionSource ,
                               struct StructSectionEDL *sectionCible ) ;
unsigned int tailleSectionProgramme(struct StructSectionEDL *section ) ;
void initialiserOuvertureSection(SectionEDL *section ,
                                 struct StructObjetEDL *objet ,
                                 size_t index_0 ) ;
void ouvrirSection(SectionEDL *section ) ;
void creerSection(SectionEDL *section , struct StructObjetEDL *objet ,
                  SectionEDL *sectionReference , unsigned int tailleMax ,
                  unsigned int alignement_0 ) ;
void partagerSection(SectionEDL *section , struct StructObjetEDL *objet ) ;
void copierContenuSection(SectionEDL *sectionSource ,
                          SectionEDL *sectionCible ) ;
void fusionnerSection(SectionEDL *sectionSource , SectionEDL *sectionCible ) ;
void initialiserClotureSection(SectionEDL *section ) ;
void cloreSection(SectionEDL *section ) ;
void fermerSection(SectionEDL *section ) ;
unsigned int tailleSection(SectionEDL *section ) ;
void afficherSection(SectionEDL *section ) ;
void afficherTitreSections(void) ;
void afficherInterligneSections(void) ;
void creerAutreSection(struct StructSectionEDL *section ,
                       unsigned int tailleMax ) ;
void cloreAutreSection(struct StructSectionEDL *section ) ;
void fermerAutreSection(struct StructSectionEDL *section ) ;
void fusionnerAutreSection(struct StructSectionEDL *sectionSource ,
                           struct StructSectionEDL *sectionCible ) ;
unsigned int tailleAutreSection(struct StructSectionEDL *section ) ;
void initialiserOuvertureSection(SectionEDL *section ,
                                 struct StructObjetEDL *objet ,
                                 size_t index_0 ) 
{ Elf *elf ;
  Elf_Scn *descripteurLibelf ;
  Elf32_Shdr *descripteurElf ;
  Elf_Data *descripteurContenu ;
  SectionEDL *tableNomsSection ;
  unsigned int indexNomSection ;
  
  {/*sid:1493*/
  elf = objet->elf;
  /*sid:1493*/
  /*T(section) = G(section)*/
  /*T(objet) = G(objet)*/
  /*T(index_0) = G(index_0)*/
  /*T(elf) = G(objet)*/
  /*T(descripteurLibelf) = U*/
  /*T(descripteurElf) = U*/
  /*T(descripteurContenu) = U*/
  /*T(tableNomsSection) = U*/
  /*T(indexNomSection) = U*/
  /*T(initialiserOuvertureSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(index_0) + G(section) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  /*sid:1494*/
  section->objetParent = objet;
  /*sid:1494*/
  /*T(section) = G(objet) + G(section)*/
  
  section->parentInitial = (struct StructObjetEDL *)((void *)0);
  section->type = descripteurElf->sh_type;
  section->flags = descripteurElf->sh_flags;
  section->alignement = descripteurElf->sh_addralign;
  section->tailleElement = descripteurElf->sh_entsize;
  section->contenuElf = descripteurContenu->d_buf;
  section->tailleContenuElf = descripteurElf->sh_size;
  /*sid:1502*/
  section->indexElf = index_0;
  /*sid:1502*/
  /*T(section) = G(index_0) + G(objet) + G(section)*/
  
  section->descripteurElf = descripteurElf;
  section->descripteurLibelf = descripteurLibelf;
  section->descripteurContenu = descripteurContenu;
  /*sid:1506*/
  tableNomsSection = (section->objetParent)->tableNomsSection;
  /*sid:1506*/
  /*T(tableNomsSection) = G(index_0) + G(objet) + G(section)*/
  
  if (section != tableNomsSection) {/*sid:1509*/
    indexNomSection = (section->descripteurElf)->sh_name;
    /*sid:1509*/
    /*T(indexNomSection) = G(index_0) + G(objet) + G(section)*/
    
    extraireChaineSelonIndex(tableNomsSection, indexNomSection, & section->nom);}
  
  /*sid:3491*/
  return;
  /*sid:3491*/
  /*T(indexNomSection) = G(index_0) + G(objet) + G(section)*/
  /*T(initialiserOuvertureSection) = U*/
  }

}
void ouvrirSection(SectionEDL *section ) 
{ SectionEDL *tableNomsSection ;
  unsigned int indexNomSection ;
  
  {/*sid:1513*/
  switch ((int )section->type) {case 1: 
  case 8: ;
  ouvrirSectionProgramme(section);
  break;
  case 3: ;
  ouvrirTableChaines(section);
  break;
  case 2: ;
  ouvrirTableSymboles(section);
  break;
  case 9: ;
  ouvrirTableTranslation(section);
  break;
  default: ;
  break;}
  
  /*sid:1513*/
  /*T(ouvrirSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(tableNomsSection) = U*/
  /*T(indexNomSection) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  /*sid:1528*/
  tableNomsSection = (section->objetParent)->tableNomsSection;
  /*sid:1528*/
  /*T(tableNomsSection) = G(section)*/
  
  if (section == tableNomsSection) {/*sid:1531*/
    indexNomSection = (section->descripteurElf)->sh_name;
    /*sid:1531*/
    /*T(indexNomSection) = G(section)*/
    
    extraireChaineSelonIndex(tableNomsSection, indexNomSection, & section->nom);}
  
  /*sid:3492*/
  return;
  /*sid:3492*/
  /*T(ouvrirSection) = U*/
  /*T(indexNomSection) = G(section)*/
  }

}
void creerSection(SectionEDL *section , struct StructObjetEDL *objet ,
                  SectionEDL *sectionReference , unsigned int tailleMax ,
                  unsigned int alignement_0 ) 
{ SectionEDL *tableNomsSection ;
  SectionEDL *tableChaines ;
  SectionEDL *tableSymboles ;
  SectionEDL *sectionCode ;
  int tmp ;
  
  {/*sid:1535*/
  section->objetParent = objet;
  /*sid:1535*/
  /*T(creerSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(alignement_0) + G(sectionReference) + G(section) + G(objet) + G(tailleMax) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(objet) + G(section)*/
  /*T(objet) = G(objet)*/
  /*T(sectionReference) = G(sectionReference)*/
  /*T(tailleMax) = G(tailleMax)*/
  /*T(alignement_0) = G(alignement_0)*/
  /*T(tableNomsSection) = U*/
  /*T(tableChaines) = U*/
  /*T(tableSymboles) = U*/
  /*T(sectionCode) = U*/
  /*T(tmp) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  section->parentInitial = (struct StructObjetEDL *)((void *)0);
  /*sid:1537*/
  section->type = sectionReference->type;
  /*sid:1537*/
  /*T(section) = G(sectionReference) + G(objet) + G(section)*/
  
  section->flags = sectionReference->flags;
  if (alignement_0 == 0U)
  {/*sid:1541*/
  section->alignement = sectionReference->alignement;
  /*sid:1541*/
  /*T(section) = G(alignement_0) + G(sectionReference) + G(objet) + G(section)*/
  }
  else {/*sid:1542*/
  section->alignement = alignement_0;
  /*sid:1542*/
  /*T(section) = G(alignement_0) + G(sectionReference) + G(objet) + G(section)*/
  }
  
  section->tailleElement = sectionReference->tailleElement;
  section->adresse = 0UL;
  section->contenuElf = (void *)0;
  section->tailleContenuElf = 0U;
  switch ((int )section->type) {case 1: 
  case 8: ;
  creerSectionProgramme(section, tailleMax);
  break;
  case 3: ;
  /*sid:1552*/
  creerTableChaines(section, tailleMax);
  /*sid:1552*/
  /*T(section) = G(tailleMax) + G(alignement_0) + G(sectionReference) + G(objet) + G(section)*/
  
  break;
  /*sid:1554*/
  case 2: 
  tableChaines = (sectionReference->tableSymboles)->tableChaines;
  /*sid:1554*/
  /*T(tableChaines) = G(alignement_0) + G(sectionReference) + G(objet) + G(section)*/
  
  /*sid:1555*/
  creerTableSymboles(section, tableChaines->sectionImage, tailleMax);
  /*sid:1555*/
  /*T(section) = G(tailleMax) + G(alignement_0) + G(sectionReference) + G(objet) + G(section)*/
  
  break;
  /*sid:1557*/
  case 9: 
  tableSymboles = (sectionReference->tableTranslation)->tableSymboles;
  /*sid:1557*/
  /*T(tableSymboles) = G(alignement_0) + G(sectionReference) + G(objet) + G(section)*/
  
  /*sid:1558*/
  sectionCode = (sectionReference->tableTranslation)->sectionCode;
  /*sid:1558*/
  /*T(sectionCode) = G(alignement_0) + G(sectionReference) + G(objet) + G(section)*/
  
  creerTableTranslation(section, tableSymboles->sectionImage,
                        sectionCode->sectionImage, tailleMax);
  break;
  default: ;
  creerAutreSection(section, tailleMax);
  /*sid:1563*/
  break;
  /*sid:1563*/
  /*T(section) = G(tailleMax) + G(alignement_0) + G(sectionReference) + G(objet) + G(section)*/
  /*T(tableChaines) = G(alignement_0) + G(sectionReference) + G(objet) + G(section)*/
  /*T(tableSymboles) = G(alignement_0) + G(sectionReference) + G(objet) + G(section)*/
  /*T(sectionCode) = G(alignement_0) + G(sectionReference) + G(objet) + G(section)*/
  }
  
  /*sid:1564*/
  tmp = strcmp((char const   *)(sectionReference->nom)->chaine, ".shstrtab");
  /*sid:1564*/
  /*T(section) = G(tailleMax) + G(alignement_0) + G(sectionReference) + G(objet) + G(section)*/
  /*T(tableChaines) = G(alignement_0) + G(sectionReference) + G(objet) + G(section)*/
  /*T(tableSymboles) = G(alignement_0) + G(sectionReference) + G(objet) + G(section)*/
  /*T(sectionCode) = G(alignement_0) + G(sectionReference) + G(objet) + G(section)*/
  /*T(tmp) = G(sectionReference)*/
  
  if (tmp == 0)
  {ajouterChaine(section, (sectionReference->nom)->chaine, 0U, 0U,
                 & section->nom);
  /*sid:1567*/
  objet->tableNomsSection = section;
  /*sid:1567*/
  /*T(objet) = G(sectionReference) + G(tailleMax) + G(alignement_0) + G(section) + G(objet)*/
  }
  else {/*sid:1568*/
  tableNomsSection = (section->objetParent)->tableNomsSection;
  /*sid:1568*/
  /*T(tableNomsSection) = G(section) + G(objet) + G(alignement_0) + G(tailleMax) + G(sectionReference)*/
  
  /*sid:1569*/
  ajouterChaine(tableNomsSection, (sectionReference->nom)->chaine, 0U, 0U,
                & section->nom);
  /*sid:1569*/
  /*T(objet) = G(sectionReference) + G(tailleMax) + G(alignement_0) + G(section) + G(objet)*/
  }
  
  /*sid:3493*/
  return;
  /*sid:3493*/
  /*T(creerSection) = U*/
  /*T(tableNomsSection) = G(section) + G(objet) + G(alignement_0) + G(tailleMax) + G(sectionReference)*/
  }

}
void partagerSection(SectionEDL *section , struct StructObjetEDL *objet ) 
{ 
  
  {/*sid:1571*/
  section->parentInitial = section->objetParent;
  /*sid:1571*/
  /*T(partagerSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objet) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(objet) = G(objet)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  /*sid:1572*/
  section->objetParent = objet;
  /*sid:1572*/
  /*T(section) = G(objet) + G(section)*/
  
  section->indexElf = 0U;
  section->descripteurLibelf = (Elf_Scn *)((void *)0);
  section->descripteurContenu = (Elf_Data *)((void *)0);
  section->descripteurElf = (Elf32_Shdr *)((void *)0);
  /*sid:3494*/
  return;
  /*sid:3494*/
  /*T(partagerSection) = U*/
  }

}
void copierContenuSection(SectionEDL *sectionSource ,
                          SectionEDL *sectionCible ) 
{ 
  
  {/*sid:1578*/
  switch ((int )sectionSource->type) {case 3: ;
  /*sid:1580*/
  copierContenuChaines(sectionSource, sectionCible);
  /*sid:1580*/
  /*T(sectionCible) = G(sectionSource) + G(sectionCible)*/
  
  break;
  case 2: ;
  copierContenuSymboles(sectionSource, sectionCible);
  break;
  case 9: ;
  copierContenuTranslation(sectionSource, sectionCible);
  break;
  /*sid:1588*/
  case 8: 
  sectionCible->tailleContenuElf = sectionSource->tailleContenuElf;
  /*sid:1588*/
  /*T(sectionCible) = G(sectionSource) + G(sectionCible)*/
  
  break;
  default: ;
  /*sid:1591*/
  sectionCible->tailleContenuElf = sectionSource->tailleContenuElf;
  /*sid:1591*/
  /*T(sectionCible) = G(sectionSource) + G(sectionCible)*/
  
  memcpy((void *)sectionCible->contenuElf,
         (void const   *)sectionSource->contenuElf,
         sectionCible->tailleContenuElf);
  break;}
  
  /*sid:1578*/
  /*T(copierContenuSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(sectionCible) + G(sectionSource) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(sectionSource) = G(sectionSource)*/
  /*T(sectionCible) = G(sectionCible)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  /*sid:3495*/
  return;
  /*sid:3495*/
  /*T(copierContenuSection) = U*/
  /*T(sectionCible) = G(sectionSource) + G(sectionCible)*/
  }

}
void fusionnerSection(SectionEDL *sectionSource , SectionEDL *sectionCible ) 
{ unsigned int type ;
  
  {/*sid:1596*/
  type = sectionSource->type;
  /*sid:1596*/
  /*T(fusionnerSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(sectionCible) + G(sectionSource) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(sectionSource) = G(sectionSource)*/
  /*T(sectionCible) = G(sectionCible)*/
  /*T(type) = G(sectionSource)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  switch ((int )type) {case 1: 
  case 8: ;
  /*sid:1599*/
  fusionnerSectionProgramme(sectionSource, sectionCible);
  /*sid:1599*/
  /*T(sectionSource) = G(sectionCible) + G(sectionSource)*/
  /*T(sectionCible) = G(sectionSource) + G(sectionCible)*/
  
  break;
  case 3: ;
  /*sid:1602*/
  fusionnerTableChaines(sectionSource, sectionCible);
  /*sid:1602*/
  /*T(sectionCible) = G(sectionSource) + G(sectionCible)*/
  
  break;
  case 2: ;
  fusionnerTableSymboles(sectionSource, sectionCible);
  break;
  case 9: ;
  fusionnerTableTranslation(sectionSource, sectionCible);
  break;
  default: ;
  /*sid:1611*/
  fusionnerAutreSection(sectionSource, sectionCible);
  /*sid:1611*/
  /*T(sectionCible) = G(sectionSource) + G(sectionCible)*/
  
  /*sid:1612*/
  break;
  /*sid:1612*/
  /*T(sectionSource) = G(sectionCible) + G(sectionSource)*/
  }
  
  /*sid:3496*/
  return;
  /*sid:3496*/
  /*T(fusionnerSection) = U*/
  /*T(sectionSource) = G(sectionCible) + G(sectionSource)*/
  /*T(sectionCible) = G(sectionSource) + G(sectionCible)*/
  }

}
void initialiserClotureSection(SectionEDL *section ) 
{ 
  
  /*sid:3497*/
  return;
  /*sid:3497*/
  /*T(initialiserClotureSection) = U*/
  /*T(section) = G(section)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  

}
void cloreSection(SectionEDL *section ) 
{ Elf32_Shdr *descripteurElf ;
  Elf_Data *descripteurContenu ;
  unsigned long position ;
  int tmp ;
  
  {/*sid:1615*/
  switch ((int )section->type) {case 1: 
  case 8: ;
  cloreSectionProgramme(section);
  break;
  case 3: ;
  cloreTableChaines(section);
  break;
  case 2: ;
  cloreTableSymboles(section);
  break;
  case 9: ;
  cloreTableTranslation(section);
  break;
  default: ;
  cloreAutreSection(section);
  break;}
  
  /*sid:1615*/
  /*T(cloreSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(descripteurElf) = U*/
  /*T(descripteurContenu) = U*/
  /*T(position) = U*/
  /*T(tmp) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  if ((section->objetParent)->type == (TypeObjetEDL )2) {/*sid:1633*/
    tmp = (int )categorieSection(section);
    /*sid:1633*/
    /*T(tmp) = G(section)*/
    
    switch (tmp) {case INSTRUCTIONS: 
    case DONNEES_INITIALISEES: 
    case DONNEES_LECTURE_SEULE: 
    case DONNEES_NON_INITIALISEES: 
    break;
    default: ;
    /*sid:1637*/
    position = alignement((section->objetParent)->tailleFichier,
                          section->alignement);
    /*sid:1637*/
    /*T(position) = G(section)*/
    
    section->position = position;
    position += (unsigned long )section->tailleContenuElf;
    (section->objetParent)->tailleFichier = position;
    break;}
    }
  
  /*sid:1643*/
  descripteurContenu = section->descripteurContenu;
  /*sid:1643*/
  /*T(descripteurContenu) = G(section)*/
  /*T(position) = G(section)*/
  /*T(tmp) = G(section)*/
  
  descripteurContenu->d_size = section->tailleContenuElf;
  descripteurContenu->d_align = section->alignement;
  descripteurContenu->d_version = 1U;
  if ((section->objetParent)->type == (TypeObjetEDL )2) {descripteurContenu->d_off = 0L;}
  
  /*sid:1651*/
  descripteurElf = section->descripteurElf;
  /*sid:1651*/
  /*T(descripteurElf) = G(section)*/
  
  descripteurElf->sh_name = (section->nom)->indexElf;
  descripteurElf->sh_type = section->type;
  descripteurElf->sh_flags = section->flags;
  descripteurElf->sh_entsize = section->tailleElement;
  descripteurElf->sh_addr = (unsigned int )section->adresse;
  if ((section->objetParent)->type == (TypeObjetEDL )2) {descripteurElf->sh_offset = (unsigned int )section->position;
    descripteurElf->sh_size = section->tailleContenuElf;
    descripteurElf->sh_addralign = section->alignement;}
  
  /*sid:3498*/
  return;
  /*sid:3498*/
  /*T(cloreSection) = G(section)*/
  }

}
void fermerSection(SectionEDL *section ) 
{ 
  
  {/*sid:1664*/
  switch ((int )section->type) {case 1: 
  case 8: ;
  fermerSectionProgramme(section);
  break;
  case 3: ;
  fermerTableChaines(section);
  break;
  case 2: ;
  fermerTableSymboles(section);
  break;
  case 9: ;
  fermerTableTranslation(section);
  break;
  default: ;
  fermerAutreSection(section);
  break;}
  
  /*sid:1664*/
  /*T(fermerSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  /*sid:3499*/
  return;
  /*sid:3499*/
  /*T(fermerSection) = U*/
  }

}
unsigned int tailleSection(SectionEDL *section ) 
{ unsigned int tmp ;
  unsigned int tmp_0 ;
  unsigned int tmp_1 ;
  unsigned int tmp_2 ;
  unsigned int tmp_3 ;
  unsigned int __retres ;
  
  {/*sid:1681*/
  switch ((int )section->type) {/*sid:1682*/
  case 1: 
  case 8: 
  tmp = tailleSectionProgramme(section);
  /*sid:1682*/
  /*T(tmp) = G(section)*/
  
  /*sid:1683*/
  __retres = tmp;
  /*sid:1683*/
  /*T(__retres) = G(section)*/
  
  goto return_label;
  /*sid:1684*/
  break;
  /*sid:1684*/
  /*T(tailleSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(tmp) = U*/
  /*T(tmp_0) = U*/
  /*T(tmp_1) = U*/
  /*T(tmp_2) = U*/
  /*T(tmp_3) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = U*/
  
  /*sid:1685*/
  case 3: 
  tmp_0 = tailleTableChaines(section);
  /*sid:1685*/
  /*T(tmp_0) = G(section)*/
  
  /*sid:1686*/
  __retres = tmp_0;
  /*sid:1686*/
  /*T(__retres) = G(section)*/
  
  goto return_label;
  /*sid:1687*/
  break;
  /*sid:1687*/
  /*T(tailleSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(tmp) = U*/
  /*T(tmp_0) = U*/
  /*T(tmp_1) = U*/
  /*T(tmp_2) = U*/
  /*T(tmp_3) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = U*/
  
  /*sid:1688*/
  case 2: 
  tmp_1 = tailleTableSymboles(section);
  /*sid:1688*/
  /*T(tmp_1) = G(section)*/
  
  /*sid:1689*/
  __retres = tmp_1;
  /*sid:1689*/
  /*T(__retres) = G(section)*/
  
  goto return_label;
  /*sid:1690*/
  break;
  /*sid:1690*/
  /*T(tailleSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(tmp) = U*/
  /*T(tmp_0) = U*/
  /*T(tmp_1) = U*/
  /*T(tmp_2) = U*/
  /*T(tmp_3) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = U*/
  
  /*sid:1691*/
  case 9: 
  tmp_2 = tailleTableTranslation(section);
  /*sid:1691*/
  /*T(tmp_2) = G(section)*/
  
  /*sid:1692*/
  __retres = tmp_2;
  /*sid:1692*/
  /*T(__retres) = G(section)*/
  
  goto return_label;
  /*sid:1693*/
  break;
  /*sid:1693*/
  /*T(tailleSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(tmp) = U*/
  /*T(tmp_0) = U*/
  /*T(tmp_1) = U*/
  /*T(tmp_2) = U*/
  /*T(tmp_3) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = U*/
  
  default: ;
  /*sid:1695*/
  tmp_3 = tailleAutreSection(section);
  /*sid:1695*/
  /*T(tmp_3) = G(section)*/
  
  /*sid:1696*/
  __retres = tmp_3;
  /*sid:1696*/
  /*T(__retres) = G(section)*/
  
  /*sid:3504*/
  goto return_label;
  /*sid:3504*/
  /*T(tmp) = G(section)*/
  /*T(tmp_0) = G(section)*/
  /*T(tmp_1) = G(section)*/
  /*T(tmp_2) = G(section)*/
  
  /*sid:1697*/
  break;
  /*sid:1697*/
  /*T(tailleSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(tmp) = U*/
  /*T(tmp_0) = U*/
  /*T(tmp_1) = U*/
  /*T(tmp_2) = U*/
  /*T(tmp_3) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = U*/
  }
  
  /*sid:1681*/
  /*T(tailleSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(tmp) = U*/
  /*T(tmp_0) = U*/
  /*T(tmp_1) = U*/
  /*T(tmp_2) = U*/
  /*T(tmp_3) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = U*/
  
  __retres = 0U;
  /*sid:3505*/
  return_label: /* CIL Label */ 
  return (__retres);
  /*sid:3505*/
  /*T(tailleSection) = G(section)*/
  /*T(tmp) = G(section)*/
  /*T(tmp_0) = G(section)*/
  /*T(tmp_1) = G(section)*/
  /*T(tmp_2) = G(section)*/
  /*T(tmp_3) = G(section)*/
  /*T(__retres) = G(section)*/
  }

}
void afficherSection(SectionEDL *section ) 
{ 
  
  /*sid:3506*/
  return;
  /*sid:3506*/
  /*T(afficherSection) = U*/
  /*T(section) = G(section)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  

}
void afficherTitreSections(void) 
{ 
  
  {/*sid:1700*/
  printf((char const   *)"index |     nom              |  type      | ");
  /*sid:1700*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(afficherTitreSections) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  printf((char const   *)"taille | flags | align | link | info\n");
  printf((char const   *)"------|----------------------|------------|-");
  printf((char const   *)"-------|-------|-------|------|-----\n");
  /*sid:3507*/
  return;
  /*sid:3507*/
  /*T(afficherTitreSections) = U*/
  }

}
void afficherInterligneSections(void) 
{ 
  
  {/*sid:1705*/
  printf((char const   *)"------|----------------------|------------|-");
  /*sid:1705*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(afficherInterligneSections) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  printf((char const   *)"-------|-------|-------|------|-----\n");
  /*sid:3508*/
  return;
  /*sid:3508*/
  /*T(afficherInterligneSections) = U*/
  }

}
unsigned long alignement(unsigned long adresse , unsigned int alignement_0 ) 
{ unsigned long __retres ;
  
  {/*sid:1708*/
  __retres = ((adresse + (unsigned long )alignement_0) - 1UL) & (unsigned long )(~ (
             alignement_0 - 1U));
  /*sid:1708*/
  /*T(alignement) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(alignement_0) + G(adresse) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(adresse) = G(adresse)*/
  /*T(alignement_0) = G(alignement_0)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = G(adresse) + G(alignement_0)*/
  
  /*sid:3509*/
  return (__retres);
  /*sid:3509*/
  /*T(alignement) = G(adresse) + G(alignement_0)*/
  }

}
void creerSectionCode(struct StructSectionEDL *section ,
                      unsigned int tailleMax ) ;
void cloreSectionCode(struct StructSectionEDL *section ) ;
void fermerSectionCode(struct StructSectionEDL *section ) ;
void fusionnerSectionCode(struct StructSectionEDL *sectionSource ,
                          struct StructSectionEDL *sectionCible ) ;
void ouvrirSectionProgramme(struct StructSectionEDL *section ) 
{ 
  
  {/*sid:1709*/
  section->sectionProgramme = (struct StructSectionProgrammeEDL *)calloc(
  1U, sizeof(SectionProgrammeEDL ));
  /*sid:1709*/
  /*T(ouvrirSectionProgramme) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  (section->sectionProgramme)->decalageContenu = 0U;
  /*sid:3510*/
  return;
  /*sid:3510*/
  /*T(ouvrirSectionProgramme) = U*/
  }

}
void creerSectionProgramme(struct StructSectionEDL *section ,
                           unsigned int tailleMax ) 
{ 
  
  {/*sid:1712*/
  section->sectionProgramme = (struct StructSectionProgrammeEDL *)calloc(
  1U, sizeof(SectionProgrammeEDL ));
  /*sid:1712*/
  /*T(creerSectionProgramme) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(tailleMax) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(tailleMax) = G(tailleMax)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  (section->sectionProgramme)->decalageContenu = 0U;
  if (section->type == (TypeSectionEDL )1) {creerSectionCode(section,
                                                             tailleMax);}
  
  /*sid:3511*/
  return;
  /*sid:3511*/
  /*T(creerSectionProgramme) = U*/
  }

}
void cloreSectionProgramme(struct StructSectionEDL *section ) 
{ Elf_Data *descripteurContenu ;
  
  {/*sid:1719*/
  switch ((int )section->type) {case 1: ;
  cloreSectionCode(section);
  break;
  case 8: ;
  cloreSectionVide(section);
  break;
  default: ;
  break;}
  
  /*sid:1719*/
  /*T(cloreSectionProgramme) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(descripteurContenu) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  /*sid:1728*/
  descripteurContenu = section->descripteurContenu;
  /*sid:1728*/
  /*T(descripteurContenu) = G(section)*/
  
  descripteurContenu->d_type = ELF_T_BYTE;
  /*sid:3512*/
  return;
  /*sid:3512*/
  /*T(cloreSectionProgramme) = U*/
  }

}
void fermerSectionProgramme(struct StructSectionEDL *section ) 
{ 
  
  {/*sid:1732*/
  if (section->sectionProgramme != (void *)0) {free((void *)section->sectionProgramme);
    section->sectionProgramme = (struct StructSectionProgrammeEDL *)((void *)0);}
  
  /*sid:1732*/
  /*T(fermerSectionProgramme) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  if (section->type == (TypeSectionEDL )1) {fermerSectionCode(section);}
  
  /*sid:3513*/
  return;
  /*sid:3513*/
  /*T(fermerSectionProgramme) = U*/
  }

}
void fusionnerSectionProgramme(struct StructSectionEDL *sectionSource ,
                               struct StructSectionEDL *sectionCible ) 
{ unsigned int tailleCible ;
  
  {/*sid:1741*/
  tailleCible = (unsigned int )alignement((unsigned long )sectionCible->tailleContenuElf,
                                          sectionSource->alignement);
  /*sid:1741*/
  /*T(fusionnerSectionProgramme) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(sectionCible) + G(sectionSource) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(sectionSource) = G(sectionSource)*/
  /*T(sectionCible) = G(sectionCible)*/
  /*T(tailleCible) = G(sectionCible) + G(sectionSource)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  /*sid:1742*/
  (sectionSource->sectionProgramme)->decalageContenu = tailleCible;
  /*sid:1742*/
  /*T(sectionSource) = G(sectionCible) + G(sectionSource)*/
  
  /*sid:1743*/
  sectionCible->tailleContenuElf = tailleCible;
  /*sid:1743*/
  /*T(sectionCible) = G(sectionSource) + G(sectionCible)*/
  
  switch ((int )sectionSource->type) {case 1: ;
  fusionnerSectionCode(sectionSource, sectionCible);
  break;
  case 8: ;
  fusionnerSectionVide(sectionSource, sectionCible);
  break;
  default: ;
  break;}
  
  /*sid:3514*/
  return;
  /*sid:3514*/
  /*T(fusionnerSectionProgramme) = U*/
  }

}
unsigned int tailleSectionProgramme(struct StructSectionEDL *section ) 
{ unsigned int __retres ;
  
  {/*sid:1754*/
  __retres = section->tailleContenuElf;
  /*sid:1754*/
  /*T(tailleSectionProgramme) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = G(section)*/
  
  /*sid:3515*/
  return (__retres);
  /*sid:3515*/
  /*T(tailleSectionProgramme) = G(section)*/
  }

}
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
void creerIterObjet(IterateurObjet **iterateur ) ;
void ajouterAIterObjet(IterateurObjet *iterateur ,
                       struct StructSectionEDL *section ) ;
void retirerDeIterObjet(IterateurObjet *iterateur ,
                        struct StructSectionEDL *section ) ;
void fermerIterObjet(IterateurObjet **iterateur ) ;
void ajouterAIterGlobal(struct StructSectionEDL *section ) ;
void demarrerIterGlobalNom(void) ;
void avancerIterGlobalNom(void) ;
unsigned int alignementCourantIterGlobal(void) ;
unsigned int finIterGlobalNom(void) ;
void demarrerIterGlobalSection(void) ;
void avancerIterGlobalSection(void) ;
struct StructSectionEDL *sectionCouranteIterGlobal(void) ;
unsigned int finIterGlobalSection(void) ;
void ouvrirObjet(ObjetEDL *objet , unsigned int lectureEcriture ) ;
void creerObjet(ObjetEDL *objetCible , ObjetEDL *objetSource ,
                TypeObjetEDL type , unsigned int nbSections ) ;
void copierObjet(ObjetEDL *objetSource , ObjetEDL *objetCible ,
                 TypeObjetEDL type ) ;
void dupliquerObjet(ObjetEDL *objetSource , ObjetEDL *objetCible ,
                    TypeObjetEDL type ) ;
void fusionnerObjet(ObjetEDL *objetCible ) ;
void implanterObjet(ObjetEDL *objet ) ;
void cloreObjet(ObjetEDL *objet ) ;
void fermerObjet(ObjetEDL *objet ) ;
void afficherObjet(ObjetEDL *objet ) ;
unsigned int sontCompatibles(ObjetEDL *objet1 , ObjetEDL *objet2 ) ;
unsigned int ontMemeBoutismeHoteObjet(ObjetEDL *objet ) ;
void memoriserNomObjet(ObjetEDL *objet , char *nom ) ;
void memoriserAdresseStack(unsigned long adressePile ) ;
void memoriserNomPointEntree(char *nomSymbole ) ;
void libererNomPointEntree(void) ;
static void ouvrirSections(ObjetEDL *objet ) ;
static void cloreSections(ObjetEDL *objet ) ;
static void fermerSections(ObjetEDL *objet ) ;
static void ajouterSection(ObjetEDL *objet ,
                           struct StructSectionEDL *sectionReference ,
                           unsigned int taille , unsigned int alignement_0 ,
                           struct StructSectionEDL **sectionCible ) ;
static void allouerSection(ObjetEDL *objet ,
                           struct StructSectionEDL **section ) ;
static void supprimerSection(ObjetEDL *objet ,
                             struct StructSectionEDL *section ) ;
static void creerSectionsFusionnees(ObjetEDL *objetCible ) ;
static void fusionnerSections(ObjetEDL *objetCible ) ;
static void resoudreSymbolesCommuns(ObjetEDL *objet ) ;
static void resoudreSymbolesCRT(ObjetEDL *objet ) ;
static void implanterTablesSymboles(ObjetEDL *objet ) ;
static void completerSectionsCode(ObjetEDL *objet ) ;
static void ajouterPile(ObjetEDL *objet ) ;
static void initialiserLibelf(void) ;
static void afficherSections(ObjetEDL *objet ) ;
static void afficherAttributs(ObjetEDL *objet ) ;
static unsigned long adresseStack  = 8388608UL;
static char *nomPtEntree  = (char *)((void *)0);
void ouvrirObjet(ObjetEDL *objet , unsigned int lectureEcriture ) 
{ Elf32_Ehdr *ehdr ;
  
  {/*sid:1755*/
  initialiserLibelf();
  /*sid:1755*/
  /*T(ouvrirObjet) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(lectureEcriture) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(objet) = G(objet)*/
  /*T(lectureEcriture) = G(lectureEcriture)*/
  /*T(ehdr) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  if (lectureEcriture)
  {/*sid:1758*/
  objet->mode = (unsigned int )ELF_C_RDWR_1;
  /*sid:1758*/
  /*T(objet) = G(lectureEcriture) + G(objet)*/
  }
  else {/*sid:1759*/
  objet->mode = (unsigned int )ELF_C_READ_1;
  /*sid:1759*/
  /*T(objet) = G(lectureEcriture) + G(objet)*/
  }
  
  if (objet->elf == (Elf *)((void *)0)) {/*sid:1762*/
    printf((char const   *)"%s%s%s\n", "erreur : lecture image ELF (",
           objet->nom, ") impossible");
    /*sid:1762*/
    /*T(journal) = U*/
    /*T(premiereFois) = U*/
    /*T(sectionBss) = U*/
    /*T(adresseText) = U*/
    /*T(adresseData) = U*/
    /*T(adresseRodata) = U*/
    /*T(adresseBss) = U*/
    /*T(adresseStack) = U*/
    /*T(nomPtEntree) = U*/
    /*T(boutismeHote) = U*/
    /*T(iterateurGlobal) = U*/
    /*T(objets) = U*/
    /*T(copieSuperficielle) = U*/
    /*T(objets_0) = U*/
    /*T(nbFichiersDonnees) = U*/
    
    exit(1);}
  
  objet->ehdr = ehdr;
  if ((int )ehdr->e_type == 2) {/*sid:1768*/
    printf((char const   *)"%s%s%s\n",
           "erreur : ouverture d\'un objet executable (", objet->nom,
           ") interdite");
    /*sid:1768*/
    /*T(journal) = U*/
    /*T(premiereFois) = U*/
    /*T(sectionBss) = U*/
    /*T(adresseText) = U*/
    /*T(adresseData) = U*/
    /*T(adresseRodata) = U*/
    /*T(adresseBss) = U*/
    /*T(adresseStack) = U*/
    /*T(nomPtEntree) = U*/
    /*T(boutismeHote) = U*/
    /*T(iterateurGlobal) = U*/
    /*T(objets) = U*/
    /*T(copieSuperficielle) = U*/
    /*T(objets_0) = U*/
    /*T(nbFichiersDonnees) = U*/
    
    exit(1);}
  
  objet->boutisme = (unsigned int )ehdr->e_ident[5];
  objet->classe = (unsigned int )ehdr->e_ident[4];
  objet->systeme = (unsigned int )ehdr->e_ident[7];
  objet->processeur = (unsigned int )ehdr->e_machine;
  objet->version = ehdr->e_version;
  objet->flags = ehdr->e_flags;
  objet->type = (unsigned int )ehdr->e_type;
  objet->estCopie = 0U;
  objet->tailleFichier = 0UL;
  ouvrirSections(objet);
  /*sid:3516*/
  return;
  /*sid:3516*/
  /*T(ouvrirObjet) = G(lectureEcriture) + G(objet)*/
  }

}
void creerObjet(ObjetEDL *objetCible , ObjetEDL *objetSource ,
                TypeObjetEDL type , unsigned int nbSections ) 
{ SectionEDL *tableNomsSectionCible ;
  SectionEDL *tableNomsSectionSource ;
  unsigned int tmp_0 ;
  
  {/*sid:1782*/
  objetCible->mode = (unsigned int )ELF_C_WRITE_1;
  /*sid:1782*/
  /*T(creerObjet) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(nbSections) + G(objetSource) + G(objetCible) + G(type) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(objetCible) = G(objetCible)*/
  /*T(objetSource) = G(objetSource)*/
  /*T(type) = G(type)*/
  /*T(nbSections) = G(nbSections)*/
  /*T(tableNomsSectionCible) = U*/
  /*T(tableNomsSectionSource) = U*/
  /*T(tmp_0) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  /*sid:1783*/
  objetCible->boutisme = objetSource->boutisme;
  /*sid:1783*/
  /*T(objetCible) = G(objetSource) + G(objetCible)*/
  
  objetCible->classe = objetSource->classe;
  objetCible->systeme = objetSource->systeme;
  /*sid:1786*/
  objetCible->type = type;
  /*sid:1786*/
  /*T(objetCible) = G(type) + G(objetSource) + G(objetCible)*/
  
  objetCible->processeur = objetSource->processeur;
  objetCible->version = objetSource->version;
  objetCible->flags = objetSource->flags;
  objetCible->estCopie = 0U;
  objetCible->nbSections = 0U;
  objetCible->tailleFichier = 0UL;
  objetCible->sections = (struct StructSectionEDL **)calloc(nbSections,
                                                            sizeof(SectionEDL *));
  /*sid:1794*/
  objetCible->nbMax = nbSections;
  /*sid:1794*/
  /*T(objetCible) = G(nbSections) + G(type) + G(objetSource) + G(objetCible)*/
  
  creerIterObjet(& objetCible->iterateur);
  /*sid:1796*/
  tableNomsSectionSource = objetSource->tableNomsSection;
  /*sid:1796*/
  /*T(tableNomsSectionSource) = G(objetSource)*/
  
  /*sid:1797*/
  tmp_0 = tailleSection(tableNomsSectionSource);
  /*sid:1797*/
  /*T(tmp_0) = G(objetSource)*/
  
  /*sid:1798*/
  ajouterSection(objetCible, tableNomsSectionSource, tmp_0, 0U,
                 & tableNomsSectionCible);
  /*sid:1798*/
  /*T(tableNomsSectionCible) = G(objetCible) + G(type) + G(nbSections) + G(objetSource)*/
  /*T(tableNomsSectionSource) = G(nbSections) + G(type) + G(objetCible) + G(objetSource)*/
  
  objetCible->tableNomsSection = tableNomsSectionCible;
  /*sid:3517*/
  return;
  /*sid:3517*/
  /*T(creerObjet) = U*/
  }

}
void copierObjet(ObjetEDL *objetSource , ObjetEDL *objetCible ,
                 TypeObjetEDL type ) 
{ SectionEDL **sections ;
  unsigned int nbSections ;
  unsigned int i ;
  
  {/*sid:1801*/
  objetCible->estCopie = 1U;
  /*sid:1801*/
  /*T(copierObjet) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(type) + G(objetSource) + G(objetCible) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(objetSource) = G(objetSource)*/
  /*T(objetCible) = G(objetCible)*/
  /*T(type) = G(type)*/
  /*T(sections) = U*/
  /*T(nbSections) = U*/
  /*T(i) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  objetCible->mode = (unsigned int )ELF_C_WRITE_1;
  objetCible->elf = (Elf *)((void *)0);
  objetCible->ehdr = (Elf32_Ehdr *)((void *)0);
  /*sid:1805*/
  objetCible->boutisme = objetSource->boutisme;
  /*sid:1805*/
  /*T(objetCible) = G(objetSource) + G(objetCible)*/
  
  objetCible->classe = objetSource->classe;
  objetCible->systeme = objetSource->systeme;
  /*sid:1808*/
  objetCible->type = type;
  /*sid:1808*/
  /*T(objetCible) = G(type) + G(objetSource) + G(objetCible)*/
  
  objetCible->processeur = objetSource->processeur;
  objetCible->version = objetSource->version;
  objetCible->flags = objetSource->flags;
  objetCible->tailleFichier = objetSource->tailleFichier;
  objetCible->pointEntree = objetSource->pointEntree;
  objetCible->sections = objetSource->sections;
  objetCible->nbSections = objetSource->nbSections;
  objetCible->nbMax = objetSource->nbMax;
  /*sid:1817*/
  sections = objetCible->sections;
  /*sid:1817*/
  /*T(sections) = G(type) + G(objetSource) + G(objetCible)*/
  
  /*sid:1818*/
  nbSections = objetCible->nbSections;
  /*sid:1818*/
  /*T(nbSections) = G(type) + G(objetSource) + G(objetCible)*/
  
  i = 0U;
  /*sid:1820*/
  while (i != nbSections) {partagerSection(*(sections + i), objetCible);
    i ++;}
  
  /*sid:1820*/
  /*T(i) = G(type) + G(objetSource) + G(objetCible)*/
  
  objetCible->tableNomsSection = objetSource->tableNomsSection;
  objetCible->nbSegments = objetSource->nbSegments;
  objetCible->segments = objetSource->segments;
  objetCible->iterateur = objetSource->iterateur;
  /*sid:3518*/
  return;
  /*sid:3518*/
  /*T(copierObjet) = U*/
  }

}
void dupliquerObjet(ObjetEDL *objetSource , ObjetEDL *objetCible ,
                    TypeObjetEDL type ) 
{ SectionEDL *sectionSource ;
  SectionEDL *sectionCible ;
  IterateurObjet *iterateurSource ;
  IterateurObjet *iterateurCible ;
  unsigned int tmp ;
  unsigned int tmp_0 ;
  unsigned int tmp_1 ;
  
  {/*sid:1831*/
  creerObjet(objetCible, objetSource, type, objetSource->nbMax);
  /*sid:1831*/
  /*T(dupliquerObjet) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(type) + G(objetSource) + G(objetCible) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(objetSource) = G(objetSource)*/
  /*T(objetCible) = G(objetSource) + G(type) + G(objetCible)*/
  /*T(type) = G(type)*/
  /*T(sectionSource) = U*/
  /*T(sectionCible) = U*/
  /*T(iterateurSource) = U*/
  /*T(iterateurCible) = U*/
  /*T(tmp) = U*/
  /*T(tmp_0) = U*/
  /*T(tmp_1) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  /*sid:1832*/
  iterateurCible = objetCible->iterateur;
  /*sid:1832*/
  /*T(iterateurCible) = G(objetSource) + G(type) + G(objetCible)*/
  
  /*sid:1833*/
  iterateurSource = objetSource->iterateur;
  /*sid:1833*/
  /*T(iterateurSource) = G(objetSource)*/
  
  demarrerIterObjet(iterateurSource, INSTRUCTIONS);
  /*sid:1835*/
  while (1) {tmp_0 = finIterObjet(iterateurSource);
    if (tmp_0) {break;}
    
    /*sid:1839*/
    sectionSource = sectionCouranteIterObjet(iterateurSource);
    /*sid:1839*/
    /*T(sectionSource) = G(objetSource)*/
    
    if (sectionSource != objetSource->tableNomsSection) {tmp = tailleSection(
                                                         sectionSource);
      /*sid:1843*/
      ajouterSection(objetCible, sectionSource, tmp, 0U, & sectionCible);
      /*sid:1843*/
      /*T(sectionSource) = G(type) + G(objetCible) + G(objetSource)*/
      }
    
    /*sid:1845*/
    avancerIterObjet(iterateurSource);
    /*sid:1845*/
    /*T(sectionSource) = G(objetCible) + G(type) + G(objetSource)*/
    }
  
  /*sid:1835*/
  /*T(sectionSource) = G(objetCible) + G(type) + G(objetSource)*/
  /*T(sectionCible) = G(objetCible) + G(type) + G(objetSource)*/
  /*T(tmp) = G(objetSource)*/
  /*T(tmp_0) = G(objetSource)*/
  
  demarrerIterObjet(iterateurSource, INSTRUCTIONS);
  demarrerIterObjet(iterateurCible, INSTRUCTIONS);
  /*sid:1848*/
  while (1) {tmp_1 = finIterObjet(iterateurSource);
    if (tmp_1) {break;}
    
    /*sid:1852*/
    sectionSource = sectionCouranteIterObjet(iterateurSource);
    /*sid:1852*/
    /*T(sectionSource) = G(objetSource)*/
    
    sectionCible = sectionCouranteIterObjet(iterateurCible);
    if (sectionSource != objetSource->tableNomsSection) {copierContenuSection(
                                                         sectionSource,
                                                         sectionCible);}
    
    avancerIterObjet(iterateurSource);
    /*sid:1859*/
    avancerIterObjet(iterateurCible);
    /*sid:1859*/
    /*T(sectionSource) = G(objetCible) + G(type) + G(objetSource)*/
    }
  
  /*sid:1848*/
  /*T(tmp_1) = G(objetSource)*/
  
  /*sid:3519*/
  return;
  /*sid:3519*/
  /*T(dupliquerObjet) = U*/
  }

}
void fusionnerObjet(ObjetEDL *objetCible ) 
{ 
  
  {/*sid:1861*/
  creerSectionsFusionnees(objetCible);
  /*sid:1861*/
  /*T(fusionnerObjet) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objetCible) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(objetCible) = G(iterateurGlobal) + G(objetCible)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  fusionnerSections(objetCible);
  /*sid:3520*/
  return;
  /*sid:3520*/
  /*T(fusionnerObjet) = U*/
  }

}
void implanterObjet(ObjetEDL *objet ) 
{ 
  
  {/*sid:1864*/
  if (! objet->estCopie)
  {/*sid:1865*/
  resoudreSymbolesCommuns(objet);
  /*sid:1865*/
  /*T(sectionBss) = G(objet) + G(sectionBss)*/
  
  /*sid:1866*/
  creerSegments(objet);
  /*sid:1866*/
  /*T(journal) = G(adresseData) + G(adresseRodata) + G(adresseText) + G(adresseBss) + G(journal)*/
  /*T(objet) = G(adresseRodata) + G(adresseData) + G(adresseBss) + G(adresseText) + G(objet)*/
  /*T(premiereFois) = G(adresseData) + G(adresseRodata) + G(adresseText) + G(adresseBss) + G(premiereFois)*/
  /*T(sectionBss) = G(adresseData) + G(adresseRodata) + G(adresseText) + G(adresseBss) + G(objet) + G(sectionBss)*/
  /*T(adresseText) = G(adresseRodata) + G(adresseData) + G(adresseBss) + G(adresseText)*/
  /*T(adresseData) = G(adresseBss) + G(adresseText) + G(adresseRodata) + G(adresseData)*/
  /*T(adresseRodata) = G(adresseData) + G(adresseText) + G(adresseBss) + G(adresseRodata)*/
  /*T(adresseBss) = G(adresseData) + G(adresseRodata) + G(adresseText) + G(adresseBss)*/
  /*T(adresseStack) = G(adresseData) + G(adresseRodata) + G(adresseText) + G(adresseBss) + G(adresseStack)*/
  /*T(nomPtEntree) = G(adresseData) + G(adresseRodata) + G(adresseText) + G(adresseBss) + G(nomPtEntree)*/
  /*T(boutismeHote) = G(adresseData) + G(adresseRodata) + G(adresseText) + G(adresseBss) + G(boutismeHote)*/
  /*T(iterateurGlobal) = G(adresseData) + G(adresseRodata) + G(adresseText) + G(adresseBss) + G(iterateurGlobal)*/
  /*T(objets) = G(adresseData) + G(adresseRodata) + G(adresseText) + G(adresseBss) + G(objets)*/
  /*T(copieSuperficielle) = G(adresseData) + G(adresseRodata) + G(adresseText) + G(adresseBss) + G(copieSuperficielle)*/
  /*T(objets_0) = G(adresseData) + G(adresseRodata) + G(adresseText) + G(adresseBss) + G(objets_0)*/
  /*T(nbFichiersDonnees) = G(adresseData) + G(adresseRodata) + G(adresseText) + G(adresseBss) + G(nbFichiersDonnees)*/
  
  implanterSectionsAllouables(objet);
  resoudreSymbolesCRT(objet);
  implanterTablesSymboles(objet);
  completerSectionsCode(objet);
  ajouterPile(objet);}
  else {/*sid:1872*/
  printf((char const   *)"%s%s%s%s%s\n", "panique (implanterObjet) ! : ",
         "l\'objet ", objet->nom,
         " est une copie (superficielle) d\'un autre objet ",
         "et ne peut etre implante");
  /*sid:1872*/
  /*T(journal) = U*/
  /*T(premiereFois) = U*/
  /*T(sectionBss) = U*/
  /*T(adresseText) = U*/
  /*T(adresseData) = U*/
  /*T(adresseRodata) = U*/
  /*T(adresseBss) = U*/
  /*T(adresseStack) = U*/
  /*T(nomPtEntree) = U*/
  /*T(boutismeHote) = U*/
  /*T(iterateurGlobal) = U*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = U*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = U*/
  
  exit(1);}
  
  /*sid:1864*/
  /*T(implanterObjet) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(objet) = G(objet)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  /*sid:3521*/
  return;
  /*sid:3521*/
  /*T(implanterObjet) = G(objet)*/
  }

}
void cloreObjet(ObjetEDL *objet ) 
{ Elf32_Ehdr *ehdr ;
  off_t tailleFichier ;
  
  {/*sid:1876*/
  if (objet->mode != (ModeOuvertureEDL )ELF_C_WRITE_1) {/*sid:1877*/
    printf((char const   *)"%s%s%s\n", "erreur : l\'objet ", objet->nom,
           " est ouvert en lecture (cloture impossible)");
    /*sid:1877*/
    /*T(journal) = U*/
    /*T(premiereFois) = U*/
    /*T(sectionBss) = U*/
    /*T(adresseText) = U*/
    /*T(adresseData) = U*/
    /*T(adresseRodata) = U*/
    /*T(adresseBss) = U*/
    /*T(adresseStack) = U*/
    /*T(nomPtEntree) = U*/
    /*T(boutismeHote) = U*/
    /*T(iterateurGlobal) = U*/
    /*T(objets) = U*/
    /*T(copieSuperficielle) = U*/
    /*T(objets_0) = U*/
    /*T(nbFichiersDonnees) = U*/
    
    exit(1);}
  
  /*sid:1876*/
  /*T(cloreObjet) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(objet) = G(objet)*/
  /*T(ehdr) = U*/
  /*T(tailleFichier) = U*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  initialiserLibelf();
  if (objet->elf == (void *)0) {/*sid:1883*/
    printf((char const   *)"%s%s%s\n", "erreur : creation image ELF (",
           objet->nom, ") impossible");
    /*sid:1883*/
    /*T(journal) = U*/
    /*T(premiereFois) = U*/
    /*T(sectionBss) = U*/
    /*T(adresseText) = U*/
    /*T(adresseData) = U*/
    /*T(adresseRodata) = U*/
    /*T(adresseBss) = U*/
    /*T(adresseStack) = U*/
    /*T(nomPtEntree) = U*/
    /*T(boutismeHote) = U*/
    /*T(iterateurGlobal) = U*/
    /*T(objets) = U*/
    /*T(copieSuperficielle) = U*/
    /*T(objets_0) = U*/
    /*T(nbFichiersDonnees) = U*/
    
    exit(1);}
  
  /*sid:1886*/
  ehdr = objet->ehdr;
  /*sid:1886*/
  /*T(ehdr) = G(objet)*/
  
  cloreSections(objet);
  ehdr->e_ident[5] = (unsigned char )objet->boutisme;
  ehdr->e_ident[4] = (unsigned char )objet->classe;
  ehdr->e_ident[7] = (unsigned char )objet->systeme;
  ehdr->e_type = (unsigned short )objet->type;
  ehdr->e_machine = (unsigned short )objet->processeur;
  ehdr->e_version = objet->version;
  ehdr->e_flags = objet->flags;
  ehdr->e_shstrndx = (unsigned short )(objet->tableNomsSection)->indexElf;
  if (objet->type == (TypeObjetEDL )2) {cloreSegments(objet);
    ehdr->e_entry = (unsigned int )objet->pointEntree;
    ehdr->e_phoff = sizeof(Elf32_Ehdr );
    ehdr->e_shoff = (unsigned int )objet->tailleFichier;}
  
  if (tailleFichier == (off_t )-1) {/*sid:1905*/
    printf((char const   *)"%s%s%s\n", "erreur : ecriture image ELF (",
           objet->nom, ") impossible");
    /*sid:1905*/
    /*T(journal) = U*/
    /*T(premiereFois) = U*/
    /*T(sectionBss) = U*/
    /*T(adresseText) = U*/
    /*T(adresseData) = U*/
    /*T(adresseRodata) = U*/
    /*T(adresseBss) = U*/
    /*T(adresseStack) = U*/
    /*T(nomPtEntree) = U*/
    /*T(boutismeHote) = U*/
    /*T(iterateurGlobal) = U*/
    /*T(objets) = U*/
    /*T(copieSuperficielle) = U*/
    /*T(objets_0) = U*/
    /*T(nbFichiersDonnees) = U*/
    
    exit(1);}
  
  /*sid:3522*/
  return;
  /*sid:3522*/
  /*T(cloreObjet) = G(objet)*/
  }

}
void fermerObjet(ObjetEDL *objet ) 
{ 
  
  {/*sid:1909*/
  if (! objet->estCopie) {fermerSections(objet);
    if (objet->type == (TypeObjetEDL )2) {fermerSegments(objet);}
    
    if (objet->iterateur != (void *)0) {fermerIterObjet(& objet->iterateur);}
    }
  
  /*sid:1909*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(objet) = G(objet)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(fermerObjet) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  if (objet->nom != (void *)0) {free((void *)objet->nom);}
  
  /*sid:3523*/
  return;
  /*sid:3523*/
  /*T(fermerObjet) = U*/
  }

}
void afficherObjet(ObjetEDL *objet ) 
{ 
  
  {/*sid:1925*/
  printf((char const   *)"\n");
  /*sid:1925*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(objet) = G(objet)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(afficherObjet) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:1926*/
  afficherAttributs(objet);
  /*sid:1926*/
  /*T(journal) = U*/
  /*T(premiereFois) = U*/
  /*T(sectionBss) = U*/
  /*T(adresseText) = U*/
  /*T(adresseData) = U*/
  /*T(adresseRodata) = U*/
  /*T(adresseBss) = U*/
  /*T(adresseStack) = U*/
  /*T(nomPtEntree) = U*/
  /*T(boutismeHote) = U*/
  /*T(iterateurGlobal) = U*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = U*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = U*/
  
  printf((char const   *)"\n");
  afficherSections(objet);
  printf((char const   *)"\n");
  /*sid:3524*/
  return;
  /*sid:3524*/
  /*T(afficherObjet) = U*/
  }

}
void ajouterSectionBss(ObjetEDL *objet ,
                       struct StructSectionEDL **sectionResultat ) 
{ SectionEDL *sectionReference ;
  SectionEDL *sectionBss_0 ;
  
  {/*sid:1931*/
  sectionReference = (SectionEDL *)calloc(1U, sizeof(SectionEDL ));
  /*sid:1931*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(objet) = G(objet)*/
  /*T(sectionResultat) = G(sectionResultat)*/
  /*T(sectionReference) = U*/
  /*T(sectionBss_0) = U*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(ajouterSectionBss) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(sectionResultat) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  sectionReference->nom = creationChaine((char *)".bss", 0U, 0U);
  sectionReference->type = 8U;
  sectionReference->flags = 1U;
  sectionReference->alignement = 1U;
  sectionReference->tailleElement = 0U;
  /*sid:1937*/
  ajouterSection(objet, sectionReference, 0U, 0U, & sectionBss_0);
  /*sid:1937*/
  /*T(sectionReference) = G(objet)*/
  /*T(sectionBss_0) = G(objet)*/
  
  libererChaine(& sectionReference->nom);
  free((void *)sectionReference);
  if (sectionResultat != (void *)0) {/*sid:1942*/
    *sectionResultat = sectionBss_0;
    /*sid:1942*/
    /*T(sectionResultat) = G(objet) + G(sectionResultat)*/
    }
  
  /*sid:3525*/
  return;
  /*sid:3525*/
  /*T(sectionResultat) = G(objet) + G(sectionResultat)*/
  /*T(ajouterSectionBss) = U*/
  }

}
struct StructSectionEDL *sectionSelonIndex(ObjetEDL *objet ,
                                           unsigned int index_0 ) 
{ SectionEDL **sections ;
  unsigned int nbSections ;
  unsigned int i ;
  struct StructSectionEDL *__retres ;
  
  {/*sid:1946*/
  if (index_0 == 0U)
  {/*sid:1947*/
  __retres = (struct StructSectionEDL *)((void *)0);
  /*sid:1947*/
  /*T(__retres) = G(index_0)*/
  
  goto return_label;}
  else {if (index_0 >= 65280U) {/*sid:1950*/
          __retres = (struct StructSectionEDL *)((void *)0);
          /*sid:1950*/
          /*T(__retres) = G(index_0)*/
          
          goto return_label;}
  }
  
  /*sid:1946*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(objet) = G(objet)*/
  /*T(index_0) = G(index_0)*/
  /*T(sections) = U*/
  /*T(nbSections) = U*/
  /*T(i) = U*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = U*/
  /*T(sectionSelonIndex) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(index_0) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:1952*/
  sections = objet->sections;
  /*sid:1952*/
  /*T(sections) = G(objet) + G(index_0)*/
  
  /*sid:1954*/
  nbSections = objet->nbSections;
  /*sid:1954*/
  /*T(nbSections) = G(objet) + G(index_0)*/
  
  /*sid:1956*/
  i = 0U;
  /*sid:1956*/
  /*T(i) = G(index_0)*/
  
  /*sid:1957*/
  while (i < nbSections) {if ((*(sections + i))->indexElf == index_0) {/*sid:1963*/
                            __retres = *(sections + i);
                            /*sid:1963*/
                            /*T(__retres) = G(objet) + G(index_0)*/
                            
                            goto return_label;}
    
    i ++;}
  
  /*sid:1957*/
  /*T(i) = G(objet) + G(index_0)*/
  
  /*sid:1966*/
  printf((char const   *)"%s%s%d%s%s\n", "panique (sectionSelonIndex) ! : ",
         "aucune section d\'index ", index_0, " n\'existe dans l\'objet ",
         objet->nom);
  /*sid:1966*/
  /*T(journal) = U*/
  /*T(premiereFois) = U*/
  /*T(sectionBss) = U*/
  /*T(adresseText) = U*/
  /*T(adresseData) = U*/
  /*T(adresseRodata) = U*/
  /*T(adresseBss) = U*/
  /*T(adresseStack) = U*/
  /*T(nomPtEntree) = U*/
  /*T(boutismeHote) = U*/
  /*T(iterateurGlobal) = U*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = U*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = U*/
  
  exit(1);
  /*sid:3529*/
  return_label: /* CIL Label */ 
  return (__retres);
  /*sid:3529*/
  /*T(sections) = G(objet) + G(index_0)*/
  /*T(nbSections) = G(objet) + G(index_0)*/
  /*T(i) = G(objet) + G(index_0)*/
  /*T(__retres) = G(objet) + G(index_0)*/
  /*T(sectionSelonIndex) = G(objet) + G(index_0)*/
  }

}
struct StructSectionEDL *sectionSelonNomEtType(ObjetEDL *objet , char *nom ,
                                               unsigned int type ) 
{ SectionEDL **sections ;
  unsigned int nbSections ;
  unsigned int i ;
  int tmp ;
  struct StructSectionEDL *__retres ;
  
  {/*sid:1968*/
  sections = objet->sections;
  /*sid:1968*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(objet) = G(objet)*/
  /*T(nom) = G(nom)*/
  /*T(type) = G(type)*/
  /*T(sections) = G(objet)*/
  /*T(nbSections) = U*/
  /*T(i) = U*/
  /*T(tmp) = U*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = U*/
  /*T(sectionSelonNomEtType) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(type) + G(objet) + G(nom) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:1970*/
  nbSections = objet->nbSections;
  /*sid:1970*/
  /*T(nbSections) = G(objet)*/
  
  i = 0U;
  /*sid:1973*/
  while (i < nbSections) {if (nom == (void *)0) {goto _L;}
                          else {tmp = strcmp((char const   *)((*(sections + i))->nom)->chaine,
                                             (char const   *)nom);
                          if (tmp == 0) {_L: /* CIL Label */ ;
                            if ((*(sections + i))->type == type) {break;}
                            }
                          }
    
    i ++;}
  
  /*sid:1973*/
  /*T(i) = G(objet)*/
  /*T(tmp) = G(nom) + G(objet)*/
  
  if (i < nbSections)
  {/*sid:1990*/
  __retres = *(sections + i);
  /*sid:1990*/
  /*T(__retres) = G(objet)*/
  
  goto return_label;}
  else {/*sid:1991*/
  __retres = (struct StructSectionEDL *)((void *)0);
  /*sid:1991*/
  /*T(__retres) = G(objet)*/
  
  goto return_label;}
  
  /*sid:3532*/
  return_label: /* CIL Label */ 
  return (__retres);
  /*sid:3532*/
  /*T(sectionSelonNomEtType) = G(objet)*/
  }

}
unsigned int sontCompatibles(ObjetEDL *objet1 , ObjetEDL *objet2 ) 
{ int tmp ;
  unsigned int __retres ;
  
  {/*sid:1993*/
  if (objet1->type == objet2->type)
  {if (objet1->boutisme == objet2->boutisme)
   {if (objet1->classe == objet2->classe)
    {if (objet1->systeme == objet2->systeme)
     {if (objet1->processeur == objet2->processeur)
      {if (objet1->version == objet2->version)
       {if (objet1->flags == objet2->flags)
        {/*sid:2006*/
        tmp = 1;
        /*sid:2006*/
        /*T(tmp) = G(objet1) + G(objet2)*/
        }
        else {/*sid:2007*/
        tmp = 0;
        /*sid:2007*/
        /*T(tmp) = G(objet1) + G(objet2)*/
        }
       }
       else {/*sid:2008*/
       tmp = 0;
       /*sid:2008*/
       /*T(tmp) = G(objet1) + G(objet2)*/
       }
      }
      else {/*sid:2009*/
      tmp = 0;
      /*sid:2009*/
      /*T(tmp) = G(objet1) + G(objet2)*/
      }
     }
     else {/*sid:2010*/
     tmp = 0;
     /*sid:2010*/
     /*T(tmp) = G(objet1) + G(objet2)*/
     }
    }
    else {/*sid:2011*/
    tmp = 0;
    /*sid:2011*/
    /*T(tmp) = G(objet1) + G(objet2)*/
    }
   }
   else {/*sid:2012*/
   tmp = 0;
   /*sid:2012*/
   /*T(tmp) = G(objet1) + G(objet2)*/
   }
  }
  else {/*sid:2013*/
  tmp = 0;
  /*sid:2013*/
  /*T(tmp) = G(objet1) + G(objet2)*/
  }
  
  /*sid:1993*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(objet1) = G(objet1)*/
  /*T(objet2) = G(objet2)*/
  /*T(tmp) = U*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = U*/
  /*T(sontCompatibles) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objet2) + G(objet1) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:2014*/
  __retres = (unsigned int )tmp;
  /*sid:2014*/
  /*T(__retres) = G(objet1) + G(objet2)*/
  
  /*sid:3533*/
  return (__retres);
  /*sid:3533*/
  /*T(sontCompatibles) = G(objet1) + G(objet2)*/
  }

}
static unsigned int boutismeHote  = 0U;
unsigned int ontMemeBoutismeHoteObjet(ObjetEDL *objet ) 
{ unsigned int i ;
  unsigned char *pi ;
  unsigned int __retres ;
  
  {/*sid:2015*/
  i = 305419896U;
  /*sid:2015*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(objet) = G(objet)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(i) = U*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(pi) = U*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = U*/
  /*T(ontMemeBoutismeHoteObjet) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  pi = (unsigned char *)(& i);
  if (boutismeHote == 0U) {if ((int )*pi == 18) {boutismeHote = 2U;}
                           else {if ((int )*pi == 120) {boutismeHote = 1U;}
                                 else {/*sid:2026*/
                                 printf((char const   *)"%s%s\n",
                                        "panique (ontMemeBoutismeHoteObjet) ! : ",
                                        "boutisme hote inconnu");
                                 /*sid:2026*/
                                 /*T(journal) = U*/
                                 /*T(premiereFois) = U*/
                                 /*T(sectionBss) = U*/
                                 /*T(adresseText) = U*/
                                 /*T(adresseData) = U*/
                                 /*T(adresseRodata) = U*/
                                 /*T(adresseBss) = U*/
                                 /*T(adresseStack) = U*/
                                 /*T(nomPtEntree) = U*/
                                 /*T(boutismeHote) = U*/
                                 /*T(iterateurGlobal) = U*/
                                 /*T(objets) = U*/
                                 /*T(copieSuperficielle) = U*/
                                 /*T(objets_0) = U*/
                                 /*T(nbFichiersDonnees) = U*/
                                 
                                 exit(1);}
                           }
    }
  
  /*sid:2029*/
  __retres = (unsigned int )(objet->boutisme == boutismeHote);
  /*sid:2029*/
  /*T(__retres) = G(objet) + G(boutismeHote)*/
  
  /*sid:3534*/
  return (__retres);
  /*sid:3534*/
  /*T(ontMemeBoutismeHoteObjet) = G(objet) + G(boutismeHote)*/
  }

}
void memoriserNomObjet(ObjetEDL *objet , char *nom ) 
{ size_t tmp ;
  
  {/*sid:2030*/
  tmp = strlen((char const   *)nom);
  /*sid:2030*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(objet) = G(objet)*/
  /*T(nom) = G(nom)*/
  /*T(tmp) = G(nom)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(memoriserNomObjet) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(nom) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  objet->nom = (char *)malloc(tmp + (size_t )1);
  strcpy((char *)objet->nom, (char const   *)nom);
  /*sid:3535*/
  return;
  /*sid:3535*/
  /*T(memoriserNomObjet) = U*/
  }

}
void memoriserAdresseStack(unsigned long adressePile ) 
{ 
  
  {/*sid:2034*/
  adresseStack = adressePile;
  /*sid:2034*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adressePile) = G(adressePile)*/
  /*T(adresseStack) = G(adressePile)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(memoriserAdresseStack) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(adressePile) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3536*/
  return;
  /*sid:3536*/
  /*T(memoriserAdresseStack) = U*/
  }

}
void memoriserNomPointEntree(char *nomSymbole ) 
{ size_t tmp ;
  
  {/*sid:2036*/
  libererNomPointEntree();
  /*sid:2036*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(nomSymbole) = G(nomSymbole)*/
  /*T(tmp) = U*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(memoriserNomPointEntree) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(nomSymbole) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:2037*/
  tmp = strlen((char const   *)nomSymbole);
  /*sid:2037*/
  /*T(tmp) = G(nomSymbole)*/
  
  /*sid:2038*/
  nomPtEntree = (char *)malloc(tmp + (size_t )1);
  /*sid:2038*/
  /*T(nomPtEntree) = G(nomSymbole)*/
  
  strcpy((char *)nomPtEntree, (char const   *)nomSymbole);
  /*sid:3537*/
  return;
  /*sid:3537*/
  /*T(memoriserNomPointEntree) = U*/
  }

}
void libererNomPointEntree(void) 
{ 
  
  {/*sid:2042*/
  if (nomPtEntree != (void *)0) {free((void *)nomPtEntree);}
  
  /*sid:2042*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(libererNomPointEntree) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3538*/
  return;
  /*sid:3538*/
  /*T(libererNomPointEntree) = U*/
  }

}
char *nomPointEntree(void) 
{ 
  
  /*sid:2046*/
  return (nomPtEntree);
  /*sid:2046*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(nomPointEntree) = G(nomPtEntree)*/
  

}
static void ouvrirSections(ObjetEDL *objet ) 
{ SectionEDL **sections ;
  unsigned int nbSections ;
  IterateurObjet *iterateur ;
  size_t indexNomsSections ;
  size_t indexCourant ;
  SectionEDL *tableNomsSection ;
  SectionEDL *sectionCourante ;
  unsigned int i ;
  unsigned int tmp_1 ;
  
  {/*sid:2047*/
  nbSections = (unsigned int )((int )(objet->ehdr)->e_shnum - 1);
  /*sid:2047*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(objet) = G(objet)*/
  /*T(sections) = U*/
  /*T(nbSections) = G(objet)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(iterateur) = U*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(indexNomsSections) = U*/
  /*T(indexCourant) = U*/
  /*T(tableNomsSection) = U*/
  /*T(sectionCourante) = U*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(i) = U*/
  /*T(tmp_1) = U*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(ouvrirSections) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:2048*/
  sections = (SectionEDL **)calloc(nbSections, sizeof(SectionEDL *));
  /*sid:2048*/
  /*T(sections) = G(objet)*/
  
  i = 0U;
  /*sid:2050*/
  while (i != nbSections) {*(sections + i) = (SectionEDL *)calloc(1U,
                                                                  sizeof(SectionEDL ));
    i ++;}
  
  /*sid:2050*/
  /*T(i) = G(objet)*/
  
  objet->sections = sections;
  objet->nbSections = nbSections;
  objet->nbMax = nbSections;
  creerIterObjet(& objet->iterateur);
  /*sid:2060*/
  iterateur = objet->iterateur;
  /*sid:2060*/
  /*T(iterateur) = G(objet)*/
  
  objet->tableNomsSection = *(sections + 0);
  /*sid:2062*/
  tableNomsSection = objet->tableNomsSection;
  /*sid:2062*/
  /*T(tableNomsSection) = G(objet)*/
  
  /*sid:2063*/
  indexNomsSections = (unsigned int )(objet->ehdr)->e_shstrndx;
  /*sid:2063*/
  /*T(indexNomsSections) = G(objet)*/
  
  initialiserOuvertureSection(tableNomsSection, objet, indexNomsSections);
  ajouterAIterObjet(iterateur, tableNomsSection);
  ouvrirSection(tableNomsSection);
  ajouterAIterGlobal(tableNomsSection);
  /*sid:2068*/
  i = 1U;
  /*sid:2068*/
  /*T(i) = U*/
  
  indexCourant = 1U;
  /*sid:2070*/
  while (indexCourant != nbSections + 1U) {if (indexCourant != indexNomsSections) {
                                             initialiserOuvertureSection(
                                             *(sections + i), objet,
                                             indexCourant);
                                             ajouterAIterObjet(iterateur,
                                                               *(sections + i));
                                             i ++;}
    
    indexCourant += (size_t )1;}
  
  /*sid:2070*/
  /*T(indexCourant) = G(objet)*/
  /*T(i) = G(objet)*/
  
  demarrerIterObjet(iterateur, INSTRUCTIONS);
  /*sid:2082*/
  while (1) {tmp_1 = finIterObjet(iterateur);
    if (tmp_1) {break;}
    
    sectionCourante = sectionCouranteIterObjet(iterateur);
    if (sectionCourante != tableNomsSection) {ouvrirSection(sectionCourante);
      ajouterAIterGlobal(sectionCourante);}
    
    avancerIterObjet(iterateur);}
  
  /*sid:2082*/
  /*T(sectionCourante) = G(objet)*/
  /*T(tmp_1) = G(objet)*/
  
  /*sid:3539*/
  return;
  /*sid:3539*/
  /*T(ouvrirSections) = U*/
  }

}
static void cloreSections(ObjetEDL *objet ) 
{ SectionEDL **sections ;
  unsigned int nbSections ;
  IterateurObjet *iterateur ;
  SectionEDL *tableNomsSection ;
  SectionEDL *sectionCourante ;
  unsigned int i ;
  unsigned int tmp ;
  
  {/*sid:2094*/
  sections = objet->sections;
  /*sid:2094*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objet) = G(objet)*/
  /*T(sections) = G(objet)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(nbSections) = U*/
  /*T(iterateur) = U*/
  /*T(tableNomsSection) = U*/
  /*T(sectionCourante) = U*/
  /*T(i) = U*/
  /*T(tmp) = U*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(cloreSections) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:2095*/
  nbSections = objet->nbSections;
  /*sid:2095*/
  /*T(nbSections) = G(objet)*/
  
  i = 0U;
  /*sid:2097*/
  while (i != nbSections) {initialiserClotureSection(*(sections + i));
    i ++;}
  
  /*sid:2097*/
  /*T(i) = G(objet)*/
  
  /*sid:2103*/
  tableNomsSection = objet->tableNomsSection;
  /*sid:2103*/
  /*T(tableNomsSection) = G(objet)*/
  
  cloreSection(tableNomsSection);
  /*sid:2105*/
  iterateur = objet->iterateur;
  /*sid:2105*/
  /*T(iterateur) = G(objet)*/
  
  demarrerIterObjet(iterateur, INSTRUCTIONS);
  /*sid:2107*/
  while (1) {tmp = finIterObjet(iterateur);
    if (tmp) {break;}
    
    sectionCourante = sectionCouranteIterObjet(iterateur);
    if (sectionCourante != tableNomsSection) {cloreSection(sectionCourante);}
    
    avancerIterObjet(iterateur);}
  
  /*sid:2107*/
  /*T(sectionCourante) = G(objet)*/
  /*T(tmp) = G(objet)*/
  
  /*sid:3540*/
  return;
  /*sid:3540*/
  /*T(cloreSections) = U*/
  }

}
static void fermerSections(ObjetEDL *objet ) 
{ SectionEDL **sections ;
  unsigned int nbSections ;
  SectionEDL *tableNomsSection ;
  unsigned int i ;
  
  {/*sid:2118*/
  sections = objet->sections;
  /*sid:2118*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objet) = G(objet)*/
  /*T(sections) = G(objet)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(nbSections) = U*/
  /*T(tableNomsSection) = U*/
  /*T(i) = U*/
  /*T(fermerSections) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:2119*/
  nbSections = objet->nbSections;
  /*sid:2119*/
  /*T(nbSections) = G(objet)*/
  
  /*sid:2120*/
  tableNomsSection = objet->tableNomsSection;
  /*sid:2120*/
  /*T(tableNomsSection) = G(objet)*/
  
  if (sections != (void *)0) {/*sid:2123*/
    i = 0U;
    /*sid:2123*/
    /*T(i) = G(objet)*/
    
    while (i != nbSections) {if (*(sections + i) != tableNomsSection) {
                               fermerSection(*(sections + i));}
      
      i ++;}
    
    fermerSection(tableNomsSection);
    i = 0U;
    while (i != nbSections) {if (*(sections + i) != (void *)0) {free(
                                                                (void *)*(
                                                                sections + i));
                               *(sections + i) = (SectionEDL *)((void *)0);}
      
      i ++;}
    
    free((void *)sections);
    objet->sections = (struct StructSectionEDL **)((void *)0);}
  
  /*sid:3541*/
  return;
  /*sid:3541*/
  /*T(i) = G(objet)*/
  /*T(fermerSections) = U*/
  }

}
static void ajouterSection(ObjetEDL *objet ,
                           struct StructSectionEDL *sectionReference ,
                           unsigned int taille , unsigned int alignement_0 ,
                           struct StructSectionEDL **sectionCible ) 
{ SectionEDL *nouvelleSection ;
  
  {/*sid:2149*/
  allouerSection(objet, & nouvelleSection);
  /*sid:2149*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(objet) = G(objet)*/
  /*T(sectionReference) = G(sectionReference)*/
  /*T(taille) = G(taille)*/
  /*T(alignement_0) = G(alignement_0)*/
  /*T(sectionCible) = G(sectionCible)*/
  /*T(nouvelleSection) = G(objet)*/
  /*T(ajouterSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(sectionCible) + G(taille) + G(objet) + G(sectionReference) + G(alignement_0) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:2150*/
  creerSection(nouvelleSection, objet, sectionReference, taille, alignement_0);
  /*sid:2150*/
  /*T(objet) = G(sectionReference) + G(taille) + G(alignement_0) + G(objet)*/
  /*T(nouvelleSection) = G(alignement_0) + G(taille) + G(sectionReference) + G(objet)*/
  
  ajouterAIterObjet(objet->iterateur, nouvelleSection);
  /*sid:2152*/
  sectionReference->sectionImage = nouvelleSection;
  /*sid:2152*/
  /*T(sectionReference) = G(objet) + G(taille) + G(alignement_0) + G(sectionReference)*/
  
  if (sectionCible != (void *)0) {/*sid:2155*/
    *sectionCible = nouvelleSection;
    /*sid:2155*/
    /*T(sectionCible) = G(alignement_0) + G(taille) + G(sectionReference) + G(objet) + G(sectionCible)*/
    }
  
  /*sid:3542*/
  return;
  /*sid:3542*/
  /*T(sectionCible) = G(objet) + G(sectionReference) + G(taille) + G(alignement_0) + G(sectionCible)*/
  /*T(ajouterSection) = U*/
  }

}
static void allouerSection(ObjetEDL *objet ,
                           struct StructSectionEDL **section ) 
{ SectionEDL **sections ;
  unsigned int nbSections ;
  unsigned int nbMax ;
  
  {/*sid:2158*/
  sections = objet->sections;
  /*sid:2158*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(objet) = G(objet)*/
  /*T(section) = G(section)*/
  /*T(sections) = G(objet)*/
  /*T(nbSections) = U*/
  /*T(nbMax) = U*/
  /*T(allouerSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:2159*/
  nbSections = objet->nbSections;
  /*sid:2159*/
  /*T(nbSections) = G(objet)*/
  
  /*sid:2160*/
  nbMax = objet->nbMax;
  /*sid:2160*/
  /*T(nbMax) = G(objet)*/
  
  if (nbSections == nbMax) {nbMax ++;
    sections = (SectionEDL **)realloc((void *)sections,
                                      nbMax * sizeof(SectionEDL *));
    objet->nbMax = nbMax;
    objet->sections = sections;}
  
  *(sections + nbSections) = (SectionEDL *)calloc(1U, sizeof(SectionEDL ));
  objet->nbSections = nbSections + 1U;
  if (section != (void *)0) {/*sid:2172*/
    *section = *(sections + nbSections);
    /*sid:2172*/
    /*T(section) = G(objet) + G(section)*/
    }
  
  /*sid:3543*/
  return;
  /*sid:3543*/
  /*T(section) = G(objet) + G(section)*/
  /*T(allouerSection) = U*/
  }

}
static void supprimerSection(ObjetEDL *objet ,
                             struct StructSectionEDL *section ) 
{ SectionEDL **sections ;
  unsigned int nbSections ;
  SectionEDL *tableNomsSection ;
  IterateurObjet *iterateur ;
  unsigned int i ;
  
  {/*sid:2175*/
  sections = objet->sections;
  /*sid:2175*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(objet) = G(objet)*/
  /*T(section) = G(section)*/
  /*T(sections) = G(objet)*/
  /*T(nbSections) = U*/
  /*T(tableNomsSection) = U*/
  /*T(iterateur) = U*/
  /*T(i) = U*/
  /*T(supprimerSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:2176*/
  nbSections = objet->nbSections;
  /*sid:2176*/
  /*T(nbSections) = G(objet)*/
  
  /*sid:2177*/
  tableNomsSection = objet->tableNomsSection;
  /*sid:2177*/
  /*T(tableNomsSection) = G(objet)*/
  
  /*sid:2178*/
  iterateur = objet->iterateur;
  /*sid:2178*/
  /*T(iterateur) = G(objet)*/
  
  i = 0U;
  /*sid:2180*/
  while (i != nbSections) {if (*(sections + i) == section) {break;}
    
    i ++;}
  
  /*sid:2180*/
  /*T(i) = G(section) + G(objet)*/
  
  if (i != nbSections)
  {retirerDeIterObjet(iterateur, *(sections + i));
  supprimerChaine(tableNomsSection, (*(sections + i))->nom);
  fermerSection(*(sections + i));
  if (*(sections + i) != (void *)0) {free((void *)*(sections + i));}
  
  /*sid:2198*/
  *(sections + i) = *(sections + (nbSections - 1U));
  /*sid:2198*/
  /*T(sections) = G(section) + G(objet)*/
  
  /*sid:2199*/
  objet->nbSections = nbSections - 1U;
  /*sid:2199*/
  /*T(objet) = G(section) + G(objet)*/
  }
  else {/*sid:2200*/
  printf((char const   *)"%s%s%s%s%s\n", "panique (supprimerSection) ! : ",
         "la section ", (section->nom)->chaine,
         " n\'appartient pas a l\'objet ", objet->nom);
  /*sid:2200*/
  /*T(journal) = U*/
  /*T(premiereFois) = U*/
  /*T(sectionBss) = U*/
  /*T(adresseText) = U*/
  /*T(adresseData) = U*/
  /*T(adresseRodata) = U*/
  /*T(adresseBss) = U*/
  /*T(adresseStack) = U*/
  /*T(nomPtEntree) = U*/
  /*T(boutismeHote) = U*/
  /*T(iterateurGlobal) = U*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = U*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = U*/
  
  exit(1);}
  
  /*sid:3544*/
  return;
  /*sid:3544*/
  /*T(supprimerSection) = G(section) + G(objet)*/
  }

}
static void creerSectionsFusionnees(ObjetEDL *objetCible ) 
{ SectionEDL *sectionSource ;
  SectionEDL *sectionCible ;
  unsigned int tailleMaxCible ;
  unsigned int alignementCourant ;
  unsigned int tmp ;
  unsigned long tmp_0 ;
  unsigned int tmp_1 ;
  unsigned int tmp_2 ;
  unsigned int tmp_3 ;
  int tmp_4 ;
  unsigned int tmp_5 ;
  
  {/*sid:2203*/
  demarrerIterGlobalNom();
  /*sid:2203*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(objetCible) = G(objetCible)*/
  /*T(sectionSource) = U*/
  /*T(sectionCible) = U*/
  /*T(tailleMaxCible) = U*/
  /*T(alignementCourant) = U*/
  /*T(tmp) = U*/
  /*T(tmp_0) = U*/
  /*T(tmp_1) = U*/
  /*T(tmp_2) = U*/
  /*T(tmp_3) = U*/
  /*T(tmp_4) = U*/
  /*T(tmp_5) = U*/
  /*T(creerSectionsFusionnees) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objetCible) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:2204*/
  while (1) {tmp_5 = finIterGlobalNom();
    if (tmp_5) {break;}
    
    demarrerIterGlobalSection();
    /*sid:2209*/
    sectionSource = sectionCouranteIterGlobal();
    /*sid:2209*/
    /*T(sectionSource) = G(iterateurGlobal)*/
    
    tmp_4 = strcmp((char const   *)(sectionSource->nom)->chaine, ".shstrtab");
    if (tmp_4 != 0) {alignementCourant = sectionSource->alignement;
      tailleMaxCible = tailleSection(sectionSource);
      avancerIterGlobalSection();
      while (1) {tmp_2 = finIterGlobalSection();
        if (tmp_2) {break;}
        
        sectionSource = sectionCouranteIterGlobal();
        switch ((int )sectionSource->type) {/*sid:2221*/
        {/*sid:2222*/
         case 3: 
         case 2: 
         case 9: 
         tmp = tailleSection(sectionSource);
         /*sid:2222*/
         /*T(objetCible) = G(iterateurGlobal) + G(objetCible)*/
         /*T(sectionSource) = G(iterateurGlobal)*/
         /*T(sectionCible) = G(objetCible) + G(iterateurGlobal)*/
         /*T(tailleMaxCible) = G(iterateurGlobal)*/
         /*T(alignementCourant) = G(iterateurGlobal)*/
         /*T(tmp) = G(iterateurGlobal)*/
         /*T(tmp_0) = G(iterateurGlobal)*/
         /*T(tmp_1) = G(iterateurGlobal)*/
         /*T(tmp_2) = G(iterateurGlobal)*/
         /*T(tmp_3) = G(iterateurGlobal)*/
         /*T(tmp_4) = G(iterateurGlobal)*/
         /*T(tmp_5) = G(iterateurGlobal)*/
         
         tailleMaxCible += tmp;}
        /*sid:2221*/
        /*T(journal) = G(journal)*/
        /*T(premiereFois) = G(premiereFois)*/
        /*T(sectionBss) = G(sectionBss)*/
        /*T(adresseText) = G(adresseText)*/
        /*T(adresseData) = G(adresseData)*/
        /*T(adresseRodata) = G(adresseRodata)*/
        /*T(adresseBss) = G(adresseBss)*/
        /*T(adresseStack) = G(adresseStack)*/
        /*T(nomPtEntree) = G(nomPtEntree)*/
        /*T(boutismeHote) = G(boutismeHote)*/
        /*T(iterateurGlobal) = G(iterateurGlobal)*/
        /*T(objets) = G(objets)*/
        /*T(copieSuperficielle) = G(copieSuperficielle)*/
        /*T(objets_0) = G(objets_0)*/
        /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
        /*T(objetCible) = G(objetCible)*/
        /*T(sectionSource) = U*/
        /*T(sectionCible) = U*/
        /*T(tailleMaxCible) = U*/
        /*T(alignementCourant) = U*/
        /*T(tmp) = U*/
        /*T(tmp_0) = U*/
        /*T(tmp_1) = U*/
        /*T(tmp_2) = U*/
        /*T(tmp_3) = U*/
        /*T(tmp_4) = U*/
        /*T(tmp_5) = U*/
        /*T(creerSectionsFusionnees) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objetCible) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
        
        break;
        default: ;
        alignementCourant = sectionSource->alignement;
        {tmp_0 = alignement((unsigned long )tailleMaxCible, alignementCourant);
         tmp_1 = tailleSection(sectionSource);
         tailleMaxCible = (unsigned int )(tmp_0 + (unsigned long )tmp_1);}
        break;}
        
        avancerIterGlobalSection();}
      
      alignementCourant = alignementCourantIterGlobal();
      demarrerIterGlobalSection();
      sectionSource = sectionCouranteIterGlobal();
      /*sid:2236*/
      ajouterSection(objetCible, sectionSource, tailleMaxCible,
                     alignementCourant, & sectionCible);
      /*sid:2236*/
      /*T(sectionSource) = G(objetCible) + G(iterateurGlobal)*/
      
      avancerIterGlobalSection();
      while (1) {tmp_3 = finIterGlobalSection();
        if (tmp_3) {break;}
        
        /*sid:2242*/
        sectionSource = sectionCouranteIterGlobal();
        /*sid:2242*/
        /*T(sectionSource) = G(iterateurGlobal)*/
        
        /*sid:2243*/
        sectionSource->sectionImage = sectionCible;
        /*sid:2243*/
        /*T(sectionSource) = G(objetCible) + G(iterateurGlobal)*/
        
        avancerIterGlobalSection();}
      }
    
    /*sid:2246*/
    avancerIterGlobalNom();
    /*sid:2246*/
    /*T(sectionSource) = G(objetCible) + G(iterateurGlobal)*/
    }
  
  /*sid:2204*/
  /*T(objetCible) = G(iterateurGlobal) + G(objetCible)*/
  /*T(sectionSource) = G(objetCible) + G(iterateurGlobal)*/
  /*T(sectionCible) = G(objetCible) + G(iterateurGlobal)*/
  /*T(tailleMaxCible) = G(iterateurGlobal)*/
  /*T(alignementCourant) = G(iterateurGlobal)*/
  /*T(tmp) = G(iterateurGlobal)*/
  /*T(tmp_0) = G(iterateurGlobal)*/
  /*T(tmp_1) = G(iterateurGlobal)*/
  /*T(tmp_2) = G(iterateurGlobal)*/
  /*T(tmp_3) = G(iterateurGlobal)*/
  /*T(tmp_4) = G(iterateurGlobal)*/
  /*T(tmp_5) = G(iterateurGlobal)*/
  
  /*sid:3545*/
  return;
  /*sid:3545*/
  /*T(creerSectionsFusionnees) = U*/
  }

}
static void fusionnerSections(ObjetEDL *objetCible ) 
{ SectionEDL *sectionCible ;
  SectionEDL *sectionSource ;
  IterateurObjet *iterateurCible ;
  unsigned int tmp ;
  int tmp_0 ;
  unsigned int tmp_1 ;
  
  {/*sid:2248*/
  iterateurCible = objetCible->iterateur;
  /*sid:2248*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(objetCible) = G(objetCible)*/
  /*T(sectionCible) = U*/
  /*T(sectionSource) = U*/
  /*T(iterateurCible) = G(objetCible)*/
  /*T(tmp) = U*/
  /*T(tmp_0) = U*/
  /*T(tmp_1) = U*/
  /*T(fusionnerSections) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objetCible) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  demarrerIterObjet(iterateurCible, INSTRUCTIONS);
  demarrerIterGlobalNom();
  /*sid:2251*/
  while (1) {tmp_1 = finIterGlobalNom();
    if (tmp_1) {break;}
    
    demarrerIterGlobalSection();
    /*sid:2256*/
    sectionSource = sectionCouranteIterGlobal();
    /*sid:2256*/
    /*T(sectionSource) = G(iterateurGlobal)*/
    
    tmp_0 = strcmp((char const   *)(sectionSource->nom)->chaine, ".shstrtab");
    if (tmp_0 != 0) {sectionCible = sectionCouranteIterObjet(iterateurCible);
      /*sid:2260*/
      fusionnerSection(sectionSource, sectionCible);
      /*sid:2260*/
      /*T(sectionSource) = G(objetCible) + G(iterateurGlobal)*/
      
      avancerIterGlobalSection();
      while (1) {tmp = finIterGlobalSection();
        if (tmp) {break;}
        
        /*sid:2266*/
        sectionSource = sectionCouranteIterGlobal();
        /*sid:2266*/
        /*T(sectionSource) = G(iterateurGlobal)*/
        
        /*sid:2267*/
        fusionnerSection(sectionSource, sectionCible);
        /*sid:2267*/
        /*T(sectionSource) = G(objetCible) + G(iterateurGlobal)*/
        
        avancerIterGlobalSection();}
      }
    
    /*sid:2270*/
    avancerIterObjet(iterateurCible);
    /*sid:2270*/
    /*T(sectionSource) = G(objetCible) + G(iterateurGlobal)*/
    
    avancerIterGlobalNom();}
  
  /*sid:2251*/
  /*T(sectionCible) = G(objetCible) + G(iterateurGlobal)*/
  /*T(sectionSource) = G(objetCible) + G(iterateurGlobal)*/
  /*T(tmp) = G(iterateurGlobal)*/
  /*T(tmp_0) = G(iterateurGlobal)*/
  /*T(tmp_1) = G(iterateurGlobal)*/
  
  /*sid:3546*/
  return;
  /*sid:3546*/
  /*T(fusionnerSections) = U*/
  }

}
static void resoudreSymbolesCommuns(ObjetEDL *objet ) 
{ IterateurObjet *iterateur ;
  SectionEDL *sectionCourante ;
  CategorieSection categorie ;
  unsigned int tmp ;
  
  {/*sid:2273*/
  iterateur = objet->iterateur;
  /*sid:2273*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(objet) = G(objet)*/
  /*T(iterateur) = G(objet)*/
  /*T(sectionCourante) = U*/
  /*T(categorie) = U*/
  /*T(tmp) = U*/
  /*T(resoudreSymbolesCommuns) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  demarrerIterObjet(iterateur, TABLE_SYMBOLES);
  /*sid:2275*/
  while (1) {tmp = finIterObjet(iterateur);
    if (tmp) {break;}
    
    sectionCourante = sectionCouranteIterObjet(iterateur);
    categorie = categorieSection(sectionCourante);
    if ((int )categorie != (int )TABLE_SYMBOLES) {break;}
    
    promouvoirSymbolesCommuns(sectionCourante);
    avancerIterObjet(iterateur);}
  
  /*sid:2275*/
  /*T(sectionBss) = G(objet) + G(sectionBss)*/
  /*T(sectionCourante) = G(objet)*/
  /*T(categorie) = G(objet)*/
  /*T(tmp) = G(objet)*/
  
  /*sid:3547*/
  return;
  /*sid:3547*/
  /*T(resoudreSymbolesCommuns) = U*/
  }

}
static void resoudreSymbolesCRT(ObjetEDL *objet ) 
{ SectionEDL *tableSymboles ;
  IterateurObjet *iterateur ;
  SectionEDL *sectionCourante ;
  CategorieSection categorie ;
  unsigned long valeurSymboleStart ;
  unsigned long valeurSymboleEnd ;
  unsigned int tailleSymboleEnd ;
  unsigned int tmp ;
  unsigned int tmp_0 ;
  
  {/*sid:2288*/
  tableSymboles = sectionSelonNomEtType(objet, (char *)".symtab", 2U);
  /*sid:2288*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(objet) = G(objet)*/
  /*T(tableSymboles) = G(objet)*/
  /*T(iterateur) = U*/
  /*T(sectionCourante) = U*/
  /*T(categorie) = U*/
  /*T(valeurSymboleStart) = U*/
  /*T(valeurSymboleEnd) = U*/
  /*T(tailleSymboleEnd) = U*/
  /*T(tmp) = U*/
  /*T(tmp_0) = U*/
  /*T(resoudreSymbolesCRT) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  if (tableSymboles != (void *)0)
  {/*sid:2291*/
  iterateur = objet->iterateur;
  /*sid:2291*/
  /*T(iterateur) = G(objet)*/
  
  demarrerIterObjet(iterateur, DONNEES_NON_INITIALISEES);
  /*sid:2293*/
  tmp_0 = finIterObjet(iterateur);
  /*sid:2293*/
  /*T(tmp_0) = G(objet)*/
  
  if (! tmp_0) {/*sid:2296*/
    sectionCourante = sectionCouranteIterObjet(iterateur);
    /*sid:2296*/
    /*T(sectionCourante) = G(objet)*/
    
    /*sid:2297*/
    categorie = categorieSection(sectionCourante);
    /*sid:2297*/
    /*T(categorie) = G(objet)*/
    
    if ((int )categorie == (int )DONNEES_NON_INITIALISEES) {/*sid:2300*/
      valeurSymboleStart = sectionCourante->adresse;
      /*sid:2300*/
      /*T(valeurSymboleStart) = G(objet)*/
      
      /*sid:2301*/
      valeurSymboleEnd = sectionCourante->adresse;
      /*sid:2301*/
      /*T(valeurSymboleEnd) = G(objet)*/
      
      /*sid:2302*/
      tailleSymboleEnd = sectionCourante->tailleContenuElf;
      /*sid:2302*/
      /*T(tailleSymboleEnd) = G(objet)*/
      
      avancerIterObjet(iterateur);
      /*sid:2304*/
      while (1) {tmp = finIterObjet(iterateur);
        if (tmp) {break;}
        
        sectionCourante = sectionCouranteIterObjet(iterateur);
        categorie = categorieSection(sectionCourante);
        if ((int )categorie != (int )DONNEES_NON_INITIALISEES) {break;}
        
        if (sectionCourante->adresse < valeurSymboleStart) {valeurSymboleStart = sectionCourante->adresse;}
        
        if (sectionCourante->adresse > valeurSymboleEnd) {valeurSymboleEnd = sectionCourante->adresse;
          tailleSymboleEnd = sectionCourante->tailleContenuElf;}
        
        avancerIterObjet(iterateur);}
      
      /*sid:2304*/
      /*T(tmp) = G(objet)*/
      }
    }
  
  /*sid:2325*/
  valeurSymboleEnd += (unsigned long )tailleSymboleEnd;
  /*sid:2325*/
  /*T(sectionCourante) = G(objet)*/
  /*T(categorie) = G(objet)*/
  /*T(valeurSymboleStart) = G(objet)*/
  /*T(valeurSymboleEnd) = G(objet)*/
  /*T(tailleSymboleEnd) = G(objet)*/
  /*T(tmp) = G(objet)*/
  
  valeurSymboleEnd = (valeurSymboleEnd + 3UL) & (unsigned long )(~ 3);
  ajusterSymbolesCRT(tableSymboles, valeurSymboleStart, valeurSymboleEnd);}
  else {/*sid:2328*/
  printf((char const   *)"%s%s%s%s\n", "panique (resoudreSymbolesCRT) ! : ",
         "aucune table symboles de nom .symtab ", " n\'existe dans l\'objet ",
         objet->nom);
  /*sid:2328*/
  /*T(journal) = U*/
  /*T(premiereFois) = U*/
  /*T(sectionBss) = U*/
  /*T(adresseText) = U*/
  /*T(adresseData) = U*/
  /*T(adresseRodata) = U*/
  /*T(adresseBss) = U*/
  /*T(adresseStack) = U*/
  /*T(nomPtEntree) = U*/
  /*T(boutismeHote) = U*/
  /*T(iterateurGlobal) = U*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = U*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = U*/
  
  exit(1);}
  
  /*sid:3548*/
  return;
  /*sid:3548*/
  /*T(resoudreSymbolesCRT) = G(objet)*/
  }

}
static void implanterTablesSymboles(ObjetEDL *objet ) 
{ IterateurObjet *iterateur ;
  SectionEDL *sectionCourante ;
  CategorieSection categorie ;
  unsigned int tmp ;
  
  {/*sid:2331*/
  iterateur = objet->iterateur;
  /*sid:2331*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(objet) = G(objet)*/
  /*T(iterateur) = G(objet)*/
  /*T(sectionCourante) = U*/
  /*T(categorie) = U*/
  /*T(tmp) = U*/
  /*T(implanterTablesSymboles) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  demarrerIterObjet(iterateur, TABLE_SYMBOLES);
  /*sid:2333*/
  while (1) {tmp = finIterObjet(iterateur);
    if (tmp) {break;}
    
    sectionCourante = sectionCouranteIterObjet(iterateur);
    categorie = categorieSection(sectionCourante);
    if ((int )categorie != (int )TABLE_SYMBOLES) {break;}
    
    implanterTableSymboles(sectionCourante);
    supprimerSymbolesSectionInutiles(sectionCourante);
    avancerIterObjet(iterateur);}
  
  /*sid:2333*/
  /*T(sectionCourante) = G(objet)*/
  /*T(categorie) = G(objet)*/
  /*T(tmp) = G(objet)*/
  
  /*sid:3549*/
  return;
  /*sid:3549*/
  /*T(implanterTablesSymboles) = U*/
  }

}
static void completerSectionsCode(ObjetEDL *objet ) 
{ IterateurObjet *iterateur ;
  SectionEDL *sectionCourante ;
  CategorieSection categorie ;
  SectionEDL *tableSymboles ;
  unsigned int tmp ;
  
  {/*sid:2347*/
  iterateur = objet->iterateur;
  /*sid:2347*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(objet) = G(objet)*/
  /*T(iterateur) = G(objet)*/
  /*T(sectionCourante) = U*/
  /*T(categorie) = U*/
  /*T(tableSymboles) = U*/
  /*T(tmp) = U*/
  /*T(completerSectionsCode) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  demarrerIterObjet(iterateur, TABLE_TRANSLATION);
  /*sid:2349*/
  while (1) {tmp = finIterObjet(iterateur);
    if (tmp) {break;}
    
    sectionCourante = sectionCouranteIterObjet(iterateur);
    categorie = categorieSection(sectionCourante);
    if ((int )categorie != (int )TABLE_TRANSLATION) {break;}
    
    completerSectionCode(sectionCourante);
    tableSymboles = (sectionCourante->tableTranslation)->tableSymboles;
    supprimerSymboleSelonNom(tableSymboles, sectionCourante->nom);
    supprimerSection(objet, sectionCourante);
    avancerIterObjet(iterateur);}
  
  /*sid:2349*/
  /*T(sectionCourante) = G(objet)*/
  /*T(categorie) = G(objet)*/
  /*T(tableSymboles) = G(objet)*/
  /*T(tmp) = G(objet)*/
  
  /*sid:3550*/
  return;
  /*sid:3550*/
  /*T(completerSectionsCode) = U*/
  }

}
static void ajouterPile(ObjetEDL *objet ) 
{ SectionEDL *sectionReference ;
  SectionEDL *sectionPile ;
  SectionEDL *tableSymboles ;
  SymboleEDL symbole ;
  
  {/*sid:2365*/
  tableSymboles = sectionSelonNomEtType(objet, (char *)".symtab", 2U);
  /*sid:2365*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(objet) = G(objet)*/
  /*T(sectionReference) = U*/
  /*T(sectionPile) = U*/
  /*T(tableSymboles) = G(objet)*/
  /*T(symbole) = U*/
  /*T(ajouterPile) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  if (tableSymboles != (void *)0)
  {/*sid:2368*/
  sectionReference = (SectionEDL *)calloc(1U, sizeof(SectionEDL ));
  /*sid:2368*/
  /*T(sectionReference) = G(objet)*/
  
  sectionReference->nom = creationChaine((char *)".stack", 0U, 0U);
  sectionReference->type = 1U;
  sectionReference->flags = 1U;
  sectionReference->alignement = 1U;
  sectionReference->tailleElement = 0U;
  /*sid:2374*/
  ajouterSection(objet, sectionReference, 0U, 0U, & sectionPile);
  /*sid:2374*/
  /*T(sectionPile) = G(objet)*/
  
  /*sid:2375*/
  sectionPile->adresse = (adresseStack + (unsigned long )(32768 - 1)) & (unsigned long )(~ (
                         32768 - 1));
  /*sid:2375*/
  /*T(sectionPile) = G(adresseStack) + G(objet)*/
  
  /*sid:2376*/
  symbole.nom = creationChaine((char *)"_stack", 0U, 0U);
  /*sid:2376*/
  /*T(symbole) = G(objet)*/
  
  /*sid:2377*/
  symbole.valeur = sectionPile->adresse;
  /*sid:2377*/
  /*T(symbole) = G(adresseStack) + G(objet)*/
  
  /*sid:2378*/
  symbole.taille = 0U;
  /*sid:2378*/
  /*T(symbole) = G(objet)*/
  
  symbole.portee = 1U;
  symbole.type = 0U;
  symbole.natureDefinition = 0U;
  symbole.sectionDefinition = sectionReference;
  ajouterSymbole(tableSymboles, & symbole, (SymboleEDL **)((void *)0));
  libererChaine(& symbole.nom);
  symbole.nom = creationChaine((char *)".stack", 0U, 0U);
  symbole.portee = 0U;
  symbole.type = 3U;
  ajouterSymbole(tableSymboles, & symbole, (SymboleEDL **)((void *)0));
  libererChaine(& symbole.nom);
  libererChaine(& sectionReference->nom);
  free((void *)sectionReference);}
  else {/*sid:2392*/
  printf((char const   *)"%s%s%s%s\n", "panique (ajouterPile) ! : ",
         "aucune table symboles de nom .symtab ", " n\'existe dans l\'objet ",
         objet->nom);
  /*sid:2392*/
  /*T(journal) = U*/
  /*T(premiereFois) = U*/
  /*T(sectionBss) = U*/
  /*T(adresseText) = U*/
  /*T(adresseData) = U*/
  /*T(adresseRodata) = U*/
  /*T(adresseBss) = U*/
  /*T(adresseStack) = U*/
  /*T(nomPtEntree) = U*/
  /*T(boutismeHote) = U*/
  /*T(iterateurGlobal) = U*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = U*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = U*/
  
  exit(1);}
  
  /*sid:3551*/
  return;
  /*sid:3551*/
  /*T(ajouterPile) = G(objet)*/
  }

}
static void initialiserLibelf(void) 
{ 
  
  /*sid:3552*/
  return;
  /*sid:3552*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(initialiserLibelf) = U*/
  

}
static void afficherSections(ObjetEDL *objet ) 
{ SectionEDL **sections ;
  unsigned int nbSections ;
  size_t indexCourant ;
  unsigned int i ;
  
  {/*sid:2396*/
  afficherTitreSections();
  /*sid:2396*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(objet) = G(objet)*/
  /*T(sections) = U*/
  /*T(nbSections) = U*/
  /*T(indexCourant) = U*/
  /*T(i) = U*/
  /*T(afficherSections) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:2397*/
  sections = objet->sections;
  /*sid:2397*/
  /*T(sections) = G(objet)*/
  
  /*sid:2398*/
  nbSections = objet->nbSections;
  /*sid:2398*/
  /*T(nbSections) = G(objet)*/
  
  indexCourant = 1U;
  /*sid:2400*/
  while (indexCourant != nbSections + 1U) {i = 0U;
    while (1) {if (i != nbSections)
               {if (! ((*(sections + i))->indexElf != indexCourant)) {break;}
               }
               else {break;}
      
      i ++;}
    
    if (i != nbSections) {afficherSection(*(sections + i));}
    else {afficherSection(*(sections + (indexCourant - (size_t )1)));}
    
    indexCourant += (size_t )1;}
  
  /*sid:2400*/
  /*T(indexCourant) = G(objet)*/
  /*T(i) = G(objet)*/
  
  /*sid:3553*/
  return;
  /*sid:3553*/
  /*T(afficherSections) = U*/
  }

}
static void afficherAttributs(ObjetEDL *objet ) 
{ Elf32_Ehdr *ehdr ;
  
  {/*sid:2419*/
  printf((char const   *)"%-40s%s\n", "nom de l\'objet : ", objet->nom);
  /*sid:2419*/
  /*T(journal) = U*/
  /*T(premiereFois) = U*/
  /*T(sectionBss) = U*/
  /*T(adresseText) = U*/
  /*T(adresseData) = U*/
  /*T(adresseRodata) = U*/
  /*T(adresseBss) = U*/
  /*T(adresseStack) = U*/
  /*T(nomPtEntree) = U*/
  /*T(boutismeHote) = U*/
  /*T(iterateurGlobal) = U*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = U*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = U*/
  /*T(objet) = G(objet)*/
  /*T(ehdr) = U*/
  /*T(afficherAttributs) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(objet) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  printf((char const   *)"%-40s", "type d\'objet : ");
  switch ((int )objet->type) {case 1: ;
  printf((char const   *)"binaire translatable\n");
  break;
  case 2: ;
  printf((char const   *)"executable\n");
  break;
  default: ;
  printf((char const   *)"autre type\n");
  break;}
  
  printf((char const   *)"%-40s", "processeur cible : ");
  switch ((int )objet->processeur) {case 2: ;
  printf((char const   *)"Sparc\n");
  break;
  case 3: ;
  printf((char const   *)"Intel 386\n");
  break;
  case 40: ;
  printf((char const   *)"Arm\n");
  break;
  default: ;
  printf((char const   *)"inconnu\n");
  break;}
  
  printf((char const   *)"%-40s", "ordre des octets : ");
  switch ((int )objet->boutisme) {case 1: ;
  printf((char const   *)"petit bout\n");
  break;
  case 2: ;
  printf((char const   *)"gros bout\n");
  break;
  default: ;
  printf((char const   *)"inconnu\n");
  break;}
  
  if (objet->ehdr != (void *)0) {/*sid:2458*/
    ehdr = objet->ehdr;
    /*sid:2458*/
    /*T(ehdr) = G(objet)*/
    
    if (objet->type == (TypeObjetEDL )2) {printf((char const   *)"%-40s0x%x\n",
                                                 "adresse du point d\'entree : ",
                                                 ehdr->e_entry);}
    
    printf((char const   *)"%-40s%d\n", "taille de l\'entete ELF : ",
           ehdr->e_ehsize);
    printf((char const   *)"%-40s%d\n", "taille d\'une entete de section : ",
           ehdr->e_shentsize);
    printf((char const   *)"%-40s%d\n", "nombre d\'entetes de section : ",
           ehdr->e_shnum);
    printf((char const   *)"%-40s%d\n",
           "index de la table des noms de section : ", ehdr->e_shstrndx);}
  
  /*sid:3554*/
  return;
  /*sid:3554*/
  /*T(ehdr) = G(objet)*/
  /*T(afficherAttributs) = U*/
  }

}
void viderIterObjet(IterateurObjet *iterateur ) ;
void afficherIterObjet(IterateurObjet *iterateur ) ;
void viderIterGlobal(void) ;
void afficherIterGlobal(void) ;
static void ajouterSectionGlobal(struct StructSectionEDL *section ,
                                 CategorieSection categorie ) ;
void creerIterObjet(IterateurObjet **iterateur ) 
{ 
  
  {/*sid:2470*/
  if (*iterateur == (void *)0)
  {*iterateur = (IterateurObjet *)calloc(1U, sizeof(IterateurObjet ));}
  else {viderIterObjet(*iterateur);}
  
  /*sid:2470*/
  /*T(creerIterObjet) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(iterateur) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(iterateur) = G(iterateur)*/
  
  /*sid:3555*/
  return;
  /*sid:3555*/
  /*T(creerIterObjet) = U*/
  }

}
void fermerIterObjet(IterateurObjet **iterateur ) 
{ 
  
  {/*sid:2475*/
  if (*iterateur != (void *)0) {viderIterObjet(*iterateur);
    free((void *)*iterateur);
    *iterateur = (IterateurObjet *)((void *)0);}
  
  /*sid:2475*/
  /*T(fermerIterObjet) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(iterateur) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(iterateur) = G(iterateur)*/
  
  /*sid:3556*/
  return;
  /*sid:3556*/
  /*T(fermerIterObjet) = U*/
  }

}
void viderIterObjet(IterateurObjet *iterateur ) 
{ NoeudSection **listesSections ;
  NoeudSection **dernieresSections ;
  CategorieSection categorie ;
  NoeudSection *sectionSupprimee ;
  
  {/*sid:2481*/
  listesSections = iterateur->listesSections;
  /*sid:2481*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(iterateur) = G(iterateur)*/
  /*T(listesSections) = G(iterateur)*/
  /*T(dernieresSections) = U*/
  /*T(categorie) = U*/
  /*T(sectionSupprimee) = U*/
  /*T(viderIterObjet) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(iterateur) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:2482*/
  dernieresSections = iterateur->dernieresSections;
  /*sid:2482*/
  /*T(dernieresSections) = G(iterateur)*/
  
  categorie = INSTRUCTIONS;
  /*sid:2484*/
  while ((int )categorie <= (int )TABLE_TRANSLATION) {while (*(listesSections + categorie) != (void *)0) {
                                                        sectionSupprimee = *(
                                                        listesSections + categorie);
                                                        *(listesSections + categorie) = (*(
                                                        listesSections + categorie))->suivant;
                                                        free((void *)sectionSupprimee);}
    
    *(dernieresSections + categorie) = (NoeudSection *)((void *)0);
    categorie = (CategorieSection )((int )categorie + 1);}
  
  /*sid:2484*/
  /*T(sectionSupprimee) = G(iterateur)*/
  
  /*sid:3557*/
  return;
  /*sid:3557*/
  /*T(viderIterObjet) = U*/
  }

}
void ajouterAIterObjet(IterateurObjet *iterateur ,
                       struct StructSectionEDL *section ) 
{ CategorieSection categorie ;
  NoeudSection **listesSections ;
  NoeudSection **dernieresSections ;
  NoeudSection *nouveauNoeud ;
  
  {/*sid:2498*/
  categorie = categorieSection(section);
  /*sid:2498*/
  /*T(ajouterAIterObjet) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(iterateur) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(iterateur) = G(iterateur)*/
  /*T(section) = G(section)*/
  /*T(categorie) = G(section)*/
  /*T(listesSections) = U*/
  /*T(dernieresSections) = U*/
  /*T(nouveauNoeud) = U*/
  
  /*sid:2499*/
  listesSections = iterateur->listesSections;
  /*sid:2499*/
  /*T(listesSections) = G(iterateur)*/
  
  /*sid:2500*/
  dernieresSections = iterateur->dernieresSections;
  /*sid:2500*/
  /*T(dernieresSections) = G(iterateur)*/
  
  nouveauNoeud = (NoeudSection *)calloc(1U, sizeof(NoeudSection ));
  /*sid:2502*/
  nouveauNoeud->section = section;
  /*sid:2502*/
  /*T(nouveauNoeud) = G(section)*/
  
  nouveauNoeud->suivant = (struct StructNoeudSection *)((void *)0);
  if (*(listesSections + categorie) == (void *)0)
  {/*sid:2506*/
  *(listesSections + categorie) = nouveauNoeud;
  /*sid:2506*/
  /*T(listesSections) = G(iterateur) + G(section)*/
  }
  else {/*sid:2507*/
  (*(dernieresSections + categorie))->suivant = nouveauNoeud;
  /*sid:2507*/
  /*T(listesSections) = G(iterateur) + G(section)*/
  /*T(dernieresSections) = G(section) + G(iterateur)*/
  }
  
  /*sid:2508*/
  *(dernieresSections + categorie) = nouveauNoeud;
  /*sid:2508*/
  /*T(dernieresSections) = G(iterateur) + G(section)*/
  
  /*sid:3558*/
  return;
  /*sid:3558*/
  /*T(ajouterAIterObjet) = U*/
  }

}
void retirerDeIterObjet(IterateurObjet *iterateur ,
                        struct StructSectionEDL *section ) 
{ CategorieSection categorie ;
  NoeudSection **listesSections ;
  NoeudSection *courant ;
  
  {/*sid:2510*/
  categorie = categorieSection(section);
  /*sid:2510*/
  /*T(retirerDeIterObjet) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(iterateur) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(iterateur) = G(iterateur)*/
  /*T(section) = G(section)*/
  /*T(categorie) = G(section)*/
  /*T(listesSections) = U*/
  /*T(courant) = U*/
  
  /*sid:2511*/
  listesSections = iterateur->listesSections;
  /*sid:2511*/
  /*T(listesSections) = G(iterateur)*/
  
  /*sid:2512*/
  courant = *(listesSections + categorie);
  /*sid:2512*/
  /*T(courant) = G(iterateur) + G(section)*/
  
  while (1) {if (courant != (void *)0)
             {if (! (courant->section != section)) {break;}
             }
             else {break;}
    
    courant = courant->suivant;}
  
  if (courant != (void *)0)
  {courant->section = (struct StructSectionEDL *)((void *)0);}
  else {/*sid:2524*/
  printf((char const   *)"%s%s%s%s%s\n", "panique (retirerDeIterObjet) ! : ",
         "la section ", (section->nom)->chaine,
         " n\'appartient pas a l\'iterateur de l\'objet ",
         (section->objetParent)->nom);
  /*sid:2524*/
  /*T(journal) = U*/
  /*T(premiereFois) = U*/
  /*T(sectionBss) = U*/
  /*T(adresseText) = U*/
  /*T(adresseData) = U*/
  /*T(adresseRodata) = U*/
  /*T(adresseBss) = U*/
  /*T(adresseStack) = U*/
  /*T(nomPtEntree) = U*/
  /*T(boutismeHote) = U*/
  /*T(iterateurGlobal) = U*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = U*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = U*/
  
  exit(1);}
  
  /*sid:3559*/
  return;
  /*sid:3559*/
  /*T(retirerDeIterObjet) = G(iterateur) + G(section)*/
  }

}
void demarrerIterObjet(IterateurObjet *iterateur , CategorieSection categorie ) 
{ NoeudSection **listesSections ;
  CategorieSection categorieCourante ;
  NoeudSection *sectionCourante ;
  
  {/*sid:2527*/
  listesSections = iterateur->listesSections;
  /*sid:2527*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(iterateur) = G(iterateur)*/
  /*T(categorie) = G(categorie)*/
  /*T(listesSections) = G(iterateur)*/
  /*T(categorieCourante) = U*/
  /*T(sectionCourante) = U*/
  /*T(demarrerIterObjet) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(categorie) + G(iterateur) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:2528*/
  categorieCourante = categorie;
  /*sid:2528*/
  /*T(categorieCourante) = G(categorie)*/
  
  /*sid:2529*/
  while ((int )categorieCourante != (int )TABLE_TRANSLATION + 1) {sectionCourante = *(
                                                                  listesSections + categorieCourante);
    while (1) {if (sectionCourante != (void *)0)
               {if (! (sectionCourante->section == (void *)0)) {break;}
               }
               else {break;}
      
      sectionCourante = sectionCourante->suivant;}
    
    if (sectionCourante != (void *)0) {break;}
    
    categorieCourante = (enum enumCategorieSection )((int )categorieCourante + 1);}
  
  /*sid:2529*/
  /*T(categorieCourante) = G(iterateur) + G(categorie)*/
  /*T(sectionCourante) = G(iterateur) + G(categorie)*/
  
  if ((int )categorieCourante != (int )TABLE_TRANSLATION + 1)
  {/*sid:2549*/
  iterateur->finSections = 0U;
  /*sid:2549*/
  /*T(iterateur) = G(categorie) + G(iterateur)*/
  
  iterateur->sectionCourante = sectionCourante;
  iterateur->categorieCourante = categorieCourante;}
  else {/*sid:2552*/
  iterateur->finSections = 1U;
  /*sid:2552*/
  /*T(iterateur) = G(categorie) + G(iterateur)*/
  }
  
  /*sid:3560*/
  return;
  /*sid:3560*/
  /*T(demarrerIterObjet) = U*/
  }

}
void avancerIterObjet(IterateurObjet *iterateur ) 
{ NoeudSection **listesSections ;
  NoeudSection *sectionCourante ;
  CategorieSection categorieCourante ;
  
  {/*sid:2554*/
  sectionCourante = (iterateur->sectionCourante)->suivant;
  /*sid:2554*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(iterateur) = G(iterateur)*/
  /*T(listesSections) = U*/
  /*T(sectionCourante) = G(iterateur)*/
  /*T(categorieCourante) = U*/
  /*T(avancerIterObjet) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(iterateur) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  while (1) {if (sectionCourante != (void *)0)
             {if (! (sectionCourante->section == (void *)0)) {break;}
             }
             else {break;}
    
    sectionCourante = sectionCourante->suivant;}
  
  if (sectionCourante == (void *)0)
  {/*sid:2565*/
  listesSections = iterateur->listesSections;
  /*sid:2565*/
  /*T(listesSections) = G(iterateur)*/
  
  /*sid:2566*/
  categorieCourante = (enum enumCategorieSection )((int )iterateur->categorieCourante + 1);
  /*sid:2566*/
  /*T(categorieCourante) = G(iterateur)*/
  
  while ((int )categorieCourante != (int )TABLE_TRANSLATION + 1) {sectionCourante = *(
                                                                  listesSections + categorieCourante);
    while (1) {if (sectionCourante != (void *)0)
               {if (! (sectionCourante->section == (void *)0)) {break;}
               }
               else {break;}
      
      sectionCourante = sectionCourante->suivant;}
    
    if (sectionCourante != (void *)0) {break;}
    
    categorieCourante = (enum enumCategorieSection )((int )categorieCourante + 1);}
  
  if ((int )categorieCourante != (int )TABLE_TRANSLATION + 1)
  {iterateur->sectionCourante = sectionCourante;
  iterateur->categorieCourante = categorieCourante;}
  else {iterateur->finSections = 1U;}
  }
  else {/*sid:2590*/
  iterateur->sectionCourante = sectionCourante;
  /*sid:2590*/
  /*T(listesSections) = G(iterateur)*/
  /*T(categorieCourante) = G(iterateur)*/
  }
  
  /*sid:3561*/
  return;
  /*sid:3561*/
  /*T(avancerIterObjet) = G(iterateur)*/
  }

}
struct StructSectionEDL *sectionCouranteIterObjet(IterateurObjet *iterateur ) 
{ struct StructSectionEDL *__retres ;
  
  {/*sid:2592*/
  __retres = (iterateur->sectionCourante)->section;
  /*sid:2592*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = G(iterateur)*/
  /*T(iterateur) = G(iterateur)*/
  /*T(sectionCouranteIterObjet) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(iterateur) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3562*/
  return (__retres);
  /*sid:3562*/
  /*T(sectionCouranteIterObjet) = G(iterateur)*/
  }

}
unsigned int finIterObjet(IterateurObjet *iterateur ) 
{ unsigned int __retres ;
  
  {/*sid:2593*/
  __retres = iterateur->finSections;
  /*sid:2593*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = G(iterateur)*/
  /*T(iterateur) = G(iterateur)*/
  /*T(finIterObjet) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(iterateur) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3563*/
  return (__retres);
  /*sid:3563*/
  /*T(finIterObjet) = G(iterateur)*/
  }

}
void afficherIterObjet(IterateurObjet *iterateur ) 
{ CategorieSection i ;
  NoeudSection *sectionCourante ;
  
  {/*sid:2594*/
  i = INSTRUCTIONS;
  /*sid:2594*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(iterateur) = G(iterateur)*/
  /*T(i) = U*/
  /*T(sectionCourante) = U*/
  /*T(afficherIterObjet) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(iterateur) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:2595*/
  while ((int )i != (int )TABLE_TRANSLATION + 1) {if (iterateur->listesSections[i] != (void *)0) {break;}
    
    i = (CategorieSection )((int )i + 1);}
  
  /*sid:2595*/
  /*T(i) = G(iterateur)*/
  
  if ((int )i != (int )TABLE_TRANSLATION + 1) {afficherTitreSections();
    /*sid:2607*/
    sectionCourante = iterateur->listesSections[i];
    /*sid:2607*/
    /*T(sectionCourante) = G(iterateur)*/
    
    while (sectionCourante != (void *)0) {afficherSection(sectionCourante->section);
      sectionCourante = sectionCourante->suivant;}
    
    i = (CategorieSection )((int )i + 1);
    while ((int )i != (int )TABLE_TRANSLATION + 1) {if (iterateur->listesSections[i] != (void *)0) {
                                                      afficherInterligneSections(
                                                      );
                                                      sectionCourante = iterateur->listesSections[i];
                                                      while (sectionCourante != (void *)0) {
                                                        afficherSection(
                                                        sectionCourante->section);
                                                        sectionCourante = sectionCourante->suivant;}
                                                      }
      
      i = (CategorieSection )((int )i + 1);}
    }
  
  /*sid:3564*/
  return;
  /*sid:3564*/
  /*T(sectionCourante) = G(iterateur)*/
  /*T(afficherIterObjet) = U*/
  }

}
static IterateurGlobal iterateurGlobal  = {{(NoeudNom *)((void *)0),
                                            (NoeudNom *)((void *)0),
                                            (NoeudNom *)((void *)0),
                                            (NoeudNom *)((void *)0),
                                            (NoeudNom *)((void *)0),
                                            (NoeudNom *)((void *)0),
                                            (NoeudNom *)((void *)0),
                                            (NoeudNom *)0},
                                           (NoeudNom *)((void *)0), 1U,
                                           (NoeudSection *)((void *)0), 1U,
                                           INSTRUCTIONS};
void viderIterGlobal(void) 
{ NoeudNom **listesNoms ;
  CategorieSection categorie ;
  NoeudNom *nomSupprime ;
  NoeudSection *sectionSupprimee ;
  
  {/*sid:2633*/
  listesNoms = iterateurGlobal.listesNoms;
  /*sid:2633*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(listesNoms) = G(iterateurGlobal)*/
  /*T(categorie) = U*/
  /*T(nomSupprime) = U*/
  /*T(sectionSupprimee) = U*/
  /*T(viderIterGlobal) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  categorie = INSTRUCTIONS;
  /*sid:2635*/
  while ((int )categorie <= (int )TABLE_TRANSLATION) {while (*(listesNoms + categorie) != (void *)0) {
                                                        nomSupprime = *(
                                                        listesNoms + categorie);
                                                        while (1) {sectionSupprimee = nomSupprime->sections;
                                                          nomSupprime->sections = (nomSupprime->sections)->suivant;
                                                          free((void *)sectionSupprimee);
                                                          if (! (nomSupprime->sections != (void *)0)) {break;}
                                                          }
                                                        
                                                        *(listesNoms + categorie) = (*(
                                                        listesNoms + categorie))->suivant;
                                                        free((void *)nomSupprime);}
    
    categorie = (CategorieSection )((int )categorie + 1);}
  
  /*sid:2635*/
  /*T(nomSupprime) = G(iterateurGlobal)*/
  /*T(sectionSupprimee) = G(iterateurGlobal)*/
  
  /*sid:3565*/
  return;
  /*sid:3565*/
  /*T(viderIterGlobal) = U*/
  }

}
void ajouterAIterGlobal(struct StructSectionEDL *section ) 
{ CategorieSection categorie ;
  
  {/*sid:2655*/
  categorie = categorieSection(section);
  /*sid:2655*/
  /*T(ajouterAIterGlobal) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(categorie) = G(section)*/
  
  ajouterSectionGlobal(section, categorie);
  /*sid:3566*/
  return;
  /*sid:3566*/
  /*T(ajouterAIterGlobal) = U*/
  }

}
void demarrerIterGlobalNom(void) 
{ NoeudNom **listesNoms ;
  CategorieSection categorieCourante ;
  
  {/*sid:2658*/
  listesNoms = iterateurGlobal.listesNoms;
  /*sid:2658*/
  /*T(demarrerIterGlobalNom) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(listesNoms) = G(iterateurGlobal)*/
  /*T(categorieCourante) = U*/
  
  categorieCourante = INSTRUCTIONS;
  /*sid:2660*/
  while (1) {if ((int )categorieCourante != (int )TABLE_TRANSLATION + 1)
             {if (! (*(listesNoms + categorieCourante) == (void *)0)) {break;}
             }
             else {break;}
    
    categorieCourante = (enum enumCategorieSection )((int )categorieCourante + 1);}
  
  /*sid:2660*/
  /*T(categorieCourante) = G(iterateurGlobal)*/
  
  if ((int )categorieCourante != (int )TABLE_TRANSLATION + 1) {iterateurGlobal.finNoms = 0U;
    iterateurGlobal.nomCourant = *(listesNoms + categorieCourante);}
  
  iterateurGlobal.categorieCourante = categorieCourante;
  /*sid:3567*/
  return;
  /*sid:3567*/
  /*T(demarrerIterGlobalNom) = U*/
  }

}
void avancerIterGlobalNom(void) 
{ NoeudNom **listesNoms ;
  CategorieSection categorieCourante ;
  
  {/*sid:2675*/
  iterateurGlobal.nomCourant = (iterateurGlobal.nomCourant)->suivant;
  /*sid:2675*/
  /*T(avancerIterGlobalNom) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(listesNoms) = U*/
  /*T(categorieCourante) = U*/
  
  if (iterateurGlobal.nomCourant == (void *)0) {/*sid:2678*/
    listesNoms = iterateurGlobal.listesNoms;
    /*sid:2678*/
    /*T(listesNoms) = G(iterateurGlobal)*/
    
    /*sid:2679*/
    categorieCourante = (enum enumCategorieSection )((int )iterateurGlobal.categorieCourante + 1);
    /*sid:2679*/
    /*T(categorieCourante) = G(iterateurGlobal)*/
    
    while (1) {if ((int )categorieCourante != (int )TABLE_TRANSLATION + 1)
               {if (! (*(listesNoms + categorieCourante) == (void *)0)) {break;}
               }
               else {break;}
      
      categorieCourante = (enum enumCategorieSection )((int )categorieCourante + 1);}
    
    if ((int )categorieCourante == (int )TABLE_TRANSLATION + 1)
    {iterateurGlobal.finNoms = 1U;}
    else {iterateurGlobal.nomCourant = *(listesNoms + categorieCourante);}
    
    iterateurGlobal.categorieCourante = categorieCourante;}
  
  /*sid:3568*/
  return;
  /*sid:3568*/
  /*T(avancerIterGlobalNom) = U*/
  /*T(listesNoms) = G(iterateurGlobal)*/
  /*T(categorieCourante) = G(iterateurGlobal)*/
  }

}
unsigned int alignementCourantIterGlobal(void) 
{ unsigned int __retres ;
  
  {/*sid:2695*/
  __retres = (iterateurGlobal.nomCourant)->alignementMax;
  /*sid:2695*/
  /*T(alignementCourantIterGlobal) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = G(iterateurGlobal)*/
  
  /*sid:3569*/
  return (__retres);
  /*sid:3569*/
  /*T(alignementCourantIterGlobal) = G(iterateurGlobal)*/
  }

}
unsigned int finIterGlobalNom(void) 
{ unsigned int __retres ;
  
  {/*sid:2696*/
  __retres = iterateurGlobal.finNoms;
  /*sid:2696*/
  /*T(finIterGlobalNom) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = G(iterateurGlobal)*/
  
  /*sid:3570*/
  return (__retres);
  /*sid:3570*/
  /*T(finIterGlobalNom) = G(iterateurGlobal)*/
  }

}
void demarrerIterGlobalSection(void) 
{ 
  
  {/*sid:2697*/
  iterateurGlobal.sectionCourante = (iterateurGlobal.nomCourant)->sections;
  /*sid:2697*/
  /*T(demarrerIterGlobalSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  if (iterateurGlobal.sectionCourante == (void *)0)
  {iterateurGlobal.finSections = 1U;}
  else {iterateurGlobal.finSections = 0U;}
  
  /*sid:3571*/
  return;
  /*sid:3571*/
  /*T(demarrerIterGlobalSection) = U*/
  }

}
void avancerIterGlobalSection(void) 
{ 
  
  {/*sid:2703*/
  iterateurGlobal.sectionCourante = (iterateurGlobal.sectionCourante)->suivant;
  /*sid:2703*/
  /*T(avancerIterGlobalSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  
  if (iterateurGlobal.sectionCourante == (void *)0) {iterateurGlobal.finSections = 1U;}
  
  /*sid:3572*/
  return;
  /*sid:3572*/
  /*T(avancerIterGlobalSection) = U*/
  }

}
struct StructSectionEDL *sectionCouranteIterGlobal(void) 
{ struct StructSectionEDL *__retres ;
  
  {/*sid:2709*/
  __retres = (iterateurGlobal.sectionCourante)->section;
  /*sid:2709*/
  /*T(sectionCouranteIterGlobal) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = G(iterateurGlobal)*/
  
  /*sid:3573*/
  return (__retres);
  /*sid:3573*/
  /*T(sectionCouranteIterGlobal) = G(iterateurGlobal)*/
  }

}
unsigned int finIterGlobalSection(void) 
{ unsigned int __retres ;
  
  {/*sid:2710*/
  __retres = iterateurGlobal.finSections;
  /*sid:2710*/
  /*T(finIterGlobalSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = G(iterateurGlobal)*/
  
  /*sid:3574*/
  return (__retres);
  /*sid:3574*/
  /*T(finIterGlobalSection) = G(iterateurGlobal)*/
  }

}
void afficherIterGlobal(void) 
{ CategorieSection i ;
  NoeudNom *noeudNomCourant ;
  NoeudSection *sectionCourante ;
  
  {/*sid:2711*/
  i = INSTRUCTIONS;
  /*sid:2711*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(i) = U*/
  /*T(noeudNomCourant) = U*/
  /*T(sectionCourante) = U*/
  /*T(afficherIterGlobal) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:2712*/
  while ((int )i != (int )TABLE_TRANSLATION + 1) {if (iterateurGlobal.listesNoms[i] != (void *)0) {break;}
    
    i = (CategorieSection )((int )i + 1);}
  
  /*sid:2712*/
  /*T(i) = G(iterateurGlobal)*/
  
  if ((int )i != (int )TABLE_TRANSLATION + 1) {afficherTitreSections();
    /*sid:2724*/
    noeudNomCourant = iterateurGlobal.listesNoms[i];
    /*sid:2724*/
    /*T(noeudNomCourant) = G(iterateurGlobal)*/
    
    /*sid:2725*/
    while (1) {sectionCourante = noeudNomCourant->sections;
      while (1) {afficherSection(sectionCourante->section);
        sectionCourante = sectionCourante->suivant;
        if (! (sectionCourante != (void *)0)) {break;}
        }
      
      noeudNomCourant = noeudNomCourant->suivant;
      if (! (noeudNomCourant != (void *)0)) {break;}
      }
    
    /*sid:2725*/
    /*T(sectionCourante) = G(iterateurGlobal)*/
    
    i = (CategorieSection )((int )i + 1);
    while ((int )i != (int )TABLE_TRANSLATION + 1) {if (iterateurGlobal.listesNoms[i] != (void *)0) {
                                                      afficherInterligneSections(
                                                      );
                                                      noeudNomCourant = iterateurGlobal.listesNoms[i];
                                                      while (1) {sectionCourante = noeudNomCourant->sections;
                                                        while (1) {afficherSection(
                                                                   sectionCourante->section);
                                                          sectionCourante = sectionCourante->suivant;
                                                          if (! (sectionCourante != (void *)0)) {break;}
                                                          }
                                                        
                                                        noeudNomCourant = noeudNomCourant->suivant;
                                                        if (! (noeudNomCourant != (void *)0)) {break;}
                                                        }
                                                      }
      
      i = (CategorieSection )((int )i + 1);}
    }
  
  /*sid:3575*/
  return;
  /*sid:3575*/
  /*T(noeudNomCourant) = G(iterateurGlobal)*/
  /*T(sectionCourante) = G(iterateurGlobal)*/
  /*T(afficherIterGlobal) = U*/
  }

}
static void ajouterSectionGlobal(struct StructSectionEDL *section ,
                                 CategorieSection categorie ) 
{ NoeudNom **listesNoms ;
  NoeudNom *noeudNomCourant ;
  NoeudNom *noeudNomPrecedent ;
  NoeudSection *noeudSection ;
  int tmp_0 ;
  
  {/*sid:2762*/
  listesNoms = iterateurGlobal.listesNoms;
  /*sid:2762*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(categorie) = G(categorie)*/
  /*T(listesNoms) = G(iterateurGlobal)*/
  /*T(noeudNomCourant) = U*/
  /*T(noeudNomPrecedent) = U*/
  /*T(noeudSection) = U*/
  /*T(tmp_0) = U*/
  /*T(ajouterSectionGlobal) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(categorie) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:2763*/
  noeudNomCourant = *(listesNoms + categorie);
  /*sid:2763*/
  /*T(noeudNomCourant) = G(iterateurGlobal) + G(categorie)*/
  
  noeudSection = (NoeudSection *)calloc(1U, sizeof(NoeudSection ));
  /*sid:2765*/
  noeudSection->section = section;
  /*sid:2765*/
  /*T(noeudSection) = G(section)*/
  
  noeudSection->suivant = (struct StructNoeudSection *)((void *)0);
  /*sid:2767*/
  while (noeudNomCourant != (void *)0) {tmp_0 = strcmp((char const   *)(((noeudNomCourant->sections)->section)->nom)->chaine,
                                                       (char const   *)(section->nom)->chaine);
    if (tmp_0 == 0) {if (((noeudNomCourant->sections)->section)->type == section->type) {break;}
      }
    
    noeudNomPrecedent = noeudNomCourant;
    noeudNomCourant = noeudNomCourant->suivant;}
  
  /*sid:2767*/
  /*T(noeudNomCourant) = G(section) + G(iterateurGlobal) + G(categorie)*/
  /*T(noeudNomPrecedent) = G(section) + G(iterateurGlobal) + G(categorie)*/
  /*T(tmp_0) = G(section) + G(iterateurGlobal) + G(categorie)*/
  
  if (noeudNomCourant == (void *)0)
  {noeudNomCourant = (NoeudNom *)calloc(1U, sizeof(NoeudNom ));
  noeudNomCourant->alignementMax = section->alignement;
  noeudNomCourant->sections = noeudSection;
  noeudNomCourant->derniereSection = noeudSection;
  noeudNomCourant->suivant = (struct StructNoeudNom *)((void *)0);
  if (*(listesNoms + categorie) == (void *)0)
  {/*sid:2789*/
  *(listesNoms + categorie) = noeudNomCourant;
  /*sid:2789*/
  /*T(listesNoms) = G(section) + G(iterateurGlobal) + G(categorie)*/
  }
  else {noeudNomPrecedent->suivant = noeudNomCourant;}
  }
  else {if (section->alignement > noeudNomCourant->alignementMax) {noeudNomCourant->alignementMax = section->alignement;}
  
  (noeudNomCourant->derniereSection)->suivant = noeudSection;
  /*sid:2796*/
  noeudNomCourant->derniereSection = noeudSection;
  /*sid:2796*/
  /*T(listesNoms) = G(section) + G(iterateurGlobal) + G(categorie)*/
  }
  
  /*sid:3576*/
  return;
  /*sid:3576*/
  /*T(listesNoms) = G(section) + G(iterateurGlobal) + G(categorie)*/
  /*T(ajouterSectionGlobal) = G(section) + G(iterateurGlobal) + G(categorie)*/
  }

}
CategorieSection categorieSection(struct StructSectionEDL *section ) 
{ unsigned int type ;
  unsigned int flags ;
  CategorieSection __retres ;
  
  {/*sid:2798*/
  type = section->type;
  /*sid:2798*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = U*/
  /*T(section) = G(section)*/
  /*T(type) = G(section)*/
  /*T(flags) = U*/
  /*T(categorieSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:2799*/
  flags = section->flags;
  /*sid:2799*/
  /*T(flags) = G(section)*/
  
  switch ((int )type) {case 1: ;
  if (flags & 2U)
  {if (flags & 4U)
   {/*sid:2805*/
   __retres = INSTRUCTIONS;
   /*sid:2805*/
   /*T(__retres) = G(section)*/
   
   goto return_label;}
   else {if (flags & 1U)
         {/*sid:2808*/
         __retres = DONNEES_INITIALISEES;
         /*sid:2808*/
         /*T(__retres) = G(section)*/
         
         goto return_label;}
         else {/*sid:2809*/
         __retres = DONNEES_LECTURE_SEULE;
         /*sid:2809*/
         /*T(__retres) = G(section)*/
         
         goto return_label;}
   }
  }
  else {/*sid:2810*/
  __retres = DONNEES_NON_ALLOUABLES;
  /*sid:2810*/
  /*T(__retres) = G(section)*/
  
  goto return_label;}
  
  /*sid:2811*/
  break;
  /*sid:2811*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = U*/
  /*T(section) = G(section)*/
  /*T(type) = U*/
  /*T(flags) = U*/
  /*T(categorieSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  case 8: ;
  if (flags & 2U)
  {/*sid:2814*/
  __retres = DONNEES_NON_INITIALISEES;
  /*sid:2814*/
  /*T(__retres) = G(section)*/
  
  goto return_label;}
  else {/*sid:2815*/
  __retres = DONNEES_NON_ALLOUABLES;
  /*sid:2815*/
  /*T(__retres) = G(section)*/
  
  goto return_label;}
  
  /*sid:2816*/
  break;
  /*sid:2816*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = U*/
  /*T(section) = G(section)*/
  /*T(type) = U*/
  /*T(flags) = U*/
  /*T(categorieSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:2817*/
  case 3: 
  __retres = TABLE_CHAINES;
  /*sid:2817*/
  /*T(__retres) = G(section)*/
  
  goto return_label;
  /*sid:2818*/
  break;
  /*sid:2818*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = U*/
  /*T(section) = G(section)*/
  /*T(type) = U*/
  /*T(flags) = U*/
  /*T(categorieSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:2819*/
  case 2: 
  __retres = TABLE_SYMBOLES;
  /*sid:2819*/
  /*T(__retres) = G(section)*/
  
  goto return_label;
  /*sid:2820*/
  break;
  /*sid:2820*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = U*/
  /*T(section) = G(section)*/
  /*T(type) = U*/
  /*T(flags) = U*/
  /*T(categorieSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:2821*/
  case 9: 
  __retres = TABLE_TRANSLATION;
  /*sid:2821*/
  /*T(__retres) = G(section)*/
  
  goto return_label;
  /*sid:2822*/
  break;
  /*sid:2822*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = U*/
  /*T(section) = G(section)*/
  /*T(type) = U*/
  /*T(flags) = U*/
  /*T(categorieSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  default: ;
  /*sid:2824*/
  __retres = DONNEES_NON_ALLOUABLES;
  /*sid:2824*/
  /*T(__retres) = G(section)*/
  
  goto return_label;
  /*sid:2825*/
  break;
  /*sid:2825*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = U*/
  /*T(section) = G(section)*/
  /*T(type) = U*/
  /*T(flags) = U*/
  /*T(categorieSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  }
  
  __retres = (enum enumCategorieSection )0;
  /*sid:3587*/
  return_label: /* CIL Label */ 
  return (__retres);
  /*sid:3587*/
  /*T(__retres) = G(section)*/
  /*T(type) = G(section)*/
  /*T(flags) = G(section)*/
  /*T(categorieSection) = G(section)*/
  }

}
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s ,
                                                char const   * __restrict  __format 
                                                , ...) ;
extern void perror(char const   *__s ) ;
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
static void analyserLigneCommande(int argc , char **argv ) ;
static void ouvrirObjetEntree(void) ;
static void realiserImplantation(void) ;
static void cloreObjetSortie(void) ;
static void fermerObjetEntree(void) ;
static void fermerObjetSortie(void) ;
static void libererDonneesGlobales(void) ;
static void afficherUsage(void) ;
static ObjetEDL objets[2] ;
static unsigned int copieSuperficielle  = 1U;
int main(int argc , char **argv ) 
{ int __retres ;
  
  {/*sid:2827*/
  analyserLigneCommande(argc, argv);
  /*sid:2827*/
  /*T(argc) = G(argc)*/
  /*T(argv) = G(argv)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = T*/
  /*T(adresseData) = T*/
  /*T(adresseRodata) = T*/
  /*T(adresseBss) = T*/
  /*T(adresseStack) = T*/
  /*T(nomPtEntree) = G(argc) + G(objets) + G(argv) + G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(argc) + G(argv) + G(objets)*/
  /*T(copieSuperficielle) = G(objets) + G(argv) + G(argc) + G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = U*/
  /*T(main) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(argv) + G(argc) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:2828*/
  ouvrirObjetEntree();
  /*sid:2828*/
  /*T(objets) = G(objets) + G(argv) + G(argc) + G(copieSuperficielle)*/
  
  /*sid:2829*/
  realiserImplantation();
  /*sid:2829*/
  /*T(journal) = T*/
  /*T(premiereFois) = T*/
  /*T(sectionBss) = T*/
  /*T(nomPtEntree) = T*/
  /*T(boutismeHote) = T*/
  /*T(iterateurGlobal) = T*/
  /*T(objets) = T*/
  /*T(copieSuperficielle) = T*/
  /*T(objets_0) = T*/
  /*T(nbFichiersDonnees) = T*/
  
  /*sid:2830*/
  cloreObjetSortie();
  /*sid:2830*/
  /*T(journal) = U*/
  /*T(premiereFois) = U*/
  /*T(sectionBss) = U*/
  /*T(adresseText) = U*/
  /*T(adresseData) = U*/
  /*T(adresseRodata) = U*/
  /*T(adresseBss) = U*/
  /*T(adresseStack) = U*/
  /*T(nomPtEntree) = U*/
  /*T(boutismeHote) = U*/
  /*T(iterateurGlobal) = U*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = U*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = U*/
  
  fermerObjetSortie();
  fermerObjetEntree();
  libererDonneesGlobales();
  __retres = 0;
  /*sid:3588*/
  return (__retres);
  /*sid:3588*/
  /*T(main) = U*/
  }

}
static void analyserLigneCommande(int argc , char **argv ) 
{ unsigned int nbFichiersDonnees_0 ;
  unsigned int i ;
  unsigned long adresseText_0 ;
  unsigned long adresseData_0 ;
  unsigned long adresseRodata_0 ;
  unsigned long adresseBss_0 ;
  unsigned long adresseStack_0 ;
  int tmp ;
  int tmp_0 ;
  int tmp_1 ;
  int tmp_2 ;
  int tmp_3 ;
  int tmp_4 ;
  int tmp_5 ;
  int tmp_6 ;
  int tmp_7 ;
  int tmp_8 ;
  int tmp_9 ;
  int tmp_10 ;
  int tmp_11 ;
  int tmp_12 ;
  int tmp_13 ;
  
  {/*sid:2835*/
  objets[0].nom = (char *)((void *)0);
  /*sid:2835*/
  /*T(argc) = G(argc)*/
  /*T(argv) = G(argv)*/
  /*T(nbFichiersDonnees_0) = U*/
  /*T(i) = U*/
  /*T(adresseText_0) = U*/
  /*T(adresseData_0) = U*/
  /*T(adresseRodata_0) = U*/
  /*T(adresseBss_0) = U*/
  /*T(adresseStack_0) = U*/
  /*T(tmp) = U*/
  /*T(tmp_0) = U*/
  /*T(tmp_1) = U*/
  /*T(tmp_2) = U*/
  /*T(tmp_3) = U*/
  /*T(tmp_4) = U*/
  /*T(tmp_5) = U*/
  /*T(tmp_6) = U*/
  /*T(tmp_7) = U*/
  /*T(tmp_8) = U*/
  /*T(tmp_9) = U*/
  /*T(tmp_10) = U*/
  /*T(tmp_11) = U*/
  /*T(tmp_12) = U*/
  /*T(tmp_13) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(analyserLigneCommande) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(argv) + G(argc) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  nbFichiersDonnees_0 = 0U;
  /*sid:2837*/
  memoriserNomPointEntree((char *)"main");
  /*sid:2837*/
  /*T(nomPtEntree) = U*/
  
  i = 1U;
  /*sid:2839*/
  while (i != (unsigned int )argc) {tmp_12 = strcmp((char const   *)*(
                                                    argv + i), "-h");
    if (tmp_12 == 0)
    {/*sid:2845*/
    afficherUsage();
    /*sid:2845*/
    /*T(journal) = U*/
    /*T(premiereFois) = U*/
    /*T(sectionBss) = U*/
    /*T(adresseText) = U*/
    /*T(adresseData) = U*/
    /*T(adresseRodata) = U*/
    /*T(adresseBss) = U*/
    /*T(adresseStack) = U*/
    /*T(nomPtEntree) = U*/
    /*T(boutismeHote) = U*/
    /*T(iterateurGlobal) = U*/
    /*T(objets) = U*/
    /*T(copieSuperficielle) = U*/
    /*T(objets_0) = U*/
    /*T(nbFichiersDonnees) = U*/
    
    exit(0);}
    else {tmp_11 = strcmp((char const   *)*(argv + i), "-o");
    if (tmp_11 == 0)
    {if (objets[0].nom == (void *)0)
     {i ++;
     if (i != (unsigned int )argc)
     {if ((int )*(*(argv + i) + 0) != '-')
      {memoriserNomObjet(objets, *(argv + i));}
      else {/*sid:2857*/
      printf((char const   *)"%s%s\n", "erreur : ",
             "-o doit etre suivi d\'un nom de fichier");
      /*sid:2857*/
      /*T(journal) = U*/
      /*T(premiereFois) = U*/
      /*T(sectionBss) = U*/
      /*T(adresseText) = U*/
      /*T(adresseData) = U*/
      /*T(adresseRodata) = U*/
      /*T(adresseBss) = U*/
      /*T(adresseStack) = U*/
      /*T(nomPtEntree) = U*/
      /*T(boutismeHote) = U*/
      /*T(iterateurGlobal) = U*/
      /*T(objets) = U*/
      /*T(copieSuperficielle) = U*/
      /*T(objets_0) = U*/
      /*T(nbFichiersDonnees) = U*/
      
      exit(1);}
     }
     else {/*sid:2859*/
     printf((char const   *)"%s%s\n", "erreur : ",
            "-o doit etre suivi d\'un nom de fichier");
     /*sid:2859*/
     /*T(journal) = U*/
     /*T(premiereFois) = U*/
     /*T(sectionBss) = U*/
     /*T(adresseText) = U*/
     /*T(adresseData) = U*/
     /*T(adresseRodata) = U*/
     /*T(adresseBss) = U*/
     /*T(adresseStack) = U*/
     /*T(nomPtEntree) = U*/
     /*T(boutismeHote) = U*/
     /*T(iterateurGlobal) = U*/
     /*T(objets) = U*/
     /*T(copieSuperficielle) = U*/
     /*T(objets_0) = U*/
     /*T(nbFichiersDonnees) = U*/
     
     exit(1);}
     }
     else {/*sid:2861*/
     printf((char const   *)"%s%s\n", "erreur : ",
            "un seul fichier resultat autorise");
     /*sid:2861*/
     /*T(journal) = U*/
     /*T(premiereFois) = U*/
     /*T(sectionBss) = U*/
     /*T(adresseText) = U*/
     /*T(adresseData) = U*/
     /*T(adresseRodata) = U*/
     /*T(adresseBss) = U*/
     /*T(adresseStack) = U*/
     /*T(nomPtEntree) = U*/
     /*T(boutismeHote) = U*/
     /*T(iterateurGlobal) = U*/
     /*T(objets) = U*/
     /*T(copieSuperficielle) = U*/
     /*T(objets_0) = U*/
     /*T(nbFichiersDonnees) = U*/
     
     exit(1);}
    }
    else {tmp_10 = strcmp((char const   *)*(argv + i), "-t");
    if (tmp_10 == 0)
    {i ++;
    if (i == (unsigned int )argc)
    {/*sid:2868*/
    printf((char const   *)"%s%s\n", "erreur : ",
           "-t doit etre suivi d\'un entier naturel");
    /*sid:2868*/
    /*T(journal) = U*/
    /*T(premiereFois) = U*/
    /*T(sectionBss) = U*/
    /*T(adresseText) = U*/
    /*T(adresseData) = U*/
    /*T(adresseRodata) = U*/
    /*T(adresseBss) = U*/
    /*T(adresseStack) = U*/
    /*T(nomPtEntree) = U*/
    /*T(boutismeHote) = U*/
    /*T(iterateurGlobal) = U*/
    /*T(objets) = U*/
    /*T(copieSuperficielle) = U*/
    /*T(objets_0) = U*/
    /*T(nbFichiersDonnees) = U*/
    
    exit(1);}
    else {tmp = sscanf((char const   *)*(argv + i), (char const   *)"%li",
                       & adresseText_0);
    if (tmp != 1)
    {/*sid:2872*/
    printf((char const   *)"%s%s\n", "erreur : ",
           "-t doit etre suivi d\'un entier naturel");
    /*sid:2872*/
    /*T(journal) = U*/
    /*T(premiereFois) = U*/
    /*T(sectionBss) = U*/
    /*T(adresseText) = U*/
    /*T(adresseData) = U*/
    /*T(adresseRodata) = U*/
    /*T(adresseBss) = U*/
    /*T(adresseStack) = U*/
    /*T(nomPtEntree) = U*/
    /*T(boutismeHote) = U*/
    /*T(iterateurGlobal) = U*/
    /*T(objets) = U*/
    /*T(copieSuperficielle) = U*/
    /*T(objets_0) = U*/
    /*T(nbFichiersDonnees) = U*/
    
    exit(1);}
    else {memoriserAdresseText(adresseText_0);}
    }
    }
    else {tmp_9 = strcmp((char const   *)*(argv + i), "-d");
    if (tmp_9 == 0)
    {i ++;
    if (i == (unsigned int )argc)
    {/*sid:2880*/
    printf((char const   *)"%s%s\n", "erreur : ",
           "-d doit etre suivi d\'un entier naturel");
    /*sid:2880*/
    /*T(journal) = U*/
    /*T(premiereFois) = U*/
    /*T(sectionBss) = U*/
    /*T(adresseText) = U*/
    /*T(adresseData) = U*/
    /*T(adresseRodata) = U*/
    /*T(adresseBss) = U*/
    /*T(adresseStack) = U*/
    /*T(nomPtEntree) = U*/
    /*T(boutismeHote) = U*/
    /*T(iterateurGlobal) = U*/
    /*T(objets) = U*/
    /*T(copieSuperficielle) = U*/
    /*T(objets_0) = U*/
    /*T(nbFichiersDonnees) = U*/
    
    exit(1);}
    else {tmp_0 = sscanf((char const   *)*(argv + i), (char const   *)"%li",
                         & adresseData_0);
    if (tmp_0 != 1)
    {/*sid:2884*/
    printf((char const   *)"%s%s\n", "erreur : ",
           "-d doit etre suivi d\'un entier naturel");
    /*sid:2884*/
    /*T(journal) = U*/
    /*T(premiereFois) = U*/
    /*T(sectionBss) = U*/
    /*T(adresseText) = U*/
    /*T(adresseData) = U*/
    /*T(adresseRodata) = U*/
    /*T(adresseBss) = U*/
    /*T(adresseStack) = U*/
    /*T(nomPtEntree) = U*/
    /*T(boutismeHote) = U*/
    /*T(iterateurGlobal) = U*/
    /*T(objets) = U*/
    /*T(copieSuperficielle) = U*/
    /*T(objets_0) = U*/
    /*T(nbFichiersDonnees) = U*/
    
    exit(1);}
    else {memoriserAdresseData(adresseData_0);}
    }
    }
    else {tmp_8 = strcmp((char const   *)*(argv + i), "-r");
    if (tmp_8 == 0)
    {i ++;
    if (i == (unsigned int )argc)
    {/*sid:2892*/
    printf((char const   *)"%s%s\n", "erreur : ",
           "-r doit etre suivi d\'un entier naturel");
    /*sid:2892*/
    /*T(journal) = U*/
    /*T(premiereFois) = U*/
    /*T(sectionBss) = U*/
    /*T(adresseText) = U*/
    /*T(adresseData) = U*/
    /*T(adresseRodata) = U*/
    /*T(adresseBss) = U*/
    /*T(adresseStack) = U*/
    /*T(nomPtEntree) = U*/
    /*T(boutismeHote) = U*/
    /*T(iterateurGlobal) = U*/
    /*T(objets) = U*/
    /*T(copieSuperficielle) = U*/
    /*T(objets_0) = U*/
    /*T(nbFichiersDonnees) = U*/
    
    exit(1);}
    else {tmp_1 = sscanf((char const   *)*(argv + i), (char const   *)"%li",
                         & adresseRodata_0);
    if (tmp_1 != 1)
    {/*sid:2896*/
    printf((char const   *)"%s%s\n", "erreur : ",
           "-r doit etre suivi d\'un entier naturel");
    /*sid:2896*/
    /*T(journal) = U*/
    /*T(premiereFois) = U*/
    /*T(sectionBss) = U*/
    /*T(adresseText) = U*/
    /*T(adresseData) = U*/
    /*T(adresseRodata) = U*/
    /*T(adresseBss) = U*/
    /*T(adresseStack) = U*/
    /*T(nomPtEntree) = U*/
    /*T(boutismeHote) = U*/
    /*T(iterateurGlobal) = U*/
    /*T(objets) = U*/
    /*T(copieSuperficielle) = U*/
    /*T(objets_0) = U*/
    /*T(nbFichiersDonnees) = U*/
    
    exit(1);}
    else {memoriserAdresseRodata(adresseRodata_0);}
    }
    }
    else {tmp_7 = strcmp((char const   *)*(argv + i), "-b");
    if (tmp_7 == 0)
    {i ++;
    if (i == (unsigned int )argc)
    {/*sid:2904*/
    printf((char const   *)"%s%s\n", "erreur : ",
           "-b doit etre suivi d\'un entier naturel");
    /*sid:2904*/
    /*T(journal) = U*/
    /*T(premiereFois) = U*/
    /*T(sectionBss) = U*/
    /*T(adresseText) = U*/
    /*T(adresseData) = U*/
    /*T(adresseRodata) = U*/
    /*T(adresseBss) = U*/
    /*T(adresseStack) = U*/
    /*T(nomPtEntree) = U*/
    /*T(boutismeHote) = U*/
    /*T(iterateurGlobal) = U*/
    /*T(objets) = U*/
    /*T(copieSuperficielle) = U*/
    /*T(objets_0) = U*/
    /*T(nbFichiersDonnees) = U*/
    
    exit(1);}
    else {tmp_2 = sscanf((char const   *)*(argv + i), (char const   *)"%li",
                         & adresseBss_0);
    if (tmp_2 != 1)
    {/*sid:2908*/
    printf((char const   *)"%s%s\n", "erreur : ",
           "-b doit etre suivi d\'un entier naturel");
    /*sid:2908*/
    /*T(journal) = U*/
    /*T(premiereFois) = U*/
    /*T(sectionBss) = U*/
    /*T(adresseText) = U*/
    /*T(adresseData) = U*/
    /*T(adresseRodata) = U*/
    /*T(adresseBss) = U*/
    /*T(adresseStack) = U*/
    /*T(nomPtEntree) = U*/
    /*T(boutismeHote) = U*/
    /*T(iterateurGlobal) = U*/
    /*T(objets) = U*/
    /*T(copieSuperficielle) = U*/
    /*T(objets_0) = U*/
    /*T(nbFichiersDonnees) = U*/
    
    exit(1);}
    else {memoriserAdresseBss(adresseBss_0);}
    }
    }
    else {tmp_6 = strcmp((char const   *)*(argv + i), "-s");
    if (tmp_6 == 0)
    {i ++;
    if (i == (unsigned int )argc)
    {/*sid:2916*/
    printf((char const   *)"%s%s\n", "erreur : ",
           "-s doit etre suivi d\'un entier naturel");
    /*sid:2916*/
    /*T(journal) = U*/
    /*T(premiereFois) = U*/
    /*T(sectionBss) = U*/
    /*T(adresseText) = U*/
    /*T(adresseData) = U*/
    /*T(adresseRodata) = U*/
    /*T(adresseBss) = U*/
    /*T(adresseStack) = U*/
    /*T(nomPtEntree) = U*/
    /*T(boutismeHote) = U*/
    /*T(iterateurGlobal) = U*/
    /*T(objets) = U*/
    /*T(copieSuperficielle) = U*/
    /*T(objets_0) = U*/
    /*T(nbFichiersDonnees) = U*/
    
    exit(1);}
    else {tmp_3 = sscanf((char const   *)*(argv + i), (char const   *)"%li",
                         & adresseStack_0);
    if (tmp_3 != 1)
    {/*sid:2920*/
    printf((char const   *)"%s%s\n", "erreur : ",
           "-s doit etre suivi d\'un entier naturel");
    /*sid:2920*/
    /*T(journal) = U*/
    /*T(premiereFois) = U*/
    /*T(sectionBss) = U*/
    /*T(adresseText) = U*/
    /*T(adresseData) = U*/
    /*T(adresseRodata) = U*/
    /*T(adresseBss) = U*/
    /*T(adresseStack) = U*/
    /*T(nomPtEntree) = U*/
    /*T(boutismeHote) = U*/
    /*T(iterateurGlobal) = U*/
    /*T(objets) = U*/
    /*T(copieSuperficielle) = U*/
    /*T(objets_0) = U*/
    /*T(nbFichiersDonnees) = U*/
    
    exit(1);}
    else {memoriserAdresseStack(adresseStack_0);}
    }
    }
    else {tmp_5 = strcmp((char const   *)*(argv + i), "-e");
    if (tmp_5 == 0)
    {i ++;
    if (i == (unsigned int )argc)
    {/*sid:2928*/
    printf((char const   *)"%s%s\n", "erreur : ",
           "-e doit etre suivi d\'un nom de symbole");
    /*sid:2928*/
    /*T(journal) = U*/
    /*T(premiereFois) = U*/
    /*T(sectionBss) = U*/
    /*T(adresseText) = U*/
    /*T(adresseData) = U*/
    /*T(adresseRodata) = U*/
    /*T(adresseBss) = U*/
    /*T(adresseStack) = U*/
    /*T(nomPtEntree) = U*/
    /*T(boutismeHote) = U*/
    /*T(iterateurGlobal) = U*/
    /*T(objets) = U*/
    /*T(copieSuperficielle) = U*/
    /*T(objets_0) = U*/
    /*T(nbFichiersDonnees) = U*/
    
    exit(1);}
    else {/*sid:2930*/
    memoriserNomPointEntree(*(argv + i));
    /*sid:2930*/
    /*T(nomPtEntree) = G(argv) + G(objets) + G(argc)*/
    }
    }
    else {tmp_4 = strcmp((char const   *)*(argv + i), "-x");
    if (tmp_4 == 0)
    {/*sid:2933*/
    copieSuperficielle = 0U;
    /*sid:2933*/
    /*T(copieSuperficielle) = G(argv) + G(objets) + G(argc)*/
    }
    else {nbFichiersDonnees_0 ++;
    memoriserNomObjet(& objets[nbFichiersDonnees_0], *(argv + i));}
    }
    }
    }
    }
    }
    }
    }
    }
    
    /*sid:2936*/
    i ++;
    /*sid:2936*/
    /*T(nomPtEntree) = G(objets) + G(argv) + G(argc) + G(nomPtEntree)*/
    /*T(copieSuperficielle) = G(argv) + G(argc) + G(objets) + G(copieSuperficielle)*/
    }
  
  /*sid:2839*/
  /*T(nbFichiersDonnees_0) = G(objets) + G(argv) + G(argc)*/
  /*T(i) = G(argv) + G(objets) + G(argc)*/
  /*T(adresseText_0) = T*/
  /*T(adresseData_0) = T*/
  /*T(adresseRodata_0) = T*/
  /*T(adresseBss_0) = T*/
  /*T(adresseStack_0) = T*/
  /*T(tmp) = G(objets) + G(argv) + G(argc)*/
  /*T(tmp_0) = G(objets) + G(argv) + G(argc)*/
  /*T(tmp_1) = G(objets) + G(argv) + G(argc)*/
  /*T(tmp_2) = G(objets) + G(argv) + G(argc)*/
  /*T(tmp_3) = G(objets) + G(argv) + G(argc)*/
  /*T(tmp_4) = G(objets) + G(argv) + G(argc)*/
  /*T(tmp_5) = G(objets) + G(argv) + G(argc)*/
  /*T(tmp_6) = G(objets) + G(argv) + G(argc)*/
  /*T(tmp_7) = G(objets) + G(argv) + G(argc)*/
  /*T(tmp_8) = G(objets) + G(argv) + G(argc)*/
  /*T(tmp_9) = G(objets) + G(argv) + G(argc)*/
  /*T(tmp_10) = G(objets) + G(argv) + G(argc)*/
  /*T(tmp_11) = G(objets) + G(argv) + G(argc)*/
  /*T(tmp_12) = G(objets) + G(argv) + G(argc)*/
  /*T(adresseText) = T*/
  /*T(adresseData) = T*/
  /*T(adresseRodata) = T*/
  /*T(adresseBss) = T*/
  /*T(adresseStack) = T*/
  /*T(nomPtEntree) = G(objets) + G(argv) + G(argc) + G(nomPtEntree)*/
  /*T(objets) = G(argv) + G(argc) + G(objets)*/
  /*T(copieSuperficielle) = G(argv) + G(argc) + G(objets) + G(copieSuperficielle)*/
  
  if (objets[0].nom == (void *)0) {/*sid:2939*/
    printf((char const   *)"%s%s\n", "erreur : ",
           "fichier resultat obligatoire");
    /*sid:2939*/
    /*T(journal) = U*/
    /*T(premiereFois) = U*/
    /*T(sectionBss) = U*/
    /*T(adresseText) = U*/
    /*T(adresseData) = U*/
    /*T(adresseRodata) = U*/
    /*T(adresseBss) = U*/
    /*T(adresseStack) = U*/
    /*T(nomPtEntree) = U*/
    /*T(boutismeHote) = U*/
    /*T(iterateurGlobal) = U*/
    /*T(objets) = U*/
    /*T(copieSuperficielle) = U*/
    /*T(objets_0) = U*/
    /*T(nbFichiersDonnees) = U*/
    
    afficherUsage();
    exit(1);}
  
  if (nbFichiersDonnees_0 != 1U) {/*sid:2945*/
    printf((char const   *)"%s%s\n", "erreur : ",
           "un fichier donnee et un seul autorise");
    /*sid:2945*/
    /*T(journal) = U*/
    /*T(premiereFois) = U*/
    /*T(sectionBss) = U*/
    /*T(adresseText) = U*/
    /*T(adresseData) = U*/
    /*T(adresseRodata) = U*/
    /*T(adresseBss) = U*/
    /*T(adresseStack) = U*/
    /*T(nomPtEntree) = U*/
    /*T(boutismeHote) = U*/
    /*T(iterateurGlobal) = U*/
    /*T(objets) = U*/
    /*T(copieSuperficielle) = U*/
    /*T(objets_0) = U*/
    /*T(nbFichiersDonnees) = U*/
    
    afficherUsage();
    exit(1);}
  
  /*sid:2949*/
  tmp_13 = strcmp((char const   *)objets[0].nom, (char const   *)objets[1].nom);
  /*sid:2949*/
  /*T(tmp_13) = G(argv) + G(objets) + G(argc)*/
  
  if (tmp_13 == 0) {/*sid:2951*/
    printf((char const   *)"%s%s%s\n", "erreur : ",
           "le fichier resultat doit etre ", "distinct du fichier donnee");
    /*sid:2951*/
    /*T(journal) = U*/
    /*T(premiereFois) = U*/
    /*T(sectionBss) = U*/
    /*T(adresseText) = U*/
    /*T(adresseData) = U*/
    /*T(adresseRodata) = U*/
    /*T(adresseBss) = U*/
    /*T(adresseStack) = U*/
    /*T(nomPtEntree) = U*/
    /*T(boutismeHote) = U*/
    /*T(iterateurGlobal) = U*/
    /*T(objets) = U*/
    /*T(copieSuperficielle) = U*/
    /*T(objets_0) = U*/
    /*T(nbFichiersDonnees) = U*/
    
    exit(1);}
  
  /*sid:3589*/
  return;
  /*sid:3589*/
  /*T(analyserLigneCommande) = G(argv) + G(objets) + G(argc)*/
  }

}
static void ouvrirObjetEntree(void) 
{ 
  
  {/*sid:2955*/
  objets[1].fd = open((char const   *)objets[1].nom, 0);
  /*sid:2955*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(ouvrirObjetEntree) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  if (objets[1].fd == -1) {perror((char const   *)objets[1].nom);
    exit(1);}
  
  /*sid:2961*/
  ouvrirObjet(& objets[1], copieSuperficielle);
  /*sid:2961*/
  /*T(objets) = G(copieSuperficielle)*/
  
  /*sid:3590*/
  return;
  /*sid:3590*/
  /*T(ouvrirObjetEntree) = U*/
  }

}
static void realiserImplantation(void) 
{ 
  
  {/*sid:2964*/
  if (copieSuperficielle)
  {/*sid:2965*/
  implanterObjet(& objets[1]);
  /*sid:2965*/
  /*T(journal) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(journal)*/
  /*T(premiereFois) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(premiereFois)*/
  /*T(sectionBss) = G(objets) + G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(sectionBss)*/
  /*T(adresseText) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText)*/
  /*T(adresseData) = G(adresseRodata) + G(adresseBss) + G(adresseText) + G(adresseData)*/
  /*T(adresseRodata) = G(adresseBss) + G(adresseData) + G(adresseText) + G(adresseRodata)*/
  /*T(adresseBss) = G(adresseText) + G(adresseData) + G(adresseRodata) + G(adresseBss)*/
  /*T(adresseStack) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(adresseStack)*/
  /*T(nomPtEntree) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(nomPtEntree)*/
  /*T(boutismeHote) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(boutismeHote)*/
  /*T(iterateurGlobal) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(iterateurGlobal)*/
  /*T(objets) = G(adresseText) + G(adresseData) + G(adresseRodata) + G(adresseBss) + G(objets)*/
  /*T(copieSuperficielle) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(copieSuperficielle)*/
  /*T(objets_0) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(objets_0)*/
  /*T(nbFichiersDonnees) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(nbFichiersDonnees)*/
  
  copierObjet(& objets[1], objets, 2U);}
  else {dupliquerObjet(& objets[1], objets, 2U);
  /*sid:2968*/
  implanterObjet(objets);
  /*sid:2968*/
  /*T(journal) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(journal)*/
  /*T(premiereFois) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(premiereFois)*/
  /*T(sectionBss) = G(objets) + G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(sectionBss)*/
  /*T(adresseText) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText)*/
  /*T(adresseData) = G(adresseRodata) + G(adresseBss) + G(adresseText) + G(adresseData)*/
  /*T(adresseRodata) = G(adresseBss) + G(adresseData) + G(adresseText) + G(adresseRodata)*/
  /*T(adresseBss) = G(adresseText) + G(adresseData) + G(adresseRodata) + G(adresseBss)*/
  /*T(adresseStack) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(adresseStack)*/
  /*T(nomPtEntree) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(nomPtEntree)*/
  /*T(boutismeHote) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(boutismeHote)*/
  /*T(iterateurGlobal) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(iterateurGlobal)*/
  /*T(objets) = G(adresseText) + G(adresseData) + G(adresseRodata) + G(adresseBss) + G(objets)*/
  /*T(copieSuperficielle) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(copieSuperficielle)*/
  /*T(objets_0) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(objets_0)*/
  /*T(nbFichiersDonnees) = G(adresseBss) + G(adresseRodata) + G(adresseData) + G(adresseText) + G(nbFichiersDonnees)*/
  }
  
  /*sid:2964*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(realiserImplantation) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3591*/
  return;
  /*sid:3591*/
  /*T(realiserImplantation) = U*/
  }

}
static void cloreObjetSortie(void) 
{ 
  
  {/*sid:2970*/
  objets[0].fd = open((char const   *)objets[0].nom, (1 | 64) | 512,
                      ((256 | 128) | (256 >> 3)) | ((256 >> 3) >> 3));
  /*sid:2970*/
  /*T(journal) = U*/
  /*T(premiereFois) = U*/
  /*T(sectionBss) = U*/
  /*T(adresseText) = U*/
  /*T(adresseData) = U*/
  /*T(adresseRodata) = U*/
  /*T(adresseBss) = U*/
  /*T(adresseStack) = U*/
  /*T(nomPtEntree) = U*/
  /*T(boutismeHote) = U*/
  /*T(iterateurGlobal) = U*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = U*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = U*/
  /*T(cloreObjetSortie) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  if (objets[0].fd == -1) {perror((char const   *)objets[0].nom);
    exit(1);}
  
  cloreObjet(objets);
  /*sid:3592*/
  return;
  /*sid:3592*/
  /*T(cloreObjetSortie) = U*/
  }

}
static void fermerObjetEntree(void) 
{ 
  
  {/*sid:2978*/
  fermerObjet(& objets[1]);
  /*sid:2978*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(fermerObjetEntree) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3593*/
  return;
  /*sid:3593*/
  /*T(fermerObjetEntree) = U*/
  }

}
static void fermerObjetSortie(void) 
{ 
  
  {/*sid:2980*/
  fermerObjet(objets);
  /*sid:2980*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(fermerObjetSortie) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3594*/
  return;
  /*sid:3594*/
  /*T(fermerObjetSortie) = U*/
  }

}
static void libererDonneesGlobales(void) 
{ 
  
  {/*sid:2982*/
  viderIterGlobal();
  /*sid:2982*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(libererDonneesGlobales) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  libererNomPointEntree();
  /*sid:3595*/
  return;
  /*sid:3595*/
  /*T(libererDonneesGlobales) = U*/
  }

}
static void afficherUsage(void) 
{ 
  
  {/*sid:2985*/
  printf((char const   *)"%s\n%s\n%s%s\n%s%s\n%s%s\n%s%s\n%s\n%s\n%s\n",
         "usage : implantation -o <resultat> <donnee>",
         "                   [ -e <symbole point d\'entree> ]",
         "                   [ -t ", "<adresse segment instructions> ]",
         "                   [ -d ",
         "<adresse segment donnees initialisees> ]",
         "                   [ -r ",
         "<adresse segment donnees en lecture seule> ]",
         "                   [ -b ",
         "<adresse segment donnees non initialisees> ]",
         "                   [ -s <adresse pile> ]",
         "                   [ -x ]", "                   [ -h ]");
  /*sid:2985*/
  /*T(journal) = U*/
  /*T(premiereFois) = U*/
  /*T(sectionBss) = U*/
  /*T(adresseText) = U*/
  /*T(adresseData) = U*/
  /*T(adresseRodata) = U*/
  /*T(adresseBss) = U*/
  /*T(adresseStack) = U*/
  /*T(nomPtEntree) = U*/
  /*T(boutismeHote) = U*/
  /*T(iterateurGlobal) = U*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = U*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = U*/
  /*T(afficherUsage) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3596*/
  return;
  /*sid:3596*/
  /*T(afficherUsage) = U*/
  }

}
extern struct _IO_FILE *stdout ;
static void analyserLigneCommande_0(int argc , char **argv ) ;
static void ouvrirObjetsEntree(void) ;
static void realiserFusion(void) ;
static void cloreObjetSortie_0(void) ;
static void fermerObjetsEntree(void) ;
static void fermerObjetSortie_0(void) ;
static void libererDonneesGlobales_0(void) ;
static void afficherUsage_0(void) ;
static ObjetEDL objets_0[13] ;
static unsigned int nbFichiersDonnees ;
static void analyserLigneCommande_0(int argc , char **argv ) 
{ unsigned int i ;
  int tmp ;
  int tmp_0 ;
  unsigned int j ;
  int tmp_1 ;
  
  {/*sid:2987*/
  objets_0[0].nom = (char *)((void *)0);
  /*sid:2987*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(analyserLigneCommande_0) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(argv) + G(argc) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(argc) = G(argc)*/
  /*T(argv) = G(argv)*/
  /*T(i) = U*/
  /*T(tmp) = U*/
  /*T(tmp_0) = U*/
  /*T(j) = U*/
  /*T(tmp_1) = U*/
  
  /*sid:2988*/
  nbFichiersDonnees = 0U;
  /*sid:2988*/
  /*T(nbFichiersDonnees) = U*/
  
  i = 1U;
  /*sid:2990*/
  while (i != (unsigned int )argc) {tmp_0 = strcmp((char const   *)*(
                                                   argv + i), "-h");
    if (tmp_0 == 0)
    {/*sid:2996*/
    afficherUsage_0(stdout);
    /*sid:2996*/
    /*T(journal) = U*/
    /*T(premiereFois) = U*/
    /*T(sectionBss) = U*/
    /*T(adresseText) = U*/
    /*T(adresseData) = U*/
    /*T(adresseRodata) = U*/
    /*T(adresseBss) = U*/
    /*T(adresseStack) = U*/
    /*T(nomPtEntree) = U*/
    /*T(boutismeHote) = U*/
    /*T(iterateurGlobal) = U*/
    /*T(objets) = U*/
    /*T(copieSuperficielle) = U*/
    /*T(objets_0) = U*/
    /*T(nbFichiersDonnees) = U*/
    
    exit(0);}
    else {tmp = strcmp((char const   *)*(argv + i), "-o");
    if (tmp == 0)
    {if (objets_0[0].nom == (void *)0)
     {i ++;
     if (i != (unsigned int )argc)
     {if ((int )*(*(argv + i) + 0) != '-')
      {memoriserNomObjet(objets_0, *(argv + i));}
      else {/*sid:3008*/
      printf((char const   *)"%s%s\n", "erreur : ",
             "-o doit etre suivi d\'un nom de fichier");
      /*sid:3008*/
      /*T(journal) = U*/
      /*T(premiereFois) = U*/
      /*T(sectionBss) = U*/
      /*T(adresseText) = U*/
      /*T(adresseData) = U*/
      /*T(adresseRodata) = U*/
      /*T(adresseBss) = U*/
      /*T(adresseStack) = U*/
      /*T(nomPtEntree) = U*/
      /*T(boutismeHote) = U*/
      /*T(iterateurGlobal) = U*/
      /*T(objets) = U*/
      /*T(copieSuperficielle) = U*/
      /*T(objets_0) = U*/
      /*T(nbFichiersDonnees) = U*/
      
      exit(1);}
     }
     else {/*sid:3010*/
     printf((char const   *)"%s%s\n", "erreur : ",
            "-o doit etre suivi d\'un nom de fichier");
     /*sid:3010*/
     /*T(journal) = U*/
     /*T(premiereFois) = U*/
     /*T(sectionBss) = U*/
     /*T(adresseText) = U*/
     /*T(adresseData) = U*/
     /*T(adresseRodata) = U*/
     /*T(adresseBss) = U*/
     /*T(adresseStack) = U*/
     /*T(nomPtEntree) = U*/
     /*T(boutismeHote) = U*/
     /*T(iterateurGlobal) = U*/
     /*T(objets) = U*/
     /*T(copieSuperficielle) = U*/
     /*T(objets_0) = U*/
     /*T(nbFichiersDonnees) = U*/
     
     exit(1);}
     }
     else {/*sid:3012*/
     printf((char const   *)"%s%s\n", "erreur : ",
            "un seul fichier resultat autorise");
     /*sid:3012*/
     /*T(journal) = U*/
     /*T(premiereFois) = U*/
     /*T(sectionBss) = U*/
     /*T(adresseText) = U*/
     /*T(adresseData) = U*/
     /*T(adresseRodata) = U*/
     /*T(adresseBss) = U*/
     /*T(adresseStack) = U*/
     /*T(nomPtEntree) = U*/
     /*T(boutismeHote) = U*/
     /*T(iterateurGlobal) = U*/
     /*T(objets) = U*/
     /*T(copieSuperficielle) = U*/
     /*T(objets_0) = U*/
     /*T(nbFichiersDonnees) = U*/
     
     exit(1);}
    }
    else {if ((int )*(*(argv + i) + 0) != '-')
          {if (nbFichiersDonnees != (unsigned int )(13 - 1))
           {nbFichiersDonnees ++;
           memoriserNomObjet(& objets_0[nbFichiersDonnees], *(argv + i));}
           else {/*sid:3020*/
           printf((char const   *)"%s%s%d\n", "erreur : ",
                  "le nb. de fichiers d\'entree doit etre < ", 13);
           /*sid:3020*/
           /*T(journal) = U*/
           /*T(premiereFois) = U*/
           /*T(sectionBss) = U*/
           /*T(adresseText) = U*/
           /*T(adresseData) = U*/
           /*T(adresseRodata) = U*/
           /*T(adresseBss) = U*/
           /*T(adresseStack) = U*/
           /*T(nomPtEntree) = U*/
           /*T(boutismeHote) = U*/
           /*T(iterateurGlobal) = U*/
           /*T(objets) = U*/
           /*T(copieSuperficielle) = U*/
           /*T(objets_0) = U*/
           /*T(nbFichiersDonnees) = U*/
           
           exit(1);}
          }
          else {/*sid:3022*/
          printf((char const   *)"%s\n", "erreur : argument invalide");
          /*sid:3022*/
          /*T(journal) = U*/
          /*T(premiereFois) = U*/
          /*T(sectionBss) = U*/
          /*T(adresseText) = U*/
          /*T(adresseData) = U*/
          /*T(adresseRodata) = U*/
          /*T(adresseBss) = U*/
          /*T(adresseStack) = U*/
          /*T(nomPtEntree) = U*/
          /*T(boutismeHote) = U*/
          /*T(iterateurGlobal) = U*/
          /*T(objets) = U*/
          /*T(copieSuperficielle) = U*/
          /*T(objets_0) = U*/
          /*T(nbFichiersDonnees) = U*/
          
          afficherUsage_0();
          exit(1);}
    }
    }
    
    i ++;}
  
  /*sid:2990*/
  /*T(objets_0) = G(argv) + G(argc)*/
  /*T(nbFichiersDonnees) = G(argv) + G(argc)*/
  /*T(i) = G(argv) + G(argc)*/
  /*T(tmp) = G(argv) + G(argc)*/
  /*T(tmp_0) = G(argv) + G(argc)*/
  
  if (objets_0[0].nom == (void *)0) {/*sid:3028*/
    printf((char const   *)"%s%s\n", "erreur : ",
           "fichier resultat obligatoire");
    /*sid:3028*/
    /*T(journal) = U*/
    /*T(premiereFois) = U*/
    /*T(sectionBss) = U*/
    /*T(adresseText) = U*/
    /*T(adresseData) = U*/
    /*T(adresseRodata) = U*/
    /*T(adresseBss) = U*/
    /*T(adresseStack) = U*/
    /*T(nomPtEntree) = U*/
    /*T(boutismeHote) = U*/
    /*T(iterateurGlobal) = U*/
    /*T(objets) = U*/
    /*T(copieSuperficielle) = U*/
    /*T(objets_0) = U*/
    /*T(nbFichiersDonnees) = U*/
    
    afficherUsage_0();
    exit(1);}
  
  if (nbFichiersDonnees < 1U) {/*sid:3034*/
    printf((char const   *)"%s%s\n", "erreur : ",
           "un fichier donnee au moins est requis");
    /*sid:3034*/
    /*T(journal) = U*/
    /*T(premiereFois) = U*/
    /*T(sectionBss) = U*/
    /*T(adresseText) = U*/
    /*T(adresseData) = U*/
    /*T(adresseRodata) = U*/
    /*T(adresseBss) = U*/
    /*T(adresseStack) = U*/
    /*T(nomPtEntree) = U*/
    /*T(boutismeHote) = U*/
    /*T(iterateurGlobal) = U*/
    /*T(objets) = U*/
    /*T(copieSuperficielle) = U*/
    /*T(objets_0) = U*/
    /*T(nbFichiersDonnees) = U*/
    
    afficherUsage_0();
    exit(1);}
  
  i = 0U;
  /*sid:3039*/
  while (i != nbFichiersDonnees + 1U) {j = i + 1U;
    while (j != nbFichiersDonnees + 1U) {tmp_1 = strcmp((char const   *)objets_0[j].nom,
                                                        (char const   *)objets_0[i].nom);
      if (tmp_1 == 0) {/*sid:3050*/
        printf((char const   *)"%s%s%s\n", "erreur : ",
               "les fichiers resultat et donnees ",
               "doivent etre distincts deux a deux");
        /*sid:3050*/
        /*T(journal) = U*/
        /*T(premiereFois) = U*/
        /*T(sectionBss) = U*/
        /*T(adresseText) = U*/
        /*T(adresseData) = U*/
        /*T(adresseRodata) = U*/
        /*T(adresseBss) = U*/
        /*T(adresseStack) = U*/
        /*T(nomPtEntree) = U*/
        /*T(boutismeHote) = U*/
        /*T(iterateurGlobal) = U*/
        /*T(objets) = U*/
        /*T(copieSuperficielle) = U*/
        /*T(objets_0) = U*/
        /*T(nbFichiersDonnees) = U*/
        
        exit(1);}
      
      j ++;}
    
    i ++;}
  
  /*sid:3039*/
  /*T(j) = G(argv) + G(argc)*/
  /*T(tmp_1) = G(argv) + G(argc)*/
  
  /*sid:3597*/
  return;
  /*sid:3597*/
  /*T(analyserLigneCommande_0) = G(argv) + G(argc)*/
  }

}
static void ouvrirObjetsEntree(void) 
{ unsigned int i ;
  unsigned int tmp ;
  
  {/*sid:3056*/
  i = 1U;
  /*sid:3056*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(ouvrirObjetsEntree) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(i) = U*/
  /*T(tmp) = U*/
  
  /*sid:3057*/
  while (i != nbFichiersDonnees + 1U) {/*sid:3061*/
    objets_0[i].fd = open((char const   *)objets_0[i].nom, 0);
    /*sid:3061*/
    /*T(objets_0) = G(nbFichiersDonnees)*/
    
    if (objets_0[i].fd == -1) {perror((char const   *)objets_0[i].nom);
      exit(1);}
    
    ouvrirObjet(& objets_0[i], 0U);
    if (i != 1U) {tmp = sontCompatibles(& objets_0[i], & objets_0[1]);
      if (! tmp) {/*sid:3073*/
        printf((char const   *)"%s%s%s%s%s\n", "erreur : ",
               "caracteristiques du fichier (", objets_0[i].nom,
               ") incompatibles avec celle du fichier ", objets_0[1].nom);
        /*sid:3073*/
        /*T(journal) = U*/
        /*T(premiereFois) = U*/
        /*T(sectionBss) = U*/
        /*T(adresseText) = U*/
        /*T(adresseData) = U*/
        /*T(adresseRodata) = U*/
        /*T(adresseBss) = U*/
        /*T(adresseStack) = U*/
        /*T(nomPtEntree) = U*/
        /*T(boutismeHote) = U*/
        /*T(iterateurGlobal) = U*/
        /*T(objets) = U*/
        /*T(copieSuperficielle) = U*/
        /*T(objets_0) = U*/
        /*T(nbFichiersDonnees) = U*/
        /*T(i) = U*/
        
        exit(1);}
      }
    
    /*sid:3076*/
    i ++;
    /*sid:3076*/
    /*T(objets_0) = G(nbFichiersDonnees) + G(objets_0)*/
    }
  
  /*sid:3057*/
  /*T(objets_0) = G(nbFichiersDonnees) + G(objets_0)*/
  /*T(i) = G(nbFichiersDonnees)*/
  /*T(tmp) = G(nbFichiersDonnees)*/
  
  /*sid:3598*/
  return;
  /*sid:3598*/
  /*T(ouvrirObjetsEntree) = G(nbFichiersDonnees)*/
  }

}
static void realiserFusion(void) 
{ unsigned int nbSections ;
  unsigned int i ;
  
  {/*sid:3078*/
  nbSections = 0U;
  /*sid:3078*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(realiserFusion) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(nbSections) = U*/
  /*T(i) = U*/
  
  i = 1U;
  /*sid:3080*/
  while (i <= nbFichiersDonnees) {nbSections += objets_0[i].nbSections;
    i ++;}
  
  /*sid:3080*/
  /*T(nbSections) = G(objets_0) + G(nbFichiersDonnees)*/
  /*T(i) = G(nbFichiersDonnees)*/
  
  /*sid:3086*/
  creerObjet(objets_0, & objets_0[1], 1U, nbSections);
  /*sid:3086*/
  /*T(objets_0) = G(nbFichiersDonnees) + G(objets_0)*/
  
  /*sid:3087*/
  fusionnerObjet(objets_0);
  /*sid:3087*/
  /*T(objets_0) = G(iterateurGlobal) + G(nbFichiersDonnees) + G(objets_0)*/
  
  /*sid:3599*/
  return;
  /*sid:3599*/
  /*T(realiserFusion) = U*/
  }

}
static void cloreObjetSortie_0(void) 
{ 
  
  {/*sid:3089*/
  objets_0[0].fd = open((char const   *)objets_0[0].nom, (1 | 64) | 512,
                        ((256 | 128) | (256 >> 3)) | ((256 >> 3) >> 3));
  /*sid:3089*/
  /*T(journal) = U*/
  /*T(premiereFois) = U*/
  /*T(sectionBss) = U*/
  /*T(adresseText) = U*/
  /*T(adresseData) = U*/
  /*T(adresseRodata) = U*/
  /*T(adresseBss) = U*/
  /*T(adresseStack) = U*/
  /*T(nomPtEntree) = U*/
  /*T(boutismeHote) = U*/
  /*T(iterateurGlobal) = U*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = U*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = U*/
  /*T(cloreObjetSortie_0) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  if (objets_0[0].fd == -1) {perror((char const   *)objets_0[0].nom);
    exit(1);}
  
  cloreObjet(objets_0);
  /*sid:3600*/
  return;
  /*sid:3600*/
  /*T(cloreObjetSortie_0) = U*/
  }

}
static void fermerObjetsEntree(void) 
{ unsigned int i ;
  
  {/*sid:3097*/
  i = 1U;
  /*sid:3097*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(fermerObjetsEntree) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(i) = U*/
  
  /*sid:3098*/
  while (i != nbFichiersDonnees + 1U) {fermerObjet(& objets_0[i]);
    i ++;}
  
  /*sid:3098*/
  /*T(objets_0) = G(nbFichiersDonnees) + G(objets_0)*/
  /*T(i) = G(nbFichiersDonnees)*/
  
  /*sid:3601*/
  return;
  /*sid:3601*/
  /*T(fermerObjetsEntree) = U*/
  }

}
static void fermerObjetSortie_0(void) 
{ 
  
  {/*sid:3105*/
  fermerObjet(objets_0);
  /*sid:3105*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(fermerObjetSortie_0) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3602*/
  return;
  /*sid:3602*/
  /*T(fermerObjetSortie_0) = U*/
  }

}
static void libererDonneesGlobales_0(void) 
{ 
  
  {/*sid:3107*/
  viderIterGlobal();
  /*sid:3107*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(libererDonneesGlobales_0) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3603*/
  return;
  /*sid:3603*/
  /*T(libererDonneesGlobales_0) = U*/
  }

}
static void afficherUsage_0(void) 
{ 
  
  {/*sid:3109*/
  printf((char const   *)"%s%s\n",
         "usage : fusion -o resultat donnee1 [donnee2 [...]]",
         "             [ -h ]");
  /*sid:3109*/
  /*T(journal) = U*/
  /*T(premiereFois) = U*/
  /*T(sectionBss) = U*/
  /*T(adresseText) = U*/
  /*T(adresseData) = U*/
  /*T(adresseRodata) = U*/
  /*T(adresseBss) = U*/
  /*T(adresseStack) = U*/
  /*T(nomPtEntree) = U*/
  /*T(boutismeHote) = U*/
  /*T(iterateurGlobal) = U*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = U*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = U*/
  /*T(afficherUsage_0) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3604*/
  return;
  /*sid:3604*/
  /*T(afficherUsage_0) = U*/
  }

}
void creerSectionCode(struct StructSectionEDL *section ,
                      unsigned int tailleMax ) 
{ 
  
  {/*sid:3111*/
  section->contenuElf = calloc(tailleMax, 1U);
  /*sid:3111*/
  /*T(section) = G(section)*/
  /*T(tailleMax) = G(tailleMax)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(creerSectionCode) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(tailleMax) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3605*/
  return;
  /*sid:3605*/
  /*T(creerSectionCode) = U*/
  }

}
void cloreSectionCode(struct StructSectionEDL *section ) 
{ Elf_Data *descripteurContenu ;
  
  {/*sid:3113*/
  descripteurContenu = section->descripteurContenu;
  /*sid:3113*/
  /*T(section) = G(section)*/
  /*T(descripteurContenu) = G(section)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(cloreSectionCode) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  descripteurContenu->d_buf = section->contenuElf;
  /*sid:3606*/
  return;
  /*sid:3606*/
  /*T(cloreSectionCode) = U*/
  }

}
void fermerSectionCode(struct StructSectionEDL *section ) 
{ 
  
  {/*sid:3117*/
  if ((section->objetParent)->mode == (ModeOuvertureEDL )ELF_C_WRITE_2) {if
     (section->parentInitial == (void *)0) {if (section->contenuElf != (void *)0) {
                                              free(section->contenuElf);
                                              section->contenuElf = (void *)0;}
    }
    }
  
  /*sid:3117*/
  /*T(section) = G(section)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(fermerSectionCode) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3607*/
  return;
  /*sid:3607*/
  /*T(fermerSectionCode) = G(section)*/
  }

}
void fusionnerSectionCode(struct StructSectionEDL *sectionSource ,
                          struct StructSectionEDL *sectionCible ) 
{ unsigned int tailleSource ;
  unsigned int tailleCible ;
  char *contenuSource ;
  char *contenuCible ;
  unsigned int i ;
  
  {/*sid:3128*/
  tailleSource = sectionSource->tailleContenuElf;
  /*sid:3128*/
  /*T(sectionSource) = G(sectionSource)*/
  /*T(sectionCible) = G(sectionCible)*/
  /*T(tailleSource) = G(sectionSource)*/
  /*T(tailleCible) = U*/
  /*T(contenuSource) = U*/
  /*T(contenuCible) = U*/
  /*T(i) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(fusionnerSectionCode) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(sectionCible) + G(sectionSource) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3129*/
  tailleCible = sectionCible->tailleContenuElf;
  /*sid:3129*/
  /*T(tailleCible) = G(sectionCible)*/
  
  /*sid:3130*/
  contenuSource = (char *)sectionSource->contenuElf;
  /*sid:3130*/
  /*T(contenuSource) = G(sectionSource)*/
  
  /*sid:3131*/
  contenuCible = (char *)sectionCible->contenuElf;
  /*sid:3131*/
  /*T(contenuCible) = G(sectionCible)*/
  
  i = 0U;
  /*sid:3133*/
  while (i < tailleSource) {*(contenuCible + (tailleCible + i)) = *(contenuSource + i);
    i ++;}
  
  /*sid:3133*/
  /*T(contenuCible) = G(sectionSource) + G(sectionCible)*/
  /*T(i) = G(sectionSource)*/
  
  /*sid:3139*/
  tailleCible += tailleSource;
  /*sid:3139*/
  /*T(tailleCible) = G(sectionCible) + G(sectionSource)*/
  
  /*sid:3140*/
  sectionCible->tailleContenuElf = tailleCible;
  /*sid:3140*/
  /*T(sectionCible) = G(sectionSource) + G(sectionCible)*/
  
  /*sid:3608*/
  return;
  /*sid:3608*/
  /*T(fusionnerSectionCode) = U*/
  }

}
void afficherChaines(struct StructSectionEDL *section ) ;
static unsigned int estSuffixe(ChaineEDL *petiteChaine ,
                               ChaineEDL *grandeChaine ) ;
static void libererFormatInterneChaines(struct StructSectionEDL *section ) ;
void ouvrirTableChaines(struct StructSectionEDL *section ) 
{ char *chainesSource ;
  ChaineEDL **chainesCible ;
  unsigned int nbMax ;
  unsigned int index_0 ;
  char *chaine ;
  size_t tmp_1 ;
  
  {/*sid:3142*/
  section->tableChaines = (struct StructTableChainesEDL *)calloc(1U,
                                                                 sizeof(TableChainesEDL ));
  /*sid:3142*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(ouvrirTableChaines) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(chainesSource) = U*/
  /*T(chainesCible) = U*/
  /*T(nbMax) = U*/
  /*T(index_0) = U*/
  /*T(chaine) = U*/
  /*T(tmp_1) = U*/
  
  /*sid:3143*/
  chainesSource = (char *)section->contenuElf;
  /*sid:3143*/
  /*T(chainesSource) = G(section)*/
  
  nbMax = 0U;
  index_0 = 0U;
  /*sid:3146*/
  while (index_0 != section->tailleContenuElf) {if ((int )*(chainesSource + index_0) == '\000') {
                                                  nbMax ++;}
    
    index_0 ++;}
  
  /*sid:3146*/
  /*T(nbMax) = G(section)*/
  /*T(index_0) = G(section)*/
  
  /*sid:3155*/
  chainesCible = (ChaineEDL **)calloc(nbMax, sizeof(ChaineEDL *));
  /*sid:3155*/
  /*T(chainesCible) = G(section)*/
  
  (section->tableChaines)->chaines = chainesCible;
  (section->tableChaines)->nbChaines = 0U;
  (section->tableChaines)->nbMax = nbMax;
  /*sid:3159*/
  index_0 = 0U;
  /*sid:3159*/
  /*T(index_0) = U*/
  
  /*sid:3160*/
  while (index_0 != section->tailleContenuElf) {chaine = chainesSource + index_0;
    ajouterChaine(section, chaine, index_0, 0U, (ChaineEDL **)((void *)0));
    {tmp_1 = strlen((char const   *)chaine);
     index_0 += tmp_1 + (size_t )1;}}
  
  /*sid:3160*/
  /*T(index_0) = G(section)*/
  /*T(chaine) = G(section)*/
  /*T(tmp_1) = G(section)*/
  
  /*sid:3609*/
  return;
  /*sid:3609*/
  /*T(ouvrirTableChaines) = U*/
  }

}
void creerTableChaines(struct StructSectionEDL *section , unsigned int nbMax ) 
{ 
  
  {/*sid:3170*/
  section->contenuElf = (void *)0;
  /*sid:3170*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(creerTableChaines) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(nbMax) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(nbMax) = G(nbMax)*/
  
  section->tableChaines = (struct StructTableChainesEDL *)calloc(1U,
                                                                 sizeof(TableChainesEDL ));
  (section->tableChaines)->chaines = (ChaineEDL **)calloc(nbMax,
                                                          sizeof(ChaineEDL *));
  (section->tableChaines)->nbChaines = 0U;
  /*sid:3174*/
  (section->tableChaines)->nbMax = nbMax;
  /*sid:3174*/
  /*T(section) = G(nbMax) + G(section)*/
  
  ajouterChaine(section, (char *)"", 0U, 0U, (ChaineEDL **)((void *)0));
  /*sid:3610*/
  return;
  /*sid:3610*/
  /*T(creerTableChaines) = U*/
  }

}
void copierContenuChaines(struct StructSectionEDL *tableSource ,
                          struct StructSectionEDL *tableCible ) 
{ ChaineEDL **chainesSource ;
  unsigned int nbChaines ;
  unsigned int i ;
  
  {/*sid:3177*/
  chainesSource = (tableSource->tableChaines)->chaines;
  /*sid:3177*/
  /*T(tableSource) = G(tableSource)*/
  /*T(tableCible) = G(tableCible)*/
  /*T(chainesSource) = G(tableSource)*/
  /*T(nbChaines) = U*/
  /*T(i) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(copierContenuChaines) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(tableCible) + G(tableSource) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3178*/
  nbChaines = (tableSource->tableChaines)->nbChaines;
  /*sid:3178*/
  /*T(nbChaines) = G(tableSource)*/
  
  i = 1U;
  /*sid:3180*/
  while (i != nbChaines) {ajouterChaine(tableCible,
                                        (*(chainesSource + i))->chaine,
                                        (*(chainesSource + i))->indexElf,
                                        (*(chainesSource + i))->estSuffixe,
                                        (ChaineEDL **)((void *)0));
    i ++;}
  
  /*sid:3180*/
  /*T(tableCible) = G(tableSource) + G(tableCible)*/
  /*T(i) = G(tableSource)*/
  
  /*sid:3611*/
  return;
  /*sid:3611*/
  /*T(copierContenuChaines) = U*/
  }

}
void cloreTableChaines(struct StructSectionEDL *section ) 
{ 
  
  /*sid:3612*/
  return;
  /*sid:3612*/
  /*T(section) = G(section)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(cloreTableChaines) = U*/
  

}
void fermerTableChaines(struct StructSectionEDL *section ) 
{ 
  
  {/*sid:3188*/
  libererFormatInterneChaines(section);
  /*sid:3188*/
  /*T(section) = G(section)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(fermerTableChaines) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  if ((section->objetParent)->mode == (ModeOuvertureEDL )ELF_C_WRITE_3) {if
     (section->contenuElf != (void *)0) {free(section->contenuElf);
    section->contenuElf = (void *)0;}
    }
  
  /*sid:3613*/
  return;
  /*sid:3613*/
  /*T(fermerTableChaines) = G(section)*/
  }

}
void fusionnerTableChaines(struct StructSectionEDL *sectionSource ,
                           struct StructSectionEDL *sectionCible ) 
{ ChaineEDL **chainesSource ;
  unsigned int nbChaines ;
  unsigned int i ;
  
  {/*sid:3198*/
  chainesSource = (sectionSource->tableChaines)->chaines;
  /*sid:3198*/
  /*T(sectionSource) = G(sectionSource)*/
  /*T(sectionCible) = G(sectionCible)*/
  /*T(chainesSource) = G(sectionSource)*/
  /*T(nbChaines) = U*/
  /*T(i) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(fusionnerTableChaines) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(sectionCible) + G(sectionSource) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3199*/
  nbChaines = (sectionCible->tableChaines)->nbChaines;
  /*sid:3199*/
  /*T(nbChaines) = G(sectionCible)*/
  
  i = 1U;
  /*sid:3201*/
  while (i != nbChaines) {ajouterChaine(sectionCible,
                                        (*(chainesSource + i))->chaine, 0U,
                                        0U, (ChaineEDL **)((void *)0));
    i ++;}
  
  /*sid:3201*/
  /*T(sectionCible) = G(sectionSource) + G(sectionCible)*/
  /*T(i) = G(sectionCible)*/
  
  /*sid:3614*/
  return;
  /*sid:3614*/
  /*T(fusionnerTableChaines) = U*/
  }

}
void ajouterChaine(struct StructSectionEDL *section , char *chaineC ,
                   unsigned int index_0 , unsigned int estSuffixe_0 ,
                   ChaineEDL **chaineAjoutee ) 
{ ChaineEDL **chaines ;
  unsigned int nbChaines ;
  unsigned int nbMax ;
  ChaineEDL *chaineEdl ;
  unsigned int i ;
  int tmp ;
  
  {/*sid:3208*/
  chaines = (section->tableChaines)->chaines;
  /*sid:3208*/
  /*T(section) = G(section)*/
  /*T(chaineC) = G(chaineC)*/
  /*T(index_0) = G(index_0)*/
  /*T(estSuffixe_0) = G(estSuffixe_0)*/
  /*T(chaineAjoutee) = G(chaineAjoutee)*/
  /*T(chaines) = G(section)*/
  /*T(nbChaines) = U*/
  /*T(nbMax) = U*/
  /*T(chaineEdl) = U*/
  /*T(i) = U*/
  /*T(tmp) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(ajouterChaine) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(chaineAjoutee) + G(index_0) + G(section) + G(chaineC) + G(estSuffixe_0) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3209*/
  nbChaines = (section->tableChaines)->nbChaines;
  /*sid:3209*/
  /*T(nbChaines) = G(section)*/
  
  i = 0U;
  /*sid:3211*/
  while (i != nbChaines) {tmp = strcmp((char const   *)(*(chaines + i))->chaine,
                                       (char const   *)chaineC);
    if (tmp == 0) {break;}
    
    i ++;}
  
  /*sid:3211*/
  /*T(i) = G(chaineC) + G(section)*/
  /*T(tmp) = G(chaineC) + G(section)*/
  
  if (i != nbChaines)
  {/*sid:3222*/
  chaineEdl = *(chaines + i);
  /*sid:3222*/
  /*T(chaineEdl) = G(chaineC) + G(section)*/
  }
  else {/*sid:3223*/
  nbMax = (section->tableChaines)->nbMax;
  /*sid:3223*/
  /*T(nbMax) = G(chaineC) + G(section)*/
  
  if (nbChaines == nbMax) {nbMax ++;
    /*sid:3227*/
    chaines = (ChaineEDL **)realloc((void *)chaines,
                                    nbMax * sizeof(ChaineEDL *));
    /*sid:3227*/
    /*T(chaines) = G(chaineC) + G(section)*/
    
    /*sid:3228*/
    (section->tableChaines)->nbMax = nbMax;
    /*sid:3228*/
    /*T(section) = G(chaineC) + G(section)*/
    
    (section->tableChaines)->chaines = chaines;}
  
  /*sid:3231*/
  chaineEdl = creationChaine(chaineC, index_0, estSuffixe_0);
  /*sid:3231*/
  /*T(section) = G(chaineC) + G(section)*/
  /*T(chaines) = G(chaineC) + G(section)*/
  /*T(chaineEdl) = G(index_0) + G(estSuffixe_0) + G(chaineC) + G(section)*/
  
  /*sid:3232*/
  *(chaines + nbChaines) = chaineEdl;
  /*sid:3232*/
  /*T(chaines) = G(index_0) + G(estSuffixe_0) + G(chaineC) + G(section)*/
  
  (section->tableChaines)->nbChaines = nbChaines + 1U;
  if (chaineAjoutee == (void *)0) {/*sid:3236*/
    chaineEdl->nbReferences = 0U;
    /*sid:3236*/
    /*T(chaineEdl) = G(estSuffixe_0) + G(index_0) + G(chaineAjoutee) + G(chaineC) + G(section)*/
    }
  }
  
  /*sid:3239*/
  if (chaineAjoutee != (void *)0) {(chaineEdl->nbReferences) ++;
    /*sid:3241*/
    *chaineAjoutee = chaineEdl;
    /*sid:3241*/
    /*T(chaineAjoutee) = G(section) + G(chaineC) + G(estSuffixe_0) + G(index_0) + G(chaineAjoutee)*/
    }
  
  /*sid:3239*/
  /*T(section) = G(chaineC) + G(section)*/
  /*T(chaines) = G(chaineC) + G(estSuffixe_0) + G(index_0) + G(section)*/
  /*T(nbMax) = G(chaineC) + G(section)*/
  /*T(chaineEdl) = G(estSuffixe_0) + G(index_0) + G(chaineAjoutee) + G(chaineC) + G(section)*/
  
  /*sid:3615*/
  return;
  /*sid:3615*/
  /*T(chaineAjoutee) = G(section) + G(chaineC) + G(estSuffixe_0) + G(index_0) + G(chaineAjoutee)*/
  /*T(ajouterChaine) = G(chaineC) + G(section)*/
  }

}
void supprimerChaine(struct StructSectionEDL *section , ChaineEDL *chaine ) 
{ TableChainesEDL *tableChaines ;
  ChaineEDL **chaines ;
  unsigned int nbChaines ;
  unsigned int i ;
  
  {/*sid:3244*/
  tableChaines = section->tableChaines;
  /*sid:3244*/
  /*T(section) = G(section)*/
  /*T(chaine) = G(chaine)*/
  /*T(tableChaines) = G(section)*/
  /*T(chaines) = U*/
  /*T(nbChaines) = U*/
  /*T(i) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(supprimerChaine) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(chaine) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3245*/
  chaines = tableChaines->chaines;
  /*sid:3245*/
  /*T(chaines) = G(section)*/
  
  /*sid:3246*/
  nbChaines = tableChaines->nbChaines;
  /*sid:3246*/
  /*T(nbChaines) = G(section)*/
  
  i = 0U;
  /*sid:3248*/
  while (i != nbChaines) {if (*(chaines + i) == chaine) {break;}
    
    i ++;}
  
  /*sid:3248*/
  /*T(i) = G(chaine) + G(section)*/
  
  if (i != nbChaines)
  {if ((*(chaines + i))->nbReferences != 0U) {/*sid:3261*/
     ((*(chaines + i))->nbReferences) --;
     /*sid:3261*/
     /*T(chaines) = G(chaine) + G(section)*/
     }
  
  /*sid:3264*/
  if ((*(chaines + i))->nbReferences == 0U) {libererChaine(chaines + i);
    *(chaines + i) = *(chaines + (nbChaines - 1U));
    /*sid:3267*/
    tableChaines->nbChaines = nbChaines - 1U;
    /*sid:3267*/
    /*T(tableChaines) = G(chaine) + G(section)*/
    }
  
  /*sid:3264*/
  /*T(chaines) = G(chaine) + G(section)*/
  }
  else {/*sid:3269*/
  printf((char const   *)"%s%s%s%s%s%s%s\n", "panique (supprimerChaine) ! : ",
         "la chaine ", chaine->chaine,
         " n\'appartient pas a la table de chaines ", (section->nom)->chaine,
         " de l\'objet ", (section->objetParent)->nom);
  /*sid:3269*/
  /*T(journal) = U*/
  /*T(premiereFois) = U*/
  /*T(sectionBss) = U*/
  /*T(adresseText) = U*/
  /*T(adresseData) = U*/
  /*T(adresseRodata) = U*/
  /*T(adresseBss) = U*/
  /*T(adresseStack) = U*/
  /*T(nomPtEntree) = U*/
  /*T(boutismeHote) = U*/
  /*T(iterateurGlobal) = U*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = U*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = U*/
  
  exit(1);}
  
  /*sid:3616*/
  return;
  /*sid:3616*/
  /*T(tableChaines) = G(chaine) + G(section)*/
  /*T(supprimerChaine) = G(chaine) + G(section)*/
  }

}
void extraireChaineSelonIndex(struct StructSectionEDL *section ,
                              unsigned int index_0 , ChaineEDL **chaine ) 
{ char *chainesSource ;
  unsigned int tailleSource ;
  ChaineEDL **chainesCible ;
  unsigned int nbChaines ;
  char *chaineSource ;
  unsigned int i ;
  
  {/*sid:3272*/
  tailleSource = section->tailleContenuElf;
  /*sid:3272*/
  /*T(section) = G(section)*/
  /*T(index_0) = G(index_0)*/
  /*T(chaine) = G(chaine)*/
  /*T(chainesSource) = U*/
  /*T(tailleSource) = G(section)*/
  /*T(chainesCible) = U*/
  /*T(nbChaines) = U*/
  /*T(chaineSource) = U*/
  /*T(i) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(extraireChaineSelonIndex) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(chaine) + G(section) + G(index_0) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  if (index_0 < tailleSource)
  {/*sid:3275*/
  chainesSource = (char *)section->contenuElf;
  /*sid:3275*/
  /*T(chainesSource) = G(index_0) + G(section)*/
  
  /*sid:3276*/
  chainesCible = (section->tableChaines)->chaines;
  /*sid:3276*/
  /*T(chainesCible) = G(index_0) + G(section)*/
  
  if ((int )*(chainesSource + index_0) == '\000')
  {/*sid:3279*/
  *chaine = *(chainesCible + 0);
  /*sid:3279*/
  /*T(chaine) = G(section) + G(index_0) + G(chaine)*/
  }
  else {/*sid:3280*/
  nbChaines = (section->tableChaines)->nbChaines;
  /*sid:3280*/
  /*T(nbChaines) = G(index_0) + G(section)*/
  
  /*sid:3281*/
  i = nbChaines - 1U;
  /*sid:3281*/
  /*T(i) = G(index_0) + G(section)*/
  
  while (i != 0U) {if ((*(chainesCible + i))->indexElf == index_0) {break;}
    
    i --;}
  
  if (i != 0U)
  {((*(chainesCible + i))->nbReferences) ++;
  /*sid:3294*/
  *chaine = *(chainesCible + i);
  /*sid:3294*/
  /*T(chaine) = G(section) + G(index_0) + G(chaine)*/
  }
  else {/*sid:3295*/
  chaineSource = chainesSource + index_0;
  /*sid:3295*/
  /*T(chaineSource) = G(index_0) + G(section)*/
  
  /*sid:3296*/
  ajouterChaine(section, chaineSource, index_0, 1U, chaine);
  /*sid:3296*/
  /*T(section) = G(index_0) + G(section)*/
  /*T(chaine) = G(section) + G(index_0) + G(chaine)*/
  }
  }
  }
  else {/*sid:3297*/
  printf((char const   *)"%s%s%d%s%s%s%s\n",
         "panique (extraireChaineSelonIndex) ! : ", "aucune chaine d\'index ",
         index_0, " n\'existe dans la table de chaines ",
         (section->nom)->chaine, " de l\'objet ", (section->objetParent)->nom);
  /*sid:3297*/
  /*T(journal) = U*/
  /*T(premiereFois) = U*/
  /*T(sectionBss) = U*/
  /*T(adresseText) = U*/
  /*T(adresseData) = U*/
  /*T(adresseRodata) = U*/
  /*T(adresseBss) = U*/
  /*T(adresseStack) = U*/
  /*T(nomPtEntree) = U*/
  /*T(boutismeHote) = U*/
  /*T(iterateurGlobal) = U*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = U*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = U*/
  
  exit(1);}
  
  /*sid:3617*/
  return;
  /*sid:3617*/
  /*T(section) = G(index_0) + G(section)*/
  /*T(nbChaines) = G(index_0) + G(section)*/
  /*T(chaineSource) = G(index_0) + G(section)*/
  /*T(i) = G(index_0) + G(section)*/
  /*T(extraireChaineSelonIndex) = G(index_0) + G(section)*/
  }

}
unsigned int tailleTableChaines(struct StructSectionEDL *section ) 
{ unsigned int __retres ;
  
  {/*sid:3300*/
  __retres = (section->tableChaines)->nbChaines;
  /*sid:3300*/
  /*T(section) = G(section)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(tailleTableChaines) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = G(section)*/
  
  /*sid:3618*/
  return (__retres);
  /*sid:3618*/
  /*T(tailleTableChaines) = G(section)*/
  }

}
void dupliquerChaine(ChaineEDL *chaineSource , ChaineEDL **chaineCible ) 
{ char *chaineC ;
  
  {/*sid:3302*/
  if (chaineSource != (void *)0)
  {/*sid:3303*/
  chaineC = chaineSource->chaine;
  /*sid:3303*/
  /*T(chaineC) = G(chaineSource)*/
  
  *chaineCible = creationChaine(chaineC, chaineSource->indexElf,
                                chaineSource->estSuffixe);}
  else {/*sid:3305*/
  *chaineCible = (ChaineEDL *)((void *)0);
  /*sid:3305*/
  /*T(chaineCible) = G(chaineSource) + G(chaineCible)*/
  /*T(chaineC) = G(chaineSource)*/
  }
  
  /*sid:3302*/
  /*T(chaineSource) = G(chaineSource)*/
  /*T(chaineCible) = G(chaineCible)*/
  /*T(chaineC) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(dupliquerChaine) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(chaineCible) + G(chaineSource) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3619*/
  return;
  /*sid:3619*/
  /*T(chaineCible) = G(chaineSource) + G(chaineCible)*/
  /*T(dupliquerChaine) = U*/
  }

}
ChaineEDL *creationChaine(char *chaineC , unsigned int index_0 ,
                          unsigned int estSuffixe_0 ) 
{ ChaineEDL *chaine ;
  unsigned int longueur ;
  
  {/*sid:3307*/
  chaine = (ChaineEDL *)calloc(1U, sizeof(ChaineEDL ));
  /*sid:3307*/
  /*T(chaineC) = G(chaineC)*/
  /*T(index_0) = G(index_0)*/
  /*T(estSuffixe_0) = G(estSuffixe_0)*/
  /*T(chaine) = U*/
  /*T(longueur) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(creationChaine) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(estSuffixe_0) + G(chaineC) + G(index_0) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3308*/
  chaine->indexElf = index_0;
  /*sid:3308*/
  /*T(chaine) = G(index_0)*/
  
  /*sid:3309*/
  chaine->estSuffixe = estSuffixe_0;
  /*sid:3309*/
  /*T(chaine) = G(estSuffixe_0) + G(index_0)*/
  
  /*sid:3310*/
  longueur = strlen((char const   *)chaineC);
  /*sid:3310*/
  /*T(longueur) = G(chaineC)*/
  
  chaine->chaine = (char *)malloc(longueur + 1U);
  memcpy((void *)chaine->chaine, (void const   *)chaineC, longueur + 1U);
  /*sid:3313*/
  chaine->longueur = longueur;
  /*sid:3313*/
  /*T(chaine) = G(chaineC) + G(estSuffixe_0) + G(index_0)*/
  
  /*sid:3314*/
  return (chaine);
  /*sid:3314*/
  /*T(creationChaine) = G(chaineC) + G(estSuffixe_0) + G(index_0)*/
  }

}
void libererChaine(ChaineEDL **chaine ) 
{ 
  
  {/*sid:3316*/
  if (*chaine != (void *)0) {if ((*chaine)->chaine != (void *)0) {free(
                                                                  (void *)(*chaine)->chaine);}
    
    free((void *)*chaine);
    *chaine = (ChaineEDL *)((void *)0);}
  
  /*sid:3316*/
  /*T(chaine) = G(chaine)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(libererChaine) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(chaine) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3620*/
  return;
  /*sid:3620*/
  /*T(libererChaine) = U*/
  }

}
void afficherChaines(struct StructSectionEDL *section ) 
{ char *chaine ;
  unsigned int index_0 ;
  unsigned int estSuffixe_0 ;
  unsigned int longueur ;
  unsigned int nbReferences ;
  unsigned int i ;
  
  {/*sid:3325*/
  printf((char const   *)"%s", (section->objetParent)->nom);
  /*sid:3325*/
  /*T(afficherChaines) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  /*T(section) = G(section)*/
  /*T(chaine) = U*/
  /*T(index_0) = U*/
  /*T(estSuffixe_0) = U*/
  /*T(longueur) = U*/
  /*T(nbReferences) = U*/
  /*T(i) = U*/
  /*T(journal) = G(section)*/
  /*T(premiereFois) = G(section)*/
  /*T(sectionBss) = G(section)*/
  /*T(adresseText) = G(section)*/
  /*T(adresseData) = G(section)*/
  /*T(adresseRodata) = G(section)*/
  /*T(adresseBss) = G(section)*/
  /*T(adresseStack) = G(section)*/
  /*T(nomPtEntree) = G(section)*/
  /*T(boutismeHote) = G(section)*/
  /*T(iterateurGlobal) = G(section)*/
  /*T(objets) = G(section)*/
  /*T(copieSuperficielle) = G(section)*/
  /*T(objets_0) = G(section)*/
  /*T(nbFichiersDonnees) = G(section)*/
  
  if (section->nom != (void *)0) {printf((char const   *)":%s",
                                         (section->nom)->chaine);}
  
  printf((char const   *)"\n");
  /*sid:3331*/
  printf((char const   *)"%s%s%s%s%s%s\n", " numero | ", "index | ",
         "estSuffixe | ", "longueur | ", "nbRef | ", "chaine");
  /*sid:3331*/
  /*T(journal) = U*/
  /*T(premiereFois) = U*/
  /*T(sectionBss) = U*/
  /*T(adresseText) = U*/
  /*T(adresseData) = U*/
  /*T(adresseRodata) = U*/
  /*T(adresseBss) = U*/
  /*T(adresseStack) = U*/
  /*T(nomPtEntree) = U*/
  /*T(boutismeHote) = U*/
  /*T(iterateurGlobal) = U*/
  /*T(objets) = U*/
  /*T(copieSuperficielle) = U*/
  /*T(objets_0) = U*/
  /*T(nbFichiersDonnees) = U*/
  
  printf((char const   *)"%s%s%s%s%s%s\n", "--------|-", "------|-",
         "-----------|-", "---------|-", "------|-", "------");
  /*sid:3333*/
  chaine = (*((section->tableChaines)->chaines + 0))->chaine;
  /*sid:3333*/
  /*T(chaine) = G(section)*/
  
  /*sid:3334*/
  index_0 = (*((section->tableChaines)->chaines + 0))->indexElf;
  /*sid:3334*/
  /*T(index_0) = G(section)*/
  
  /*sid:3335*/
  estSuffixe_0 = (*((section->tableChaines)->chaines + 0))->estSuffixe;
  /*sid:3335*/
  /*T(estSuffixe_0) = G(section)*/
  
  /*sid:3336*/
  longueur = (*((section->tableChaines)->chaines + 0))->longueur;
  /*sid:3336*/
  /*T(longueur) = G(section)*/
  
  /*sid:3337*/
  nbReferences = (*((section->tableChaines)->chaines + 0))->nbReferences;
  /*sid:3337*/
  /*T(nbReferences) = G(section)*/
  
  printf((char const   *)"   %3d  | %5d |      %d     |   %3d    |  %2d   | %s\n",
         0, index_0, estSuffixe_0, longueur, nbReferences, chaine);
  i = 1U;
  /*sid:3340*/
  while (i != (section->tableChaines)->nbChaines) {chaine = (*((section->tableChaines)->chaines + i))->chaine;
    index_0 = (*((section->tableChaines)->chaines + i))->indexElf;
    estSuffixe_0 = (*((section->tableChaines)->chaines + i))->estSuffixe;
    longueur = (*((section->tableChaines)->chaines + i))->longueur;
    nbReferences = (*((section->tableChaines)->chaines + i))->nbReferences;
    printf((char const   *)"   %3d  | %5d |      %d     |   %3d    |  %2d   | %s\n",
           i, index_0, estSuffixe_0, longueur, nbReferences, chaine);
    i ++;}
  
  /*sid:3340*/
  /*T(i) = G(section)*/
  /*T(journal) = G(section)*/
  /*T(premiereFois) = G(section)*/
  /*T(sectionBss) = G(section)*/
  /*T(adresseText) = G(section)*/
  /*T(adresseData) = G(section)*/
  /*T(adresseRodata) = G(section)*/
  /*T(adresseBss) = G(section)*/
  /*T(adresseStack) = G(section)*/
  /*T(nomPtEntree) = G(section)*/
  /*T(boutismeHote) = G(section)*/
  /*T(iterateurGlobal) = G(section)*/
  /*T(objets) = G(section)*/
  /*T(copieSuperficielle) = G(section)*/
  /*T(objets_0) = G(section)*/
  /*T(nbFichiersDonnees) = G(section)*/
  
  printf((char const   *)"\n");
  /*sid:3621*/
  return;
  /*sid:3621*/
  /*T(afficherChaines) = U*/
  }

}
static unsigned int estSuffixe(ChaineEDL *petiteChaine ,
                               ChaineEDL *grandeChaine ) 
{ unsigned int decalage ;
  int tmp ;
  unsigned int __retres ;
  
  {/*sid:3353*/
  decalage = grandeChaine->longueur - petiteChaine->longueur;
  /*sid:3353*/
  /*T(petiteChaine) = G(petiteChaine)*/
  /*T(grandeChaine) = G(grandeChaine)*/
  /*T(decalage) = G(grandeChaine) + G(petiteChaine)*/
  /*T(tmp) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = U*/
  /*T(estSuffixe) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(grandeChaine) + G(petiteChaine) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3354*/
  tmp = strcmp((char const   *)petiteChaine->chaine,
               (char const   *)(grandeChaine->chaine + decalage));
  /*sid:3354*/
  /*T(tmp) = G(grandeChaine) + G(petiteChaine)*/
  
  /*sid:3355*/
  __retres = (unsigned int )(tmp == 0);
  /*sid:3355*/
  /*T(__retres) = G(grandeChaine) + G(petiteChaine)*/
  
  /*sid:3622*/
  return (__retres);
  /*sid:3622*/
  /*T(estSuffixe) = G(grandeChaine) + G(petiteChaine)*/
  }

}
static void libererFormatInterneChaines(struct StructSectionEDL *section ) 
{ TableChainesEDL *tableChaines ;
  unsigned int i ;
  
  {/*sid:3357*/
  if (section->tableChaines != (void *)0) {/*sid:3358*/
    tableChaines = section->tableChaines;
    /*sid:3358*/
    /*T(tableChaines) = G(section)*/
    
    if (tableChaines->chaines != (void *)0) {/*sid:3361*/
      i = 0U;
      /*sid:3361*/
      /*T(i) = G(section)*/
      
      while (i != tableChaines->nbChaines) {libererChaine(tableChaines->chaines + i);
        i ++;}
      
      free((void *)tableChaines->chaines);}
    
    /*sid:3370*/
    free((void *)section->tableChaines);
    /*sid:3370*/
    /*T(i) = G(section)*/
    
    section->tableChaines = (struct StructTableChainesEDL *)((void *)0);}
  
  /*sid:3357*/
  /*T(section) = G(section)*/
  /*T(tableChaines) = U*/
  /*T(i) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(libererFormatInterneChaines) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3623*/
  return;
  /*sid:3623*/
  /*T(tableChaines) = G(section)*/
  /*T(i) = G(section)*/
  /*T(libererFormatInterneChaines) = U*/
  }

}
void creerAutreSection(struct StructSectionEDL *section ,
                       unsigned int tailleMax ) 
{ 
  
  {/*sid:3374*/
  section->contenuElf = calloc(tailleMax, 1U);
  /*sid:3374*/
  /*T(section) = G(section)*/
  /*T(tailleMax) = G(tailleMax)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(creerAutreSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(tailleMax) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3624*/
  return;
  /*sid:3624*/
  /*T(creerAutreSection) = U*/
  }

}
void cloreAutreSection(struct StructSectionEDL *section ) 
{ Elf_Data *descripteurContenu ;
  
  {/*sid:3376*/
  descripteurContenu = section->descripteurContenu;
  /*sid:3376*/
  /*T(section) = G(section)*/
  /*T(descripteurContenu) = G(section)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(cloreAutreSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  descripteurContenu->d_buf = section->contenuElf;
  switch ((int )section->type) {case 6: 
  descripteurContenu->d_type = ELF_T_DYN;
  break;
  case 11: 
  descripteurContenu->d_type = ELF_T_SYM;
  break;
  case 15: 
  case 14: 
  case 16: 
  descripteurContenu->d_type = ELF_T_ADDR;
  break;
  case 17: 
  case 5: 
  descripteurContenu->d_type = ELF_T_WORD;
  break;
  case 7: 
  descripteurContenu->d_type = ELF_T_BYTE;
  break;
  case 4: 
  descripteurContenu->d_type = ELF_T_RELA;
  break;
  default: ;
  descripteurContenu->d_type = ELF_T_BYTE;
  break;}
  
  /*sid:3625*/
  return;
  /*sid:3625*/
  /*T(cloreAutreSection) = U*/
  }

}
void fermerAutreSection(struct StructSectionEDL *section ) 
{ 
  
  {/*sid:3396*/
  if ((section->objetParent)->mode == (ModeOuvertureEDL )ELF_C_WRITE_4) {if
     (section->parentInitial == (void *)0) {if (section->contenuElf != (void *)0) {
                                              free(section->contenuElf);
                                              section->contenuElf = (void *)0;}
    }
    }
  
  /*sid:3396*/
  /*T(section) = G(section)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(fermerAutreSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3626*/
  return;
  /*sid:3626*/
  /*T(fermerAutreSection) = G(section)*/
  }

}
void fusionnerAutreSection(struct StructSectionEDL *sectionSource ,
                           struct StructSectionEDL *sectionCible ) 
{ unsigned int tailleSource ;
  unsigned int tailleCible ;
  char *contenuSource ;
  char *contenuCible ;
  unsigned int i ;
  
  {/*sid:3407*/
  tailleSource = sectionSource->tailleContenuElf;
  /*sid:3407*/
  /*T(sectionSource) = G(sectionSource)*/
  /*T(sectionCible) = G(sectionCible)*/
  /*T(tailleSource) = G(sectionSource)*/
  /*T(tailleCible) = U*/
  /*T(contenuSource) = U*/
  /*T(contenuCible) = U*/
  /*T(i) = U*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(fusionnerAutreSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(sectionCible) + G(sectionSource) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3408*/
  tailleCible = sectionCible->tailleContenuElf;
  /*sid:3408*/
  /*T(tailleCible) = G(sectionCible)*/
  
  /*sid:3409*/
  contenuSource = (char *)sectionSource->contenuElf;
  /*sid:3409*/
  /*T(contenuSource) = G(sectionSource)*/
  
  /*sid:3410*/
  contenuCible = (char *)sectionCible->contenuElf;
  /*sid:3410*/
  /*T(contenuCible) = G(sectionCible)*/
  
  /*sid:3411*/
  tailleCible = (unsigned int )alignement((unsigned long )tailleCible,
                                          sectionSource->alignement);
  /*sid:3411*/
  /*T(tailleCible) = G(sectionCible) + G(sectionSource)*/
  
  i = 0U;
  /*sid:3413*/
  while (i < tailleSource) {*(contenuCible + (tailleCible + i)) = *(contenuSource + i);
    i ++;}
  
  /*sid:3413*/
  /*T(contenuCible) = G(sectionSource) + G(sectionCible)*/
  /*T(i) = G(sectionSource)*/
  
  tailleCible += tailleSource;
  /*sid:3420*/
  sectionCible->tailleContenuElf = tailleCible;
  /*sid:3420*/
  /*T(sectionCible) = G(sectionSource) + G(sectionCible)*/
  
  /*sid:3627*/
  return;
  /*sid:3627*/
  /*T(fusionnerAutreSection) = U*/
  }

}
unsigned int tailleAutreSection(struct StructSectionEDL *section ) 
{ unsigned int __retres ;
  
  {/*sid:3422*/
  __retres = section->tailleContenuElf;
  /*sid:3422*/
  /*T(section) = G(section)*/
  /*T(journal) = G(journal)*/
  /*T(premiereFois) = G(premiereFois)*/
  /*T(sectionBss) = G(sectionBss)*/
  /*T(adresseText) = G(adresseText)*/
  /*T(adresseData) = G(adresseData)*/
  /*T(adresseRodata) = G(adresseRodata)*/
  /*T(adresseBss) = G(adresseBss)*/
  /*T(adresseStack) = G(adresseStack)*/
  /*T(nomPtEntree) = G(nomPtEntree)*/
  /*T(boutismeHote) = G(boutismeHote)*/
  /*T(iterateurGlobal) = G(iterateurGlobal)*/
  /*T(objets) = G(objets)*/
  /*T(copieSuperficielle) = G(copieSuperficielle)*/
  /*T(objets_0) = G(objets_0)*/
  /*T(nbFichiersDonnees) = G(nbFichiersDonnees)*/
  /*T(__retres) = G(section)*/
  /*T(tailleAutreSection) = G(objets_0) + G(objets) + G(boutismeHote) + G(adresseStack) + G(adresseRodata) + G(adresseText) + G(premiereFois) + G(section) + G(journal) + G(sectionBss) + G(adresseData) + G(adresseBss) + G(nomPtEntree) + G(iterateurGlobal) + G(copieSuperficielle) + G(nbFichiersDonnees)*/
  
  /*sid:3628*/
  return (__retres);
  /*sid:3628*/
  /*T(tailleAutreSection) = G(section)*/
  }

}
